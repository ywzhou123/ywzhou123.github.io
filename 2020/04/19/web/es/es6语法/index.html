<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="月晴星飞的个人博客"><meta name="baidu-site-verification" content="2kzCiP25dA"><title>es6语法 | 月晴星飞</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script>var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?115872dc2cc8c5a96937ab18cbdd16fe";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();</script><meta name="generator" content="Hexo 4.2.0"></head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">月晴星飞</a></h1></div><p class="m-desc">夫君子之行，静以修身，俭以养德。<br>非澹泊无以明志， 非宁静无以致远。</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">es6语法</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/04/19/web/es/es6%E8%AF%AD%E6%B3%95/">2020-04-19</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/js/">js</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>/**———————————————————————————– */<br>// Arrays（数组）<br>array.find(predicate)<br>//萃取数组对象中某属性值<br>array.map(value =&gt; value[propertyName])<br>//把一个类数组转换成一个数组<br>Array.from(arguments)<br>//返回一个除去所有false值的 array副本<br>array.filter(x =&gt; !!x)<br>//返回 array去重后的副本<br>[…new Set(array)]<br>//创建一个 N个数字数组，从x开始<br>Array.from({ length: n }, (v, k) =&gt; k + x)<br>//检查数组中是否包含某个元素<br>array.includes(element)<br>// includes() 方法能找到 NaN，而 indexOf() 不行</p>
<blockquote>
<p>[NaN].includes(NaN)<br>true<br>[NaN].indexOf(NaN)<br>-1<br>[-0].includes(+0)<br>true<br>/<strong>———————————————————————————– */<br>//Objects（对象）<br>// 枚举所有的属性名，包括继承过来的<br>Reflect.enumerate(object) // 返回一个迭代器<br>//检查一个对象是否是一个有限的数字<br>Number.isFinite(object)<br>//创建一个合并属性后的新对象<br>{ …source, a: false }<br>//创建一个浅拷贝对象<br>{ …object }<br>/</strong>———————————————————————————– */<br>//Functions（函数）<br>//给对象绑定一个函数<br>foo(() =&gt; {<br>this.bar();<br>});<br>foo(object.fun.bind(object));<br>//迭代行数<br>value =&gt; value<br>//返回值的函数<br>const fun = () =&gt; value;<br>//空函数<br>() =&gt; {}</p>
</blockquote>
<p>//给对象绑定一个函数<br>foo(() =&gt; {<br>this.bar();<br>});<br>foo(::object.fun);//:: 作为一个新的绑定操作符</p>
<p>//指数运算符<br>x ** y<br>let squared = 3 ** 2; // 9<br>let num = 3;<br>num **= 2;<br>console.log(num); // 9</p>
<p>// 异步函数<br>async function fetchJson(url) {<br>try {<br>let request = await fetch(url);<br>let text = await request.text();<br>return JSON.parse(text);<br>}<br>catch (error) {<br>console.log(<code>ERROR: ${error.stack}</code>);<br>}<br>}</p>
<p>async test(){<br>return ‘aaa’<br>}<br>this.test().then(res=&gt;{<br>console.log(‘123 ‘+res)<br>})</p>
<blockquote>
<p>‘123 aaa’<br>// async函数返回的是一个Promise对象。<br>// 如果在函数中return一个直接量，<br>// async会把这个直接量通过Promise.resolve()封装成Promise对象。<br>// async函数 在没有await的情况下执行async函数，它会立即执行，并且返回一个promise对象，并且绝不会阻塞后面的语句<br>// await 暂停当前async function的执行，等待Promise处理完成</p>
</blockquote>
<p>// 异步变同步<br>getGategory(pm){<br>console.log(‘begin:’,pm)<br>return Promise((resolve,reject)=&gt;{<br>getJson(‘/goods/gategory’,date=&gt;{<br>console.log(pm)<br>resolve(data)<br>})<br>})<br>}<br>async doIt(){<br>getGategory(‘do1’)<br>getGategory(‘do2’)<br>getGategory(‘do3’)<br>}</p>
<blockquote>
<p>‘begin: do1’<br>‘do1’<br>‘begin: do2’<br>‘do2’<br>‘begin: do3’<br>‘do3’<br>//类似于一个使用了 Promises 和 generators 让编程风格看起来更像异步的库co<br>const fetchJson2 = co(function* () {<br>try {<br>let request = yield fetch(url);<br>let text = yield request.text();<br>return JSON.parse(text);<br>}<br>catch (error) {<br>console.log(<code>ERROR: ${error.stack}</code>);<br>}<br>});</p>
</blockquote>
<p>// Generator函数</p>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>// 简介<br>// 说明<br>/<em>意思是生成器，是一个状态机，封装了多个内部状态<br>返回一个遍历器对象，可以遍历每一个状态<br>function关键字与函数名之间有一个星号<br>内部使用yield语句，定义不同的内部状态<br>yield语句在英语里的意思就是“产出”</em>/<br>// 有三个状态：hello，world和return语句<br>function* helloWorldGenerator() {<br>yield ‘hello’;<br>yield ‘world’;<br>return ‘ending’;<br>}<br>// 调用Generator函数后，该函数并不执行<br>var hw = helloWorldGenerator();<br>// done属性的值false，表示遍历还没有结束<br>hw.next() // { value: ‘hello’, done: false }<br>hw.next() // { value: ‘world’, done: false }<br>// 从上次yield语句停下的地方，一直执行到return语句<br>hw.next() // { value: ‘ending’, done: true }<br>hw.next() // { value: undefined, done: true }<br>// <em>号位置可以随意<br>function * foo(x, y) { }<br>function *foo(x, y) { }<br>function</em> foo(x, y) { }<br>function*foo(x, y) { }</p>
<p>// yield语句<br>/<em>遇到yield，函数暂停执行，下一次再从该位置继续向后执行<br>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行<br>yield语句不能用在普通函数中</em>/<br>var arr = [1, [[2, 3], 4], [5, 6]];<br>var flat = function* (a) {<br>var length = a.length;<br>for (var i = 0; i &lt; length; i++) {<br>var item = a[i];<br>if (typeof item !== ‘number’) {<br>yield* flat(item);<br>} else {<br>yield item;<br>}<br>}<br>};<br>for (var f of flat(arr)) {<br>console.log(f);<br>} // 1, 2, 3, 4, 5, 6<br>// forEach方法的参数是一个普通函数，但是在里面使用了yield语句，改用for循环<br>console.log(‘Hello’ + yield); // SyntaxError<br>console.log(‘Hello’ + yield 123); // SyntaxError<br>console.log(‘Hello’ + (yield)); // OK<br>console.log(‘Hello’ + (yield 123)); // OK<br>// 用在一个表达式之中，必须放在圆括号里<br>foo(yield ‘a’, yield ‘b’); // OK<br>let input = yield; // OK<br>// 用作函数参数或赋值表达式的右边，可以不加括号<br>// 与Iterator接口的关系<br>var myIterable = {};<br>myIterable[Symbol.iterator] = function* () {<br>yield 1;<br>yield 2;<br>yield 3;<br>};<br>[…myIterable] // [1, 2, 3]<br>// 可以把Generator赋值给对象的Symbol.iterator属性<br>// 使得myIterable对象具有了Iterator接口，可以被…运算符遍历了<br>function* gen(){<br>// some code<br>}<br>var g = gen();<br>g<a href="">Symbol.iterator</a> === g // true<br>// gen是一个Generator函数，调用它会生成一个遍历器对象g<br>// Symbol.iterator属性也是一个遍历器对象生成函数，执行后返回它自己</p>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>// next的参数<br>function* f() {<br>for(var i=0; true; i++) {<br>var reset = yield i;<br>if(reset) { i = -1;<br>}<br>}<br>}<br>var g = f();<br>g.next() // { value: 0, done: false }<br>g.next() // { value: 1, done: false }<br>g.next(true) // { value: 0, done: false }<br>// next方法的参数会被当作上一个yield语句的返回值<br>// 第一次使用next方法时，不能带有参数<br>function* foo(x) {<br>var y = 2 * (yield (x + 1));<br>var z = yield (y / 3);<br>return (x + y + z);<br>}<br>var a = foo(5);<br>a.next() // Object{value:6, done:false}<br>a.next() // Object{value:NaN, done:false}<br>a.next() // Object{value:NaN, done:true}<br>var b = foo(5); b.next() // { value:6, done:false }<br>b.next(12) // { value:8, done:false }<br>b.next(13) // { value:42, done:true }<br>// a第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN）<br>// b第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8<br>// 第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24<br>function wrapper(generatorFunction) {<br>return function (…args) {<br>let generatorObject = generatorFunction(…args);<br>generatorObject.next();<br>return generatorObject;<br>};<br>}<br>const wrapped = wrapper(function* () {<br>console.log(<code>First input: ${yield}</code>);<br>return ‘DONE’;<br>});<br>wrapped().next(‘hello!’) // First input: hello!<br>// 在Generator函数外面再包一层，可以第一次调用next就输入参数<br>function* dataConsumer() {<br>console.log(‘Started’);<br>console.log(<code>1. ${yield}</code>);<br>console.log(<code>2. ${yield}</code>);<br>return ‘result’;<br>}<br>let genObj = dataConsumer();<br>genObj.next(); // Started<br>genObj.next(‘a’) // 1. a<br>genObj.next(‘b’) // 2. b</p>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>// for…of循环<br>function <em>foo() {<br>yield 1;<br>yield 2;<br>yield 3;<br>yield 4;<br>yield 5;<br>return 6;<br>}<br>for (let v of foo()) {<br>console.log(v);<br>} // 1 2 3 4 5<br>// 返回对象的done属性为true，for…of循环就会中止<br>function</em> fibonacci() {<br>let [prev, curr] = [0, 1];<br>for (;;) {<br>[prev, curr] = [curr, prev + curr];<br>yield curr;<br>}<br>}<br>for (let n of fibonacci()) {<br>if (n &gt; 1000) break;<br>console.log(n);<br>}<br>function* objectEntries(obj) {<br>let propKeys = Reflect.ownKeys(obj);<br>for (let propKey of propKeys) {<br>yield [propKey, obj[propKey]];<br>}<br>}<br>let jane = { first: ‘Jane’, last: ‘Doe’ };<br>for (let [key, value] of objectEntries(jane)) {<br>console.log(<code>${key}: ${value}</code>);<br>} // first: Jane // last: Doe<br>// object通过Generator函数为它加上遍历接口<br>function* objectEntries() {<br>let propKeys = Object.keys(this);<br>for (let propKey of propKeys) {<br>yield [propKey, this[propKey]];<br>}<br>}<br>let jane = { first: ‘Jane’, last: ‘Doe’ };<br>jane[Symbol.iterator] = objectEntries;<br>for (let [key, value] of jane) {<br>console.log(<code>${key}: ${value}</code>);<br>} // first: Jane // last: Doe<br>// 或者将Generator函数加到对象的Symbol.iterator属性上面<br>function* numbers () {<br>yield 1<br>yield 2<br>return 3<br>yield 4<br>}<br>// 扩展运算符<br>[…numbers()] // [1, 2]<br>// Array.from 方法<br>Array.from(numbers()) // [1, 2]<br>// 解构赋值<br>let [x, y] = numbers();<br>x // 1<br>y // 2<br>// for…of 循环<br>for (let n of numbers()) {<br>console.log(n)<br>} // 1 // 2<br>// 扩展运算符（…）、解构赋值和Array.from方法都是遍历器接口<br>// 都可以将Generator函数返回的Iterator对象，作为参数</p>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>// throw()<br>var g = function* () {<br>try {<br>yield;<br>} catch (e) {<br>console.log(‘内部捕获’, e);<br>}<br>};<br>var i = g();<br>i.next();<br>try {<br>i.throw(‘a’);<br>i.throw(‘b’);<br>} catch (e) {<br>console.log(‘外部捕获’, e);<br>}<br>// 内部捕获 a<br>// 外部捕获 b<br>// 第一个错误被Generator函数体内的catch语句捕获<br>// 第二次抛出错误，Generator函数内部的catch语句已经执行过了，不会再捕捉<br>// 错误就被抛出了Generator函数体，被函数体外的catch语句捕获<br>var g = function* () {<br>try {<br>yield;<br>} catch (e) {<br>console.log(e);<br>}<br>};<br>var i = g();<br>i.next();<br>i.throw(new Error(‘出错了！’)); // Error: 出错了！(…)<br>// 可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例<br>var g = function* () {<br>while (true) {<br>yield;<br>console.log(‘内部捕获’, e);<br>}<br>};<br>var i = g();<br>i.next();<br>try {<br>i.throw(‘a’);<br>i.throw(‘b’);<br>} catch (e) {<br>console.log(‘外部捕获’, e);<br>} // 外部捕获 a<br>// 内部没有部署try…catch代码块<br>// 抛出的错误直接被外部catch代码块捕获<br>var gen = function* gen(){<br>yield console.log(‘hello’);<br>yield console.log(‘world’);<br>}<br>var g = gen();<br>g.next();<br>g.throw(); // hello // Uncaught undefined<br>// 内部和外部，都没有部署try…catch代码块<br>// 程序将报错，直接中断执行<br>var gen = function* gen(){<br>try {<br>yield console.log(‘a’);<br>} catch (e) {<br>// …<br>}<br>yield console.log(‘b’);<br>yield console.log(‘c’);<br>}<br>var g = gen();<br>g.next() // a<br>g.throw() // b<br>g.next() // c<br>// throw方法被捕获以后，会附带执行下一条yield语句</p>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>// return()</p>
<p>function* gen() {<br>yield 1;<br>yield 2;<br>yield 3;<br>}<br>var g = gen();<br>g.next() // { value: 1, done: false }<br>g.return(‘foo’) // { value: “foo”, done: true }<br>g.next() // { value: undefined, done: true }<br>// g调用return方法后，返回值的value属性就是return方法的参数foo<br>// 遍历就终止了，返回值的done属性为true<br>// 不提供参数，则返回值的value属性为undefined<br>function* numbers () {<br>yield 1;<br>try {<br>yield 2;<br>yield 3;<br>} finally {<br>yield 4;<br>yield 5;<br>}<br>yield 6;<br>}<br>var g = numbers()<br>g.next() // { done: false, value: 1 }<br>g.next() // { done: false, value: 2 }<br>g.return(7) // { done: false, value: 4 }<br>g.next() // { done: false, value: 5 }<br>g.next() // { done: true, value: 7 }<br>// 内部有try…finally代码<br>// return方法会推迟到finally代码块执行完再执行</p>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// yield<em>语句<br>function</em> foo() {<br>yield ‘a’; yield ‘b’; }<br>function* bar() {<br>yield ‘x’;<br>foo();<br>yield ‘y’;<br>}<br>for (let v of bar()){<br>console.log(v);<br>} // “x” // “y”<br>// 在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果<br>function* bar() {<br>yield ‘x’;<br>yield* foo();<br>yield ‘y’; }<br>// 等同于<br>function* bar() {<br>yield ‘x’;<br>yield ‘a’;<br>yield ‘b’;<br>yield ‘y’;<br>}<br>// 等同于<br>function* bar() {<br>yield ‘x’;<br>for (let v of foo()) {<br>yield v;<br>}<br>yield ‘y’;<br>}<br>for (let v of bar()){<br>console.log(v);<br>}<br>// “x”<br>// “a”<br>// “b”<br>// “y”</p>
<p>function* inner() {<br>yield ‘hello!’;<br>}<br>function* outer1() {<br>yield ‘open’;<br>yield inner();<br>yield ‘close’;<br>}<br>var gen = outer1()<br>gen.next().value // “open”<br>gen.next().value // 返回一个遍历器对象<br>gen.next().value // “close”<br>function* outer2() {<br>yield ‘open’<br>yield* inner()<br>yield ‘close’<br>}<br>var gen = outer2()<br>gen.next().value // “open”<br>gen.next().value // “hello!”<br>gen.next().value // “close”<br>let delegatedIterator = (function* () {<br>yield ‘Hello!’;<br>yield ‘Bye!’;<br>}());<br>let delegatingIterator = (function* () {<br>yield ‘Greetings!’;<br>yield* delegatedIterator;<br>yield ‘Ok, bye.’; }());<br>for(let value of delegatingIterator) {<br>console.log(value);<br>}<br>// “Greetings!<br>// “Hello!”<br>// “Bye!”<br>// “Ok, bye.”</p>
<p>function* gen(){<br>yield* [“a”, “b”, “c”];<br>}<br>gen().next() // { value:”a”, done:false }<br>let read = (function* () {<br>yield ‘hello’;<br>yield* ‘hello’;<br>})();<br>read.next().value // “hello”<br>read.next().value // “h”<br>// 任何数据结构只要有Iterator接口，就可以被yield<em>遍历<br>// 不加星号，返回的是整个数组<br>function *foo() {<br>yield 2;<br>yield 3;<br>return “foo”;<br>}<br>function *bar() {<br>yield 1;<br>var v = yield *foo();<br>console.log( “v: “ + v );<br>yield 4;<br>}<br>var it = bar();<br>it.next() // {value: 1, done: false}<br>it.next() // {value: 2, done: false}<br>it.next() // {value: 3, done: false}<br>it.next(); // “v: foo” // {value: 4, done: false}<br>it.next() // {value: undefined, done: true}<br>// 有return语句，那么就可以向代理它的Generator函数返回数据<br>// 函数foo的return语句，向函数bar提供了返回值<br>function</em> genFuncWithReturn() {<br>yield ‘a’;<br>yield ‘b’;<br>return ‘The result’;<br>}<br>function* logReturned(genObj) {<br>let result = yield* genObj;<br>console.log(result);<br>}<br>[…logReturned(genFuncWithReturn())]<br>// The result<br>// 值为 [ ‘a’, ‘b’ ]<br>function* iterTree(tree) {<br>if (Array.isArray(tree)) {<br>for(let i=0; i &lt; tree.length; i++) {<br>yield* iterTree(tree[i]);<br>}<br>} else {<br>yield tree;<br>}<br>}<br>const tree = [ ‘a’, [‘b’, ‘c’], [‘d’, ‘e’] ];<br>for(let x of iterTree(tree)) {<br>console.log(x);<br>}<br>// a<br>// b<br>// c<br>// d<br>// e<br>// 取出嵌套数组的所有成员<br>// 下面是二叉树的构造函数，<br>// 三个参数分别是左树、当前节点和右树<br>function Tree(left, label, right) {<br>this.left = left;<br>this.label = label;<br>this.right = right;<br>}<br>// 下面是中序（inorder）遍历函数。<br>// 由于返回的是一个遍历器，所以要用generator函数。<br>// 函数体内采用递归算法，所以左树和右树要用yield<em>遍历<br>function</em> inorder(t) {<br>if (t) {<br>yield* inorder(t.left);<br>yield t.label;<br>yield* inorder(t.right);<br>}<br>}<br>// 下面生成二叉树<br>function make(array) {<br>// 判断是否为叶节点<br>if (array.length == 1) return new Tree(null, array[0], null);<br>return new Tree(make(array[0]), array[1], make(array[2]));<br>}<br>let tree = make([[[‘a’], ‘b’, [‘c’]], ‘d’, [[‘e’], ‘f’, [‘g’]]]);<br>// 遍历二叉树<br>var result = [];<br>for (let node of inorder(tree)) {<br>result.push(node);<br>}<br>result // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’]<br>// 遍历完全二叉树<br>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 作为对象属性<br>let obj = {</p>
<ul>
<li>myGeneratorMethod() { ··· }<br>};<br>// 一个对象的属性是Generator函数<br>let obj = {<br>myGeneratorMethod: function* () {<br>// ···<br>}<br>};<br>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// this<br>function* g() { }<br>g.prototype.hello = function () {<br>return ‘hi!’;<br>};<br>let obj = g();<br>obj instanceof g // true<br>obj.hello() // ‘hi!’<br>// Generator函数的实例，也继承了Generator函数的prototype对象上的方法<br>function* g() {<br>this.a = 11;<br>}<br>let obj = g();<br>obj.a // undefined<br>// g返回的总是遍历器对象，而不是this对象<br>function* F() {<br>yield this.x = 2;<br>yield this.y = 3;<br>}<br>new F() // TypeError: F is not a constructor<br>// Generator函数也不能跟new命令一起用<br>// F不是构造函数<br>function* F() {<br>this.a = 1;<br>yield this.b = 2;<br>yield this.c = 3;<br>}<br>var obj = {};<br>var f = F.call(obj);<br>f.next(); // Object {value: 2, done: false}<br>f.next(); // Object {value: 3, done: false}<br>f.next(); // Object {value: undefined, done: true}<br>obj.a // 1<br>obj.b // 2<br>obj.c // 3<br>// 使用call方法绑定Generator函数内部的this<br>// F内部的this对象绑定obj对象，然后调用它<br>// 执行的是遍历器对象f，但是生成的对象实例是obj<br>function* F() {<br>this.a = 1;<br>yield this.b = 2;<br>yield this.c = 3;<br>}<br>var f = F.call(F.prototype);<br>f.next(); // Object {value: 2, done: false}<br>f.next(); // Object {value: 3, done: false}<br>f.next(); // Object {value: undefined, done: true}<br>f.a // 1 f.b // 2 f.c // 3<br>// 将obj换成F.prototype ，执行和生成的就是统一对象了<br>function* gen() {<br>this.a = 1;<br>yield this.b = 2;<br>yield this.c = 3;<br>}<br>function F() {<br>return gen.call(gen.prototype);<br>}<br>var f = new F();<br>f.next(); // Object {value: 2, done: false}<br>f.next(); // Object {value: 3, done: false}<br>f.next(); // Object {value: undefined, done: true}<br>f.a // 1<br>f.b // 2<br>f.c // 3<br>// 将F改成构造函数，就可以对它执行new命令了<br>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 应用<br>// 状态机<br>var ticking = true;<br>var clock = function () {<br>if (ticking) console.log(‘Tick!’);<br>else console.log(‘Tock!’);<br>ticking = !ticking;<br>}<br>// Generator是实现状态机的最佳结构<br>// 两种状态（Tick和Tock），每运行一次，就改变一次状态<br>var clock = function* () {<br>while (true) {<br>console.log(‘Tick!’);<br>yield;<br>console.log(‘Tock!’);<br>yield;<br>}<br>};<br>// Generator本身就包含了一个状态信息：是否处于暂停态<br>// 异步操作的同步化表达<br>function* loadUI() {<br>showLoadingScreen();<br>yield loadUIDataAsynchronously();<br>hideLoadingScreen();<br>}<br>var loader = loadUI(); // 加载UI<br>loader.next() // 卸载UI loader.next()<br>// 异步操作的后续操作可以放在yield语句下面<br>// 所有Loading界面的逻辑，都被封装在一个函数<br>function* main() {<br>var result = yield request(“<a href="http://some.url&quot;" target="_blank" rel="noopener">http://some.url&quot;</a>);<br>var resp = JSON.parse(result);<br>console.log(resp.value);<br>}<br>function request(url) {<br>makeAjaxCall(url, function (response) {<br>it.next(response);<br>});<br>}<br>var it = main();<br>it.next();<br>// main函数，就是通过Ajax操作获取数据<br>// makeAjaxCall函数中的next方法，必须加上response参数， 因为yield语句构成的表达式，本身是没有值的<br>function* numbers() {<br>let file = new FileReader(“numbers.txt”);<br>try {<br>while (!file.eof) {<br>yield parseInt(file.readLine(), 10);<br>}<br>} finally {<br>file.close();<br>}<br>}<br>// 使用yield语句可以手动逐行读取文件<br>// 控制流管理<br>Promise.resolve(step1)<br>.then(step2)<br>.then(step3)<br>.then(step4)<br>.then(function (value4) {<br>// Do something with value4<br>}, function (error) {<br>// Handle any error from step1 through step4<br>}).done();<br>// Promise方式<br>function* longRunningTask(value1) {<br>try {<br>var value2 = yield step1(value1);<br>var value3 = yield step2(value2);<br>var value4 = yield step3(value3);<br>var value5 = yield step4(value4);<br>// Do something with value4<br>} catch (e) {<br>// Handle any error from step1 through step4<br>}<br>}<br>scheduler(longRunningTask(initialValue));<br>function scheduler(task) {<br>var taskObj = task.next(task.value);<br>// 如果Generator函数未结束，就继续调用<br>if (!taskObj.done) {<br>task.value = taskObj.value;<br>scheduler(task);<br>}<br>}<br>// 按次序自动执行所有步骤<br>// 只适合同步操作<br>let steps = [step1Func, step2Func, step3Func];<br>function* iterateSteps(steps) {<br>for (var i = 0; i &lt; steps.length; i++){<br>var step = steps[i];<br>yield step();<br>}<br>}<br>// for…of循环会自动依次执行yield命令<br>let jobs = [job1, job2, job3];<br>function* iterateJobs(jobs) {<br>for (var i = 0; i &lt; jobs.length; i++){<br>var job = jobs[i];<br>yield* iterateSteps(job.steps);<br>}<br>}<br>// 还可以将项目分解成多个依次执行的任务<br>for (var step of iterateJobs(jobs)) {<br>console.log(step.id);<br>}<br>// 一次性依次执行所有任务的所有步骤<br>// 部署Iterator接口<br>function* iterEntries(obj) {<br>let keys = Object.keys(obj);<br>for (let i = 0; i &lt; keys.length; i++) {<br>let key = keys[i];<br>yield [key, obj[key]];<br>}<br>}<br>let myObj = { foo: 3, bar: 7 };<br>for (let [key, value] of iterEntries(myObj)) {<br>console.log(key, value);<br>} // foo 3 // bar 7<br>// 可以在任意对象上部署Iterator接口<br>function* makeSimpleGenerator(array) {<br>var nextIndex = 0;<br>while (nextIndex &lt; array.length) {<br>yield array[nextIndex++];<br>}<br>}<br>var gen = makeSimpleGenerator([‘yo’, ‘ya’]);<br>gen.next().value // ‘yo’<br>gen.next().value // ‘ya’<br>gen.next().done // true<br>// 作为数据结构<br>// Generator可以看作是一个数组结构<br>function* doStuff() {<br>yield fs.readFile.bind(null, ‘hello.txt’);<br>yield fs.readFile.bind(null, ‘world.txt’);<br>yield fs.readFile.bind(null, ‘and-such.txt’);<br>}<br>// 可以像处理数组那样，处理这三个返回的函数<br>for (task of doStuff()) {<br>// task是一个函数，可以像回调函数那样使用它<br>}</li>
</ul>
<p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>// Promise对象<br>// 含义<br>// 是异步编程的一种解决方案，比传统的回调函数和事件更合理和更强大<br>// 是一个容器，里面保存着某个未来才会结束的事件（异步操作）的结果<br>// 是一个对象，从它可以获取异步操作的消息<br>// 有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）<br>// 只有两种可能：从Pending变为Resolved和从Pending变为Rejected<br>// Promise新建后就会立即执行</p>
<p>// 基本用法<br>var promise = new Promise(function (resolve, reject) {<br>// … some code<br>if (/* 异步操作成功 */true){<br>resolve(value);<br>} else {<br>reject(error);<br>}<br>});<br>// Promise对象是一个构造函数<br>// resolve函数将Promise对象的状态从Pending变为Resolved<br>// reject函数将Promise对象的状态从Pending变为Rejected<br>// 它们的参数value和error会被传递给回调函数<br>promise.then(function (value) {<br>// success<br>}, function (error) {<br>// failure<br>});<br>// 用then方法分别指定Resolved状态和Reject状态的回调函数<br>// 第一个回调函数是Promise对象的状态变为Resolved时调用<br>// 第二个回调函数是Promise对象的状态变为Reject时调用(可选)<br>function timeout(ms) {<br>return new Promise((resolve, reject) =&gt; {<br>setTimeout(resolve, ms, ‘done’);<br>});<br>}<br>timeout(100).then((value) =&gt; {<br>console.log(value);<br>});<br>// 一段时间以后才会发生的结果<br>let promise = new Promise(function (resolve, reject) {<br>console.log(‘Promise’); resolve();<br>});<br>promise.then(function () {<br>console.log(‘Resolved.’);<br>});<br>console.log(‘Hi!’);<br>// Promise<br>// Hi!<br>// Resolved<br>// Promise新建后就会立即执行,首先输出的是“Promise”<br>// then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行<br>function loadImageAsync(url) {<br>return new Promise(function (resolve, reject) {<br>var image = new Image();<br>image.onload = function () {<br>resolve(image);<br>};<br>image.onerror = function () {<br>reject(new Error(‘Could not load image at ‘ + url));<br>};<br>image.src = url;<br>});<br>}<br>// 异步加载图片<br>var getJSON = function (url) {<br>var promise = new Promise(function (resolve, reject) {<br>var client = new XMLHttpRequest();<br>client.open(“GET”, url);<br>client.onreadystatechange = handler;<br>client.responseType = “json”;<br>client.setRequestHeader(“Accept”, “application/json”);<br>client.send(); function handler() {<br>if (this.readyState !== 4) { return; }<br>if (this.status === 200) {<br>resolve(this.response);<br>} else {<br>reject(new Error(this.statusText));<br>}<br>};<br>});<br>return promise;<br>};<br>getJSON(“/posts.json”).then(function (json) {<br>console.log(‘Contents: ‘ + json);<br>}, function (error) {<br>console.error(‘出错了’, error);<br>});<br>// Ajax操作<br>// getJSON是对XMLHttpRequest对象的封装， 用于发出一个针对JSON数据的HTTP请求， 并且返回一个Promise对象<br>var p1 = new Promise(function (resolve, reject) {<br>// …<br>});<br>var p2 = new Promise(function (resolve, reject) {<br>// …<br>resolve(p1);<br>})<br>// 一个异步操作的结果是返回另一个异步操作<br>// p1的状态决定了p2的状态<br>var p1 = new Promise(function (resolve, reject) {<br>setTimeout(() =&gt; reject(new Error(‘fail’)), 3000)<br>})<br>var p2 = new Promise(function (resolve, reject) {<br>setTimeout(() =&gt; resolve(p1), 1000)<br>})<br>p2.then(result =&gt; console.log(result))<br>.catch(error =&gt; console.log(error)) // Error: fail<br>// p1在3秒之后变为rejected<br>// p2的状态在1秒之后改变，resolve方法返回的是p1<br>// 又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数</p>
<p>// then()<br>getJSON(“/posts.json”).then(function (json) {<br>return json.post;<br>}).then(function (post) {<br>// …<br>});<br>// then方法返回的是一个新的Promise实例<br>// 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数<br>getJSON(“/post/1.json”).then(function (post) {<br>return getJSON(post.commentURL);<br>}).then(function funcA(comments) {<br>console.log(“Resolved: “, comments);<br>}, function funcB(err) {<br>console.log(“Rejected: “, err);<br>});<br>// 前一个回调函数，有可能返回的还是一个Promise对象<br>// 后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用<br>getJSON(“/post/1.json”).then(<br>post =&gt; getJSON(post.commentURL)<br>).then(comments =&gt; console.log(“Resolved: “, comments), err =&gt; console.log(“Rejected: “, err));</p>
<p>// catch()<br>getJSON(“/posts.json”).then(function (posts) {<br>// …<br>}).catch(function (error) {<br>// 处理 getJSON 和 前一个回调函数运行时发生的错误<br>console.log(‘发生错误！’, error);<br>});<br>// 是.then(null, rejection)的别名，用于指定发生错误时的回调函数<br>// getJSON方法变为Rejected或then方法指定的回调函数错误都会被catch捕获<br>// 一般不要在then方法里面定义Reject状态的回调函数，总是使用catch方法<br>p.then((val) =&gt; console.log(“fulfilled:”, val))<br>.catch((err) =&gt; console.log(“rejected:”, err));<br>// 等同于<br>p.then((val) =&gt; console.log(“fulfilled:”, val))<br>.then(null, (err) =&gt; console.log(“rejected:”, err));<br>var promise = new Promise(function (resolve, reject) {<br>throw new Error(‘test’);<br>});<br>promise.catch(function (error) {<br>console.log(error);<br>}); // Error: test<br>// promise抛出一个错误，就被catch方法指定的回调函数捕获<br>var promise = new Promise(function (resolve, reject) {<br>try { throw new Error(‘test’); }<br>catch (e) { reject(e); }<br>});<br>promise.catch(function (error) {<br>console.log(error);<br>});<br>var promise = new Promise(function (resolve, reject) {<br>reject(new Error(‘test’));<br>});<br>promise.catch(function (error) {<br>console.log(error);<br>});<br>var promise = new Promise(function (resolve, reject) {<br>resolve(‘ok’); throw new Error(‘test’);<br>});<br>promise.then(function (value) {<br>console.log(value)<br>}).catch(function (error) {<br>console.log(error)<br>}); // ok<br>// 状态已经变成Resolved，再抛出错误是无效的<br>var someAsyncThing = function () {<br>return new Promise(function (resolve, reject) {<br>// 下面一行会报错，因为x没有声明<br>resolve(x + 2);<br>});<br>};<br>someAsyncThing().catch(function (error) {<br>console.log(‘oh no’, error);<br>}).then(function () {<br>console.log(‘carry on’);<br>});<br>// oh no [ReferenceError: x is not defined]<br>// carry on<br>// catch方法返回的还是一个Promise对象<br>Promise.resolve()<br>.catch(function (error) {<br>console.log(‘oh no’, error);<br>}).then(function () {<br>console.log(‘carry on’);<br>}); // carry on<br>// 没有报错，跳过了catch方法，直接执行后面的then方法<br>// then方法里面报错，就与前面的catch无关了<br>var someAsyncThing = function () {<br>return new Promise(function (resolve, reject) {<br>// 下面一行会报错，因为x没有声明<br>resolve(x + 2);<br>});<br>};<br>someAsyncThing().then(function () {<br>return someOtherAsyncThing();<br>}).catch(function (error) {<br>console.log(‘oh no’, error);<br>// 下面一行会报错，因为y没有声明<br>y + 2;<br>}).then(function () {<br>console.log(‘carry on’);<br>});<br>// oh no [ReferenceError: x is not defined]<br>// catch方法抛出一个错误，因为后面没有别的catch方法了， 导致这个错误不会被捕获，也不会传递到外层</p>
<p>// Promise.all()<br>var p = Promise.all([p1, p2, p3]);<br>// 将多个Promise实例，包装成一个新的Promise实例<br>// p1、p2、p3都是Promise对象的实例<br>// 如果不是就会先调用Promise.resolve方法转为Promise实例<br>// 状态<br>// 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled<br>// 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected<br>// 第一个被reject的实例的返回值，会传递给p的回调函数<br>// 生成一个Promise对象的数组<br>var promises = [2, 3, 5, 7, 11, 13].map(function (id) {<br>return getJSON(“/post/“ + id + “.json”);<br>});<br>Promise.all(promises).then(function (posts) {<br>// …<br>}).catch(function (reason) {<br>// …<br>});<br>const databasePromise = connectDatabase();<br>const booksPromise = databaseProimse.then(findAllBooks);<br>const userPromise = databasePromise.then(getCurrentUser);<br>Promise.all([booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user));<br>// Promise.race()<br>var p = Promise.race([p1,p2,p3]);<br>// 将多个Promise实例，包装成一个新的Promise实例<br>// 有一个实例率先改变状态，p的状态就跟着改变<br>// 那个率先改变的Promise实例的返回值，就传递给p的回调函数<br>var p = Promise.race([<br>fetch(‘/resource-that-may-take-a-while’),<br>new Promise(function (resolve, reject) {<br>setTimeout(() =&gt; reject(new Error(‘request timeout’)), 5000)<br>})<br>])<br>p.then(response =&gt; console.log(response))<br>p.catch(error =&gt; console.log(error))<br>// 5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected</p>
<p>// Promise.resolve()<br>var jsPromise = Promise.resolve($.ajax(‘/whatever.json’));<br>// 将现有对象转为Promise对象<br>// 将jQuery生成的deferred对象，转为一个新的Promise对象<br>let thenable = {<br>then: function (resolve, reject) {<br>resolve(42);<br>}<br>};<br>let p1 = Promise.resolve(thenable);<br>p1.then(function (value) {<br>console.log(value); // 42<br>});<br>// 将这个对象转为Promise对象，然后就立即执行then方法<br>var p = Promise.resolve(‘Hello’);<br>p.then(function (s) {<br>console.log(s)<br>}); // Hello</p>
<p>// Promise.reject()<br>var p = Promise.reject(‘出错了’);<br>// 等同于<br>var p = new Promise((resolve, reject) =&gt; reject(‘出错了’))<br>p.then(null, function (s) {<br>console.log(s)<br>}); // 出错了<br>// 返回一个新的Promise实例，该实例的状态为rejected<br>// 附加方法<br>// done()<br>asyncFunc()<br>.then(f1)<br>.catch(r1)<br>.then(f2)<br>.done();<br>// done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误<br>// finally()<br>server.listen(0)<br>.then(function () {<br>// run test<br>}).finally(server.stop);<br>// 不管Promise对象最后状态如何，都会执行的操作<br>// 接受一个普通的回调函数作为参数<br>// 应用<br>// 加载图片<br>const preloadImage = function (path) {<br>return new Promise(function (resolve, reject) {<br>var image = new Image();<br>image.onload = resolve;<br>image.onerror = reject;<br>image.src = path;<br>});<br>};<br>// Generator函数<br>function getFoo() {<br>return new Promise(function (resolve, reject) {<br>resolve(‘foo’);<br>});<br>}<br>var g = function* () {<br>try {<br>var foo = yield getFoo(); console.log(foo);<br>}<br>catch (e) {<br>console.log(e);<br>}<br>};<br>function run(generator) {<br>var it = generator();<br>function go(result) {<br>if (result.done) return result.value;<br>return result.value.then(function (value) {<br>return go(it.next(value));<br>}, function (error) {<br>return go(it.throw(error));<br>});<br>}<br>go(it.next());<br>}<br>run(g);<br>// 使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象<br>// 函数run用来处理这个Promise对象，并调用下一个next方法</p>
</div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/js/">js</a><a href="/tags/es6/">es6</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/04/19/web/js/new%E5%AF%B9%E8%B1%A1/">&lt; new操作符做了啥？</a><a class="next" href="/2020/04/19/web/es/es%E8%A7%A3%E6%9E%84%E6%96%B9%E6%B3%95/">es解构方法 &gt;</a></div><div id="valine-comment"><style type="text/css">.v * { color: #CECECE; }
.v a { color: #0F9FB4; }
.v a:hover { color: #216C73; }
.v li { list-style: inherit; }
.v .vwrap { border: 1px solid #223441; border-radius: 0; }
.v .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.v .vbtn { border-radius: 0; color: #cecece; background: none; }
.v .vlist .vcard .vh { border-bottom-color: #293D4E; }
.v .vwrap .vheader .vinput { border-bottom-color: #223441; }
.v .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.v code, .v pre,.v .vlist .vcard .vhead .vsys { background: #203240; }
.v code, .v pre { color: #F0F0F0; font-size: 95%; }
.v .vlist .vcard .vcontent.expand:before { background: linear-gradient(180deg,hsla(206,33%,19%,0),hsla(206,33%,19%,.9)); }
.v .vlist .vcard .vcontent.expand:after { background: hsla(206,33%,19%,.9); }</style><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'YA2WYHPMXQdEAVaM1kpLwGYh-gzGzoHsz',
  appKey:'Lw8DxQbBcfgYGtAFrU8kfpQA',
  lang: 'zh-cn',
  placeholder:'请留下您宝贵的评论...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">月晴星飞</a><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>