<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="月晴星飞的个人博客"><meta name="baidu-site-verification" content="2kzCiP25dA"><title>es数据结构 | 月晴星飞</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script>var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?115872dc2cc8c5a96937ab18cbdd16fe";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();</script><meta name="generator" content="Hexo 4.2.0"></head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">月晴星飞</a></h1></div><p class="m-desc">夫君子之行，静以修身，俭以养德。<br>非澹泊无以明志， 非宁静无以致远。</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">es数据结构</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/04/19/web/es/es%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">2020-04-19</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/js/">js</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>ES数据结构 Map Set Symbol</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>// 基本用法<br>// 解决Object的键只能是字符串的限制<br>// 将一个DOM节点作为data对象的键<br>// element被自动转为字符串[object HTMLDivElement]<br>// Map的键实际上是跟内存地址绑定的<br>var data = {};<br>var element = document.getElementById(‘myDiv’);<br>data[element] = ‘metadata’;<br>data[‘[object HTMLDivElement]’] // “metadata”</p>
<p>var m = new Map();<br>var o = {p: ‘Hello World’};<br>m.set(o, ‘content’)<br>m.get(o) // “content”<br>m.has(o) // true<br>m.delete(o) // true<br>m.has(o) // false</p>
<p>// 可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组<br>var map = new Map([<br>[‘name’, ‘张三’],<br>[‘title’, ‘Author’]<br>]);<br>map.size // 2<br>map.has(‘name’) // true<br>map.get(‘name’) // “张三”<br>map.has(‘title’) // true<br>map.get(‘title’) // “Author”</p>
<p>// 接受数组作为参数时，实际上执行的是下面的算法<br>var items = [<br>[‘name’, ‘张三’],<br>[‘title’, ‘Author’]<br>];<br>var map = new Map();<br>items.forEach(([key, value]) =&gt; map.set(key, value));<br>////<br>var m = new Map([<br>[true, ‘foo’],<br>[‘true’, ‘bar’]<br>]);<br>m.get(true) // ‘foo’<br>m.get(‘true’) // ‘bar’</p>
<p>// 后面的值将覆盖前面的值<br>let map = new Map();<br>map<br>.set(1, ‘aaa’)<br>.set(1, ‘bbb’);<br>map.get(1) // “bbb”</p>
<p>// 未知的键，则返回undefined<br>new Map().get(‘asfddfsasadf’) // undefined</p>
<p>// 表面是针对同一个键，但实际上这是两个值<br>var map = new Map();<br>map.set([‘a’], 555);<br>map.get([‘a’]) // undefined</p>
<p>// 同样的值的两个实例，在Map结构中被视为两个键<br>var map = new Map();<br>var k1 = [‘a’];<br>var k2 = [‘a’];<br>map<br>.set(k1, 111)<br>.set(k2, 222);<br>map.get(k1) // 111<br>map.get(k2) // 222<br>// 简单类型的值（数字、字符串、布尔值）严格相等时其视为一个键<br>let map = new Map();<br>map.set(NaN, 123);<br>map.get(NaN) // 123<br>map.set(-0, 123);<br>map.get(+0) // 123<br>/**—————————————————————————————————- */<br>// 属性和方法<br>// 更多高级用法参考 ImmuTable.jsx<br>size // 相当于数组的length<br>set(key, value) // 返回整个Map结构，可以采用链式写法<br>let map = new Map()<br>.set(1, ‘a’)<br>.set(2, ‘b’)<br>.set(3, ‘c’);<br>get(key) // 找不到key，返回undefined<br>has(key) // 返回一个布尔值<br>delete(key) // 返回一个布尔值<br>clear() // 清除所有成员，没有返回值</p>
<p>/**—————————————————————————————————- */<br>// 遍历方法<br>// 可参考扩展方法里的对象方法<br>keys() // 返回键名的遍历器。<br>let map = new Map([<br>[‘F’, ‘no’],<br>[‘T’, ‘yes’],<br>]);<br>for (let key of map.keys()) {<br>console.log(key);<br>}<br>// “F”<br>// “T”</p>
<p>values() // 返回键值的遍历器。<br>for (let value of map.values()) {<br>console.log(value);<br>}<br>// “no”<br>// “yes”</p>
<p>entries() // 返回所有成员的遍历器。<br>for (let item of map.entries()) {<br>console.log(item[0], item[1]);<br>}<br>// “F” “no”<br>// “T” “yes”<br>// 或者<br>for (let [key, value] of map.entries()) {<br>console.log(key, value);<br>}<br>// 等同于使用map.entries()<br>for (let [key, value] of map) {<br>console.log(key, value);<br>}<br>// 默认遍历器接口（Symbol.iterator属性），就是entries方法<br>map[Symbol.iterator] === map.entries // true</p>
<p>forEach() // 遍历Map的所有成员。<br>map.forEach(function(value, key, map) {<br>console.log(“Key: %s, Value: %s”, key, value);<br>});<br>// forEach方法还可以接受第二个参数，用来绑定this<br>// forEach方法的回调函数的this，就指向reporter<br>var reporter = {<br>report: function(key, value) {<br>console.log(“Key: %s, Value: %s”, key, value);<br>}<br>};<br>map.forEach(function(value, key, map) {<br>this.report(key, value);<br>}, reporter);</p>
<p>/**—————————————————————————————————- */<br>// 实例<br>// 结合数组的map方法、filter方法，可以实现Map的遍历和过滤<br>let map0 = new Map()<br>.set(1, ‘a’)<br>.set(2, ‘b’)<br>.set(3, ‘c’);<br>let map1 = new Map(<br>[…map0].filter(([k, v]) =&gt; k &lt; 3)<br>); // 产生Map结构 {1 =&gt; ‘a’, 2 =&gt; ‘b’}<br>let map2 = new Map(<br>[…map0].map(([k, v]) =&gt; [k * 2, ‘_’ + v])<br>); // 产生Map结构 {2 =&gt; ‘_a’, 4 =&gt; ‘_b’, 6 =&gt; ‘_c’}</p>
<p>/**—————————————————————————————————- */<br>// 结构转换<br>// Map转为数组<br>let myMap = new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>[…myMap]; // [ [ true, 7 ], [ { foo: 3 }, [ ‘abc’ ] ] ]</p>
<p>let map = new Map([<br>[1, ‘one’],<br>[2, ‘two’],<br>[3, ‘three’],<br>]);<br>[…map.keys()]; // [1, 2, 3]<br>[…map.values()]; // [‘one’, ‘two’, ‘three’]<br>[…map.entries()]; // [[1,’one’], [2, ‘two’], [3, ‘three’]]<br>[…map]; // [[1,’one’], [2, ‘two’], [3, ‘three’]]</p>
<p>// 数组转为Map<br>new Map([[true, 7], [{foo: 3}, [‘abc’]]])<br>// Map {true =&gt; 7, Object {foo: 3} =&gt; [‘abc’]}</p>
<p>// Map转为对象<br>// 所有Map的键都是字符串时<br>function strMapToObj(strMap) {<br>let obj = Object.create(null);<br>for (let [k,v] of strMap) {<br>obj[k] = v;<br>}<br>return obj;<br>}<br>let myMap = new Map().set(‘yes’, true).set(‘no’, false);<br>strMapToObj(myMap) // { yes: true, no: false }</p>
<p>// Map转为JSON<br>// Map的键名都是字符串，这时可以选择转为对象JSON。<br>function strMapToJson(strMap) {<br>return JSON.stringify(strMapToObj(strMap));<br>}<br>let myMap = new Map().set(‘yes’, true).set(‘no’, false);<br>strMapToJson(myMap) // ‘{“yes”:true,”no”:false}’</p>
<p>// Map的键名有非字符串，这时可以选择转为数组JSON<br>function mapToArrayJson(map) {<br>return JSON.stringify([…map]);<br>}<br>let myMap = new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>mapToArrayJson(myMap) // ‘[[true,7],[{“foo”:3},[“abc”]]]’</p>
<p>// JSON转为Map<br>// 整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组<br>function jsonToStrMap(jsonStr) {<br>return objToStrMap(JSON.parse(jsonStr));<br>}<br>jsonToStrMap(‘{“yes”:true,”no”:false}’) // Map {‘yes’ =&gt; true, ‘no’ =&gt; false}</p>
<p>function jsonToMap(jsonStr) {<br>return new Map(JSON.parse(jsonStr));<br>}<br>jsonToMap(‘[[true,7],[{“foo”:3},[“abc”]]]’) // Map {true =&gt; 7, Object {foo: 3} =&gt; [‘abc’]}</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>// 基本用法<br>// 类似于数组，但是成员的值都是唯一的<br>var s = new Set();<br>[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));<br>for (let i of s) {<br>console.log(i);<br>} // 2 3 5 4</p>
<p>// 可以接受一个数组（或类似数组的对象）作为参数，用来初始化<br>var set = new Set([1, 2, 3, 4, 4]);<br>[…set] // [1, 2, 3, 4]<br>var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);<br>items.size // 5<br>function divs () {<br>return […document.querySelectorAll(‘div’)];<br>}<br>var set = new Set(divs());<br>set.size; // 56<br>// 类似于<br>divs().forEach(div =&gt; set.add(div));<br>set.size; // 56</p>
<p>// 去除数组的重复成员<br>[…new Set(array)];</p>
<p>function dedupe(array) {<br>return Array.from(new Set(array));<br>}<br>dedupe([1, 1, 2, 3]) // [1, 2, 3]</p>
<p>// 在Set内部，两个NaN相等, 而精确相等运算符（===）认为NaN不等于自身<br>let set = new Set();<br>let a = NaN;<br>let b = NaN;<br>set.add(a);<br>set.add(b);<br>set // Set {NaN}</p>
<p>// 两个空对象不相等<br>let set = new Set();<br>set.add({});<br>set.size // 1<br>set.add({});<br>set.size // 2</p>
<p>/**—————————————————————————————————- */<br>// 属性和方法<br>Set.prototype.constructor // 构造函数，默认就是Set函数<br>Set.prototype.size // 返回Set实例的成员总数<br>add(value) // 添加某个值，返回Set结构本身<br>delete(value) // 删除某个值，返回一个布尔值，表示删除是否成功<br>has(value) // 返回一个布尔值，表示该值是否为Set的成员<br>clear() // 清除所有成员，没有返回值</p>
<p>// 基本示例<br>s.add(1).add(2).add(2); // 注意2被加入了两次<br>s.size // 2<br>s.has(1) // true<br>s.has(2) // true<br>s.has(3) // false<br>s.delete(2);<br>s.has(2) // false</p>
<p>// 对象的写法<br>var properties = {<br>‘width’: 1,<br>‘height’: 1<br>};<br>if (properties[someName]) {<br>// do something<br>}<br>// Set的写法<br>var properties = new Set();<br>properties.add(‘width’);<br>properties.add(‘height’);<br>if (properties.has(someName)) {<br>// do something<br>}</p>
<p>// 将Set结构转为数组<br>var items = new Set([1, 2, 3, 4, 5]);<br>var array = Array.from(items);</p>
<p>/**—————————————————————————————————- */<br>// 遍历操作<br>// 遍历顺序就是插入顺序<br>// 前三个方法返回的都是遍历器对象，键名和键值是同一个值<br>keys() // 返回键名的遍历器<br>let set = new Set([‘red’, ‘green’, ‘blue’]);<br>for (let item of set.keys()) {<br>console.log(item);<br>}<br>// red<br>// green<br>// blue</p>
<p>values() // 返回键值的遍历器<br>for (let item of set.values()) {<br>console.log(item);<br>}<br>// red<br>// green<br>// blue</p>
<p>// 可以省略values方法<br>for (let x of set) {<br>console.log(x);<br>}<br>// red<br>// green<br>// blue</p>
<p>entries() // 返回键值对的遍历器<br>for (let item of set.entries()) {<br>console.log(item);<br>}<br>// [“red”, “red”]<br>// [“green”, “green”]<br>// [“blue”, “blue”]</p>
<p>forEach() // 使用回调函数遍历每个成员，没有返回值；参数依次为键值、键名、集合本身<br>let set = new Set([1, 2, 3]);<br>set.forEach((value, key) =&gt; console.log(value * 2) )<br>// 2<br>// 4<br>// 6</p>
<p>// 默认遍历器生成函数就是它的values方法<br>Set.prototype[Symbol.iterator] === Set.prototype.values // true</p>
<p>// 扩展运算符<br>let set = new Set([‘red’, ‘green’, ‘blue’]);<br>let arr = […set]; // [‘red’, ‘green’, ‘blue’]</p>
<p>// 去除数组的重复成员<br>let arr = [3, 5, 2, 2, 5, 5];<br>let unique = […new Set(arr)]; // [3, 5, 2]</p>
<p>// 数组的map和filter方法也可以用于Set<br>let set = new Set([1, 2, 3]);<br>set = new Set([…set].map(x =&gt; x * 2)); // {2, 4, 6}<br>let set = new Set([1, 2, 3, 4, 5]);<br>set = new Set([…set].filter(x =&gt; (x % 2) == 0)); // {2, 4}</p>
<p>// 实现并集（Union）、交集（Intersect）和差集（Difference）<br>let a = new Set([1, 2, 3]);<br>let b = new Set([4, 3, 2]);<br>// 并集<br>let union = new Set([…a, …b]); // Set {1, 2, 3, 4}<br>// 交集<br>let intersect = new Set([…a].filter(x =&gt; b.has(x))); // set {2, 3}<br>// 差集<br>let difference = new Set([…a].filter(x =&gt; !b.has(x))); // Set {1}</p>
<p>// 改变原来的Set结构<br>let set = new Set([1, 2, 3]);<br>set = new Set([…set].map(val =&gt; val * 2)); // 2, 4, 6<br>set = new Set(Array.from(set, val =&gt; val * 2)); // 2, 4, 6</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>// 引用他人对象时，防止属性名冲突<br>// ES6引入了一种新的原始数据类型Symbol，表示独一无二的值<br>// Symbol值通过Symbol函数生成<br>// 对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型<br>// Symbol函数前不能使用new命令<br>let s = Symbol();<br>typeof s // “symbol”</p>
<p>// 可以接受一个字符串作为参数，表示对Symbol实例的描述<br>var s1 = Symbol(‘foo’);<br>var s2 = Symbol(‘bar’);<br>s1 // Symbol(foo)<br>s2 // Symbol(bar)<br>s1.toString() // “Symbol(foo)”<br>s2.toString() // “Symbol(bar)”</p>
<p>// 相同参数的Symbol函数的返回值是不相等的<br>// 没有参数的情况<br>var s1 = Symbol();<br>var s2 = Symbol();<br>s1 === s2 // false<br>// 有参数的情况<br>var s1 = Symbol(“foo”);<br>var s2 = Symbol(“foo”);<br>s1 === s2 // false</p>
<p>// Symbol值不能与其他类型的值进行运算<br>var sym = Symbol(‘My symbol’);<br>“your symbol is “ + sym // TypeError: can’t convert symbol to string<br><code>your symbol is ${sym}</code> // TypeError: can’t convert symbol to string</p>
<p>// Symbol值可以显式转为字符串<br>var sym = Symbol(‘My symbol’);<br>String(sym) // ‘Symbol(My symbol)’<br>sym.toString() // ‘Symbol(My symbol)’</p>
<p>// 可以转为布尔值，但是不能转为数值<br>var sym = Symbol();<br>Boolean(sym) // true<br>!sym // false<br>if (sym) {<br>// …<br>}<br>Number(sym) // TypeError<br>sym + 2 // TypeError</p>
<p>/**—————————————————————————————————- */</p>
<h2 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h2><p>// 保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖<br>// 在对象的内部，Symbol值必须放在方括号之中<br>var mySymbol = Symbol();<br>// 第一种写法<br>var a = {};<br>a[mySymbol] = ‘Hello!’;<br>// 第二种写法<br>var a = {<br>[mySymbol]: ‘Hello!’<br>};<br>// 第三种写法<br>var a = {};<br>Object.defineProperty(a, mySymbol, { value: ‘Hello!’ });</p>
<p>a[mySymbol] // “Hello!”</p>
<p>// 不能用点运算符，因为点运算符后面总是字符串<br>var mySymbol = Symbol();<br>var a = {};<br>a.mySymbol = ‘Hello!’;<br>a[mySymbol] // undefined<br>a[‘mySymbol’] // “Hello!”</p>
<p>// 任何值都不可能有相同的值了，因此可以保证switch语句会按设计的方式工作<br>const COLOR_RED = Symbol();<br>const COLOR_GREEN = Symbol();<br>function getComplement(color) {<br>switch (color) {<br>case COLOR_RED:<br>return COLOR_GREEN;<br>case COLOR_GREEN:<br>return COLOR_RED;<br>default:<br>throw new Error(‘Undefined color’);<br>}<br>}</p>
<p>/**—————————————————————————————————- */</p>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>// Symbol作为属性名，该属性不会出现在for…in、for…of循环中， 也不会被Object.keys()、Object.getOwnPropertyNames()返回<br>// Object.getOwnPropertySymbols可以当前对象的所有用作属性名的Symbol值<br>var obj = {};<br>var a = Symbol(‘a’);<br>var b = Symbol(‘b’);<br>obj[a] = ‘Hello’;<br>obj[b] = ‘World’;<br>var objectSymbols = Object.getOwnPropertySymbols(obj);<br>objectSymbols // [Symbol(a), Symbol(b)]</p>
<p>// Reflect.ownKeys方法可以返回所有类型的键名<br>let obj = {<br>[Symbol(‘my_key’)]: 1,<br>enum: 2,<br>nonEnum: 3<br>};<br>Reflect.ownKeys(obj) // [Symbol(my_key), ‘enum’, ‘nonEnum’]</p>
<p>/**—————————————————————————————————- */</p>
<h2 id="for-和keyFor"><a href="#for-和keyFor" class="headerlink" title="for()和keyFor()"></a>for()和keyFor()</h2><p>// 接受一个字符串作为参数<br>// 有以该参数作为名称的Symbol值，就返回这个Symbol值<br>var s1 = Symbol.for(‘foo’);<br>var s2 = Symbol.for(‘foo’);<br>s1 === s2 // true</p>
<p>// 返回一个已登记的Symbol类型值的key<br>var s1 = Symbol.for(“foo”);<br>Symbol.keyFor(s1) // “foo”<br>var s2 = Symbol(“foo”);<br>Symbol.keyFor(s2) // undefined</p>
<p>/**—————————————————————————————————- */</p>
<h2 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h2><p>Symbol.hasInstance<br>// 当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法<br>class MyClass {<br><a href="foo">Symbol.hasInstance</a> {<br>return foo instanceof Array;<br>}<br>}<br>[1, 2, 3] instanceof new MyClass() // true<br>class Even {<br>static <a href="obj">Symbol.hasInstance</a> {<br>return Number(obj) % 2 === 0;<br>}<br>}<br>1 instanceof Even // false<br>2 instanceof Even // true<br>12345 instanceof Even // false</p>
<p>Symbol.isConcatSpreadable<br>// 一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开<br>// 数组的默认行为是可以展开,true或undefined，都有这个效果<br>let arr1 = [‘c’, ‘d’];<br>[‘a’, ‘b’].concat(arr1, ‘e’) // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]<br>arr1[Symbol.isConcatSpreadable] // undefined</p>
<p>let arr2 = [‘c’, ‘d’];<br>arr2[Symbol.isConcatSpreadable] = false;<br>[‘a’, ‘b’].concat(arr2, ‘e’) // [‘a’, ‘b’, [‘c’,’d’], ‘e’]</p>
<p>// 类似数组的对象也可以展开（带length属性的对象）,必须手动打开<br>let obj = {length: 2, 0: ‘c’, 1: ‘d’};<br>[‘a’, ‘b’].concat(obj, ‘e’) // [‘a’, ‘b’, obj, ‘e’]<br>obj[Symbol.isConcatSpreadable] = true;<br>[‘a’, ‘b’].concat(obj, ‘e’) // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</p>
<p>// 类A1是可展开的，类A2是不可展开的<br>class A1 extends Array {<br>constructor(args) {<br>super(args);<br>this[Symbol.isConcatSpreadable] = true;<br>}<br>}<br>class A2 extends Array {<br>constructor(args) {<br>super(args);<br>this[Symbol.isConcatSpreadable] = false;<br>}<br>}</p>
<p>let a1 = new A1();<br>a1[0] = 3;<br>a1[1] = 4;<br>let a2 = new A2();<br>a2[0] = 5;<br>a2[1] = 6;<br>[1, 2].concat(a1).concat(a2) // [1, 2, 3, 4, [5, 6]]<br>Symbol.species<br>// Symbol.species属性默认的读取器<br>// 如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象<br>static <a href="">Symbol.species</a> {<br>return this;<br>}<br>Symbol.match<br>String.prototype.match(regexp)<br>// 等同于<br>regexp<a href="this">Symbol.match</a><br>class MyMatcher {<br><a href="string">Symbol.match</a> {<br>return ‘hello world’.indexOf(string);<br>}<br>}<br>‘e’.match(new MyMatcher()) // 1<br>Symbol.replace<br>String.prototype.replace(searchValue, replaceValue)<br>// 等同于<br>searchValue[Symbol.replace](this, replaceValue)<br>Symbol.search<br>String.prototype.search(regexp)<br>// 等同于<br>regexp<a href="this">Symbol.search</a><br>class MySearch {<br>constructor(value) {<br>this.value = value;<br>}<br><a href="string">Symbol.search</a> {<br>return string.indexOf(this.value);<br>}<br>}<br>‘foobar’.search(new MySearch(‘foo’)) // 0<br>Symbol.split<br>String.prototype.split(separator, limit)<br>// 等同于<br>separator[Symbol.split](this, limit)<br>Symbol.iterator<br>// 指向该对象的默认遍历器方法<br>var myIterable = {};<br>myIterable[Symbol.iterator] = function* () {<br>yield 1;<br>yield 2;<br>yield 3;<br>};<br>[…myIterable] // [1, 2, 3]<br>class Collection {<br>*<a href="">Symbol.iterator</a> {<br>let i = 0;<br>while(this[i] !== undefined) {<br>yield this[i];<br>++i;<br>}<br>}<br>}<br>let myCollection = new Collection();<br>myCollection[0] = 1;<br>myCollection[1] = 2;<br>for(let value of myCollection) {<br>console.log(value);<br>}<br>// 1<br>// 2<br>Symbol.toPrimitive<br>// 接受一个字符串参数，表示当前运算的模式<br>// Number：该场合需要转成数值<br>// String：该场合需要转成字符串<br>// Default：该场合可以转成数值，也可以转成字符串<br>let obj = { <a href="hint">Symbol.toPrimitive</a> {<br>switch (hint) {<br>case ‘number’:<br>return 123;<br>case ‘string’:<br>return ‘str’;<br>case ‘default’:<br>return ‘default’;<br>default:<br>throw new Error();<br>}<br>}<br>};<br>2 * obj // 246<br>3 + obj // ‘3default’<br>obj == ‘default’ // true<br>String(obj) // ‘str’</p>
<p>Symbol.toStringTag<br>// 用来定制[object Object]或[object Array]中object后面的那个字符串<br>({[Symbol.toStringTag]: ‘Foo’}.toString()) // “[object Foo]”<br>class Collection {<br>get <a href="">Symbol.toStringTag</a> {<br>return ‘xxx’;<br>}<br>}<br>var x = new Collection();<br>Object.prototype.toString.call(x) // “[object xxx]”<br>// JSON[Symbol.toStringTag]：’JSON’<br>// Math[Symbol.toStringTag]：’Math’<br>// M[Symbol.toStringTag]：’Module’ // Module对象<br>// ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’<br>// DataView.prototype[Symbol.toStringTag]：’DataView’<br>// Map.prototype[Symbol.toStringTag]：’Map’<br>// Promise.prototype[Symbol.toStringTag]：’Promise’<br>// Set.prototype[Symbol.toStringTag]：’Set’<br>// %TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’<br>// WeakMap.prototype[Symbol.toStringTag]：’WeakMap’<br>// WeakSet.prototype[Symbol.toStringTag]：’WeakSet’<br>// %MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’<br>// %SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’<br>// %StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’<br>// Symbol.prototype[Symbol.toStringTag]：’Symbol’<br>// Generator.prototype[Symbol.toStringTag]：’Generator’<br>// GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’</p>
<p>Symbol.unscopables<br>// 指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除<br>// 数组有6个属性，会被with命令排除<br>Array.prototype[Symbol.unscopables]<br>// {<br>// copyWithin: true,<br>// entries: true,<br>// fill: true,<br>// find: true,<br>// findIndex: true,<br>// keys: true<br>// }<br>Object.keys(Array.prototype[Symbol.unscopables])<br>// [‘copyWithin’, ‘entries’, ‘fill’, ‘find’, ‘findIndex’, ‘keys’]</p>
<p>// 没有unscopables时<br>class MyClass {<br>foo() { return 1; }<br>}<br>var foo = function () { return 2; };<br>with (MyClass.prototype) {<br>foo(); // 1<br>}</p>
<p>// 有unscopables时<br>class MyClass {<br>foo() { return 1; }<br>get <a href="">Symbol.unscopables</a> {<br>return { foo: true };<br>}<br>}<br>var foo = function () { return 2; };<br>with (MyClass.prototype) {<br>foo(); // 2<br>}<br>/<em>*—————————————————————————————————- */<br>// 实例<br>// 消除魔术字符串<br>function getArea(shape, options) {<br>var area = 0;<br>switch (shape) {<br>case ‘Triangle’: // 魔术字符串<br>area = .5 * options.width * options.height;<br>break;<br>/</em> … more code … */<br>}<br>return area;<br>}<br>getArea(‘Triangle’, { width: 100, height: 100 }); // 魔术字符串</p>
<p>// 常用的消除魔术字符串的方法，就是把它写成一个变量。<br>var shapeType = {<br>triangle: ‘Triangle’ // 改成变量解决 triangle: Symbol()<br>};<br>function getArea(shape, options) {<br>var area = 0;<br>switch (shape) {<br>case shapeType.triangle:<br>area = .5 * options.width * options.height;<br>break;<br>}<br>return area;<br>}<br>getArea(shapeType.triangle, { width: 100, height: 100 });</p>
<p>// 模块的 Singleton 模式：指的是调用一个类，任何时候返回的都是同一个实例<br>// mod.js<br>function A() {<br>this.foo = ‘hello’;<br>}<br>if (!global._foo) {<br>global._foo = new A();<br>}<br>module.exports = global._foo;</p>
<p>// 变量a任何时候加载的都是A的同一个实例<br>// 但全局变量global._foo是可写的，会使其失真<br>var a = require(‘./mod.js’);<br>console.log(a.foo);</p>
<p>// mod.js<br>const FOO_KEY = Symbol.for(‘foo’);<br>function A() {<br>this.foo = ‘hello’;<br>}<br>if (!global[FOO_KEY]) {<br>global[FOO_KEY] = new A();<br>}<br>module.exports = global[FOO_KEY];</p>
<p>// 可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写<br>// 如果使用Symbol方法，外部将无法引用这个值，当然也就无法改写<br>var a = require(‘./mod.js’); ·</p>
</div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/js/">js</a><a href="/tags/es6/">es6</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Map"><span class="toc-number">1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set"><span class="toc-number">2.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Symbol"><span class="toc-number">3.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作为属性名"><span class="toc-number">3.2.</span> <span class="toc-text">作为属性名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性名的遍历"><span class="toc-number">3.3.</span> <span class="toc-text">属性名的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-和keyFor"><span class="toc-number">3.4.</span> <span class="toc-text">for()和keyFor()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内置的Symbol值"><span class="toc-number">3.5.</span> <span class="toc-text">内置的Symbol值</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/04/19/web/es/es%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/">&lt; es扩展方法</a><a class="next" href="/2020/04/19/web/browser/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/">浏览器通讯协议 &gt;</a></div><div id="valine-comment"><style type="text/css">.v * { color: #CECECE; }
.v a { color: #0F9FB4; }
.v a:hover { color: #216C73; }
.v li { list-style: inherit; }
.v .vwrap { border: 1px solid #223441; border-radius: 0; }
.v .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.v .vbtn { border-radius: 0; color: #cecece; background: none; }
.v .vlist .vcard .vh { border-bottom-color: #293D4E; }
.v .vwrap .vheader .vinput { border-bottom-color: #223441; }
.v .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.v code, .v pre,.v .vlist .vcard .vhead .vsys { background: #203240; }
.v code, .v pre { color: #F0F0F0; font-size: 95%; }
.v .vlist .vcard .vcontent.expand:before { background: linear-gradient(180deg,hsla(206,33%,19%,0),hsla(206,33%,19%,.9)); }
.v .vlist .vcard .vcontent.expand:after { background: hsla(206,33%,19%,.9); }</style><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'YA2WYHPMXQdEAVaM1kpLwGYh-gzGzoHsz',
  appKey:'Lw8DxQbBcfgYGtAFrU8kfpQA',
  lang: 'zh-cn',
  placeholder:'请留下您宝贵的评论...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">月晴星飞</a><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>