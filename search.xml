<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试题2</title>
      <link href="/2020/04/19/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
      <url>/2020/04/19/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<p><strong>前端开发知识点：</strong>    </p><pre><code>HTML&amp;CSS：    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、    HTML5、CSS3、FlexboxJavaScript：    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs其他：    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力</code></pre><p>作为一名前端工程师，<strong>无论工作年头长短都应该掌握的知识点</strong>：</p><p>此条由 王子墨 发表在 <a href="http://lab.yuanwai.wang/" target="_blank" rel="noopener">攻城师的实验室</a></p><pre><code>    1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。    2、DOM操作 ——如何添加、移除、移动、复制、创建和查找节点等。    3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。    4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。    5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。    6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型    7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们    8、浮动元素 ——怎么使用它们、它们有什么问题以及怎么解决这些问题。    9、HTML与XHTML ——二者有什么区别，你觉得应该使用哪一个并说出理由。    10、JSON —— 作用、用途、设计结构。</code></pre><p><strong>备注：</strong></p><pre><code>根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。</code></pre><p>###更新时间:  2015-10-9</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><a name='html'>HTML</a></h2><ul><li><p>Doctype作用？标准模式与兼容模式各有什么区别?</p><pre><code>  （1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。  （2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</code></pre></li><li><p>HTML5 为什么只需要写 <!DOCTYPE HTML>？</p><pre><code>   HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；   而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</code></pre></li><li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p><pre><code>  首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。  （1）行内元素有：a b span img input select strong（强调的语气）  （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p  （3）常见的空元素：      &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;      鲜为人知的是：      &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></pre></li></ul><ul><li>页面导入样式时，使用link和@import有什么区别？</li></ul><pre><code>    （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;    （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;    （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</code></pre><ul><li><p>介绍一下你对浏览器内核的理解？</p><pre><code>  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然  后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。  所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。  JS引擎则：解析和执行javascript来实现网页的动态效果。  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</code></pre></li><li><p>常见的浏览器内核有哪些？</p><pre><code>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)</code></pre></li></ul><ul><li>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和<br>HTML5？</li></ul><pre><code>    * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。          绘画 canvas;          用于媒介回放的 video 和 audio 元素;          本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;          sessionStorage 的数据在浏览器关闭后自动删除;          语意化更好的内容元素，比如 article、footer、header、nav、section;          表单控件，calendar、date、time、email、url、search;          新的技术webworker, websockt, Geolocation;      移除的元素：          纯表现的元素：basefont，big，center，font, s，strike，tt，u;          对可用性产生负面影响的元素：frame，frameset，noframes；    * 支持HTML5新标签：         IE8/IE7/IE6支持通过document.createElement方法产生的标签，           可以利用这一特性让这些浏览器支持HTML5新标签，           浏览器支持新标签后，还需要添加标签默认的样式。         当然最好的方式是直接使用成熟的框架、比如html5shim;         &lt;!--[if lt IE 9]&gt;            &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;         &lt;![endif]--&gt;    * 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</code></pre><ul><li><p>简述一下你对HTML语义化的理解？</p><pre><code>  用正确的标签做正确的事情。  html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;  及时在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的;  搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;  使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre></li></ul><ul><li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p><pre><code>  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</code></pre></li></ul><pre><code>    如何使用：    1、页面头部像下面一样加入一个manifest的属性；    2、在cache.manifest文件的编写离线存储的资源；        CACHE MANIFEST        #v0.11        CACHE:        js/app.js        css/style.css        NETWORK:        resourse/logo.png        FALLBACK:        / /offline.html    3、在离线状态时，操作window.applicationCache进行需求实现。    详细的使用请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)</code></pre><ul><li><p>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</p><pre><code>  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。  离线的情况下，浏览器就直接使用离线存储的资源。  详细的使用请参考：[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)</code></pre></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p><pre><code>  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。  存储大小：      cookie数据大小不能超过4k。      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。  有期时间：      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；      sessionStorage  数据在当前浏览器窗口关闭后自动删除。      cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</code></pre></li><li><p>iframe有那些缺点？</p><pre><code>  *iframe会阻塞主页面的Onload事件；  *搜索引擎的检索程序无法解读这种页面，不利于SEO;  *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。      使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript         动态给iframe添加src属性值，这样可以绕开以上两个问题。</code></pre></li><li><p>Label的作用是什么？是怎么用的？</p><pre><code>  label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。  &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;  &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;  &lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</code></pre></li><li><p>HTML5的form如何关闭自动完成功能？</p><pre><code>  给不想要提示的 form 或下某个input 设置为 autocomplete=off。</code></pre></li></ul><ul><li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p><pre><code>  调用localstorge、cookies等本地存储方式</code></pre></li><li><p>webSocket如何兼容低浏览器？(阿里)</p><pre><code>  Adobe Flash Socket 、  ActiveX HTMLFile (IE) 、  基于 multipart 编码发送 XHR 、  基于长轮询的 XHR</code></pre></li><li><p>页面可见性（Page Visibility）API 可以有哪些用途？</p><pre><code>  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</code></pre></li><li><p>如何在页面上实现一个圆形的可点击区域？</p><pre><code>  1、map+area或者svg  2、border-radius  3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</code></pre></li><li><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p><pre><code>  &lt;div style=&quot;height:1px;overflow:hidden;background:#ccc&quot;&gt;&lt;/div&gt;</code></pre></li></ul><ul><li><p>网页验证码是干嘛的，是为了解决什么安全问题。</p><pre><code>  区分用户是计算机还是人的公共全自动程序。可以防止：恶意破解密码、刷票、论坛灌水；  有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试；</code></pre></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a name='css'>CSS</a></h2><ul><li><p>介绍一下CSS的盒子模型？</p><pre><code>  （1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</code></pre></li></ul><ul><li><p>CSS选择符有哪些？哪些属性可以继承？</p><pre><code>  *   1.id选择器（ # myid）      2.类选择器（.myclassname）      3.标签选择器（div, h1, p）      4.相邻选择器（h1 + p）      5.子选择器（ul &gt; li）      6.后代选择器（li a）      7.通配符选择器（ * ）      8.属性选择器（a[rel = &quot;external&quot;]）      9.伪类选择器（a: hover, li: nth - child）  *   可继承的样式： font-size font-family color, UL LI DL DD DT;  *   不可继承的样式：border padding margin width height ;</code></pre></li></ul><ul><li><p>CSS优先级算法如何计算？</p><pre><code>  *   优先级就近原则，同权重情况下样式定义最近者为准;  *   载入样式以最后载入的定位为准;  优先级为:     !important &gt;  id &gt; class &gt; tag      important 比 内联优先级高</code></pre></li><li><p>CSS3新增伪类有那些？</p><pre><code>  CSS3新增伪类举例：      p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。      p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。       :enabled          :disabled 控制表单控件的禁用状态。      :checked        单选框或复选框被选中。</code></pre></li><li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p></li></ul><pre><code>*  给div设置一个宽度，然后添加margin:0 auto属性        div{            width:200px;            margin:0 auto;         }*  居中一个浮动元素          确定容器的宽高 宽500 高 300 的层          设置层的外边距         .div {              width:500px ; height:300px;//高度可以不设              margin: -150px 0 0 -250px;              position:relative;         //相对定位              background-color:pink;     //方便看效果              left:50%;              top:50%;         }*  让绝对定位的div居中          position: absolute;          width: 1200px;          background: none;          margin: 0 auto;          top: 0;          left: 0;          bottom: 0;          right: 0;</code></pre><ul><li>display有哪些值？说明他们的作用。</li></ul><pre><code>      block 象块类型元素一样显示。      none 缺省值。象行内元素类型一样显示。      inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。      list-item 象块类型元素一样显示，并添加样式列表标记。</code></pre><ul><li><p>position的值relative和absolute定位原点是？</p><pre><code>    absolute      生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。    fixed （老IE不支持）      生成绝对定位的元素，相对于浏览器窗口进行定位。    relative      生成相对定位的元素，相对于其正常位置进行定位。    static      默认值。没有定位，元素出现在正常的流中     （忽略 top, bottom, left, right z-index 声明）。    inherit      规定从父元素继承 position 属性的值。</code></pre></li><li><p>CSS3有哪些新特性？</p><pre><code>      CSS3实现圆角（border-radius:8px），    阴影（box-shadow:10px），    文字特效（text-shadow、），    线性渐变（gradient），    旋转（transform）   transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜          增加了更多的CSS选择器   多背景 rgba</code></pre></li><li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p><pre><code>   布局用来确定页面上不同组件和元素的尺寸和位置。随着响应式用户界面的流行，Web 应用一般都要求适配不同的设备尺寸和浏览器分辨率。  需要根据窗口尺寸来调整布局，从而改变组件的尺寸和位置，以达到最佳的显示效果</code></pre></li><li><p>用纯CSS创建一个三角形的原理是什么？</p><pre><code>  把上、左、右三条边隐藏掉（颜色设为 transparent）  #demo {    width: 0;    height: 0;    border-width: 20px;    border-style: solid;    border-color: transparent transparent red transparent;  }</code></pre></li><li><p>HTML如何获取浏览器的宽度？</p><pre><code>  目前来讲html不具备获取浏览器宽度的能力。可以采用js的方式来获取，具体示例JS代码如下：  // 获取窗口宽度  if (window.innerWidth)  winWidth = window.innerWidth;  else if ((document.body) &amp;&amp; (document.body.clientWidth))  winWidth = document.body.clientWidth;  // 获取窗口高度  if (window.innerHeight)  winHeight = window.innerHeight;  else if ((document.body) &amp;&amp; (document.body.clientHeight))  winHeight = document.body.clientHeight;  // 通过深入 Document 内部对 body 进行检测，获取窗口大小  if (document.documentElement &amp;&amp; document.documentElement.clientHeight &amp;&amp; document.documentElement.clientWidth)  {  winHeight = document.documentElement.clientHeight;  winWidth = document.documentElement.clientWidth;      }  jQuery 获取屏幕高度、宽度  做手机Web开发做浏览器兼容用到了，所以在网上找了些汇总下。  alert($(window).height()); //浏览器当前窗口可视区域高度   alert($(document).height()); //浏览器当前窗口文档的高度   alert($(document.body).height());//浏览器当前窗口文档body的高度   alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin   alert($(window).width()); //浏览器当前窗口可视区域宽度   alert($(document).width());//浏览器当前窗口文档对象宽度   alert($(document.body).width());//浏览器当前窗口文档body的高度   alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin   // 获取页面的高度、宽度  function getPageSize() {      var xScroll, yScroll;      if (window.innerHeight &amp;&amp; window.scrollMaxY) {          xScroll = window.innerWidth + window.scrollMaxX;          yScroll = window.innerHeight + window.scrollMaxY;      } else {          if (document.body.scrollHeight &gt; document.body.offsetHeight) { // all but Explorer Mac                  xScroll = document.body.scrollWidth;              yScroll = document.body.scrollHeight;          } else { // Explorer Mac...would also work in Explorer 6 Strict, Mozilla and Safari                  xScroll = document.body.offsetWidth;              yScroll = document.body.offsetHeight;          }      }      var windowWidth, windowHeight;      if (self.innerHeight) { // all except Explorer              if (document.documentElement.clientWidth) {              windowWidth = document.documentElement.clientWidth;          } else {              windowWidth = self.innerWidth;          }          windowHeight = self.innerHeight;      } else {          if (document.documentElement &amp;&amp; document.documentElement.clientHeight) { // Explorer 6 Strict Mode                  windowWidth = document.documentElement.clientWidth;              windowHeight = document.documentElement.clientHeight;          } else {              if (document.body) { // other Explorers                      windowWidth = document.body.clientWidth;                  windowHeight = document.body.clientHeight;              }          }      }             // for small pages with total height less then height of the viewport          if (yScroll &lt; windowHeight) {          pageHeight = windowHeight;      } else {          pageHeight = yScroll;      }          // for small pages with total width less then width of the viewport          if (xScroll &lt; windowWidth) {          pageWidth = xScroll;      } else {          pageWidth = windowWidth;      }      arrayPageSize = new Array(pageWidth, pageHeight, windowWidth, windowHeight);      return arrayPageSize;  }  // 滚动条  document.body.scrollTop;  $(document).scrollTop();</code></pre></li><li><p>一个满屏 品 字布局 如何设计?</p><pre><code>      简单的方式：      上面的div宽100%，      下面的两个div分别宽50%，      然后用float或者inline使其不换行即可</code></pre></li></ul><ul><li><p>常见兼容性问题？</p><pre><code>  * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.  * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。  * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。    浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}       这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)    渐进识别的方式，从总体中逐渐排除局部。    首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。    css        .bb{            background-color:#f1ee18;/*所有识别*/            .background-color:#00deff\9; /*IE6、7、8识别*/            +background-color:#a200ff;/*IE6、7识别*/            _background-color:#1e0bd1;/*IE6识别*/        }  *  IE下,可以使用获取常规属性的方法来获取自定义属性,  也可以使用getAttribute()获取自定义属性;         Firefox下,只能使用getAttribute()获取自定义属性。         解决方法:统一通过getAttribute()获取自定义属性。  *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;         Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。  *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。  *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,     可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。     超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:      L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</code></pre></li></ul><ul><li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p><p>  li与li之间有看不见的空白。解决办法，可以设置浮动，不想浮动的话在ul用font-size:0去掉空白，像chrome不支持font-size:0的用letter-spacing:-3px这样的方式去掉li间的空白。</p></li><li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p><pre><code>  http://www.cnblogs.com/lgmcolin/archive/2013/02/12/2910179.html  http://www.duitang.com/static/csshack.html</code></pre></li><li><p>为什么要初始化CSS样式。</p><pre><code>  - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。  - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。  最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）  淘宝的样式初始化代码：  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }  body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }  h1, h2, h3, h4, h5, h6{ font-size:100%; }  address, cite, dfn, em, var { font-style:normal; }  code, kbd, pre, samp { font-family:couriernew, courier, monospace; }  small{ font-size:12px; }  ul, ol { list-style:none; }  a { text-decoration:none; }  a:hover { text-decoration:underline; }  sup { vertical-align:text-top; }  sub{ vertical-align:text-bottom; }  legend { color:#000; }  fieldset, img { border:0; }  button, input, select, textarea { font-size:100%; }  table { border-collapse:collapse; border-spacing:0; }</code></pre></li></ul><ul><li><p>absolute的containing block(容器块)计算方式跟正常流有什么不同？</p><pre><code>  无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：  1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；  2、否则,则由这个祖先元素的 padding box 构成。  如果都找不到，则为 initial containing block。  补充：  1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）  2. absolute: 向上找最近的定位为absolute/relative的元素  3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</code></pre></li><li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p><pre><code>  visible： 设置对象可视   hidden： 设置对象隐藏   collapse： 主要用来隐藏表格的行或列。隐藏的行或列能够被其他内容使用。对于表格外的其他对象，其作用等同于hidden。IE6及以下不支持此参数值 </code></pre></li><li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p><pre><code>  http://www.cnblogs.com/jackyWHJ/p/3756087.html</code></pre></li><li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p><pre><code>  （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</code></pre></li><li><p>css定义的权重</p><pre><code>  以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：  /*权重为1*/  div{  }  /*权重为10*/  .class1{  }  /*权重为100*/  #id1{  }  /*权重为100+1=101*/  #id1 div{  }  /*权重为10+1=11*/  .class1 div{  }  /*权重为10+10+1=21*/  .class1 .class2 div{  }  如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</code></pre></li></ul><ul><li>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式</li></ul><ul><li>移动端的布局用过媒体查询吗？</li></ul><ul><li><p>使用 CSS 预处理器吗？喜欢那个？</p><pre><code>  SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</code></pre></li></ul><ul><li><p>CSS优化、提高性能的方法有哪些？</p></li><li><p>浏览器是怎样解析CSS选择器的？</p></li><li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？<br>偶数 更容易去其他设计构成比例</p></li><li><p>margin和padding分别适合什么场景使用？<br>外边距  内间距</p></li><li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p></li><li><p>元素竖向的百分比设定是相对于容器的高度吗？<br>这是一个很让人困惑的CSS特征，我之前也谈到过它。我们大家都知道，当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如padding-top,padding-bottom,margin-top,margin-bottom等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p></li><li><p>全屏滚动的原理是什么？用到了CSS的那些属性？<br>图片轮播原理，只不过图片宽高100%、超出隐藏、调整比例适应屏幕大小</p></li><li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p></li></ul><p>//- 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p><ul><li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。<br>  单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。</p></li><li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？<br>  可以对input:-webkit-autofill使用足够大的纯色内阴影来覆盖input输入框的黄色背景；如：</p><p>  input:-webkit-autofill {<br>  -webkit-box-shadow: 0 0 0px 1000px white inset;<br>  border: 1px solid #CCC!important;<br>  }<br>如果你有使用圆角等属性，或者发现输入框的长度高度不太对，可以对其进行调整，除了chrome默认定义的background-color，background-image，color不能用!important提升其优先级以外，其他的属性均可使用!important提升其优先级，如：</p><p>  input:-webkit-autofill {<br>  -webkit-box-shadow: 0 0 0px 1000px white inset;<br>  border: 1px solid #CCC!important;<br>  height: 27px!important;<br>  line-height: 27px!important;<br>  border-radius: 0 4px 4px 0;<br>  }</p></li><li><p>你对line-height是如何理解的？<br>  基线位置是由字体确定的，css的line-height指的是一行字的高度，包含了字间距，实际上就是下一行的基线到上一行的基线距离。</p></li><li><p>设置元素浮动后，该元素的display值是多少？（自动变成display:block）</p></li><li><p>怎么让Chrome支持小于12px 的文字？<br>  .shrink{-webkit-transform:scale(0.8);-o-transform:scale(1); display:inline-block}</p></li><li><p>让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）</p></li><li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？<br>  可以理解成Italic是使用文字的斜体，Oblique是让没有斜体属性的文字倾斜</p></li><li><p>position:fixed;在android下无效怎么处理？</p>  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" /></li><li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p><pre><code>  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</code></pre></li><li><p>display:inline-block 什么时候会显示间隙？(携程)</p><pre><code>  移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</code></pre></li><li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p></li><li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p>  <div class="outer">      <div class="A"></div>      <div class="B"></div>  </div>  html,  body { height: 100%; padding: 0; margin: 0; }  .outer { height: 100%; padding: 100px 0 0; box-sizing: border-box ; position: relative; }  .A { height: 100px; background: #BBE8F2; position: absolute; top: 0 ; left: 0 ; width: 100%; }  .B { height: 100%; background: #D9C666; }</li><li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？<br>  <a href="http://www.tuicool.com/articles/AbUvI3A" target="_blank" rel="noopener">http://www.tuicool.com/articles/AbUvI3A</a></p></li><li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p><pre><code>  如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，  所以不如隔离开。  因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，  这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。  同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，  提高了webserver的http请求的解析速度。</code></pre></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a name='js'>JavaScript</a></h2><ul><li><p>介绍js的基本数据类型。</p><pre><code>  Undefined、Null、Boolean、Number、String</code></pre></li><li><p>介绍js有哪些内置对象？</p><pre><code> Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error</code></pre></li><li><p>说几条写JavaScript的基本规范？</p><pre><code> 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre></li><li><p>JavaScript原型，原型链 ? 有什么特点？</p><pre><code> 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</code></pre></li></ul><pre><code>     当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，     就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。        function Func(){}        Func.prototype.name = &quot;Sean&quot;;        Func.prototype.getInfo = function() {          return this.name;        }        var person = new Func();//现在可以参考var person = Object.create(oldObject);        console.log(person.getInfo());//它拥有了Func的属性和方法        //&quot;Sean&quot;        console.log(Func.prototype);        // Func { name=&quot;Sean&quot;, getInfo=function()}</code></pre><ul><li><p>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p><pre><code> 堆：原始数据类型（Undefined，Null，Boolean，Number、String）  栈：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体</code></pre><p> <img src="http://www.w3school.com.cn/i/ct_js_value.gif" alt="Stated Clearly Image"></p></li></ul><ul><li><p>Javascript如何实现继承？</p><pre><code> 1、构造继承 2、原型继承 3、实例继承 4、拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。  function Parent(){         this.name = &#39;wang&#39;;     }     function Child(){         this.age = 28;     }     Child.prototype = new Parent();//继承了Parent，通过原型     var demo = new Child();     alert(demo.age);     alert(demo.name);//得到被继承的属性   }</code></pre></li><li><p>javascript创建对象的几种方式？</p><pre><code> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</code></pre></li></ul><pre><code>    1、对象字面量的方式           person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};    2、用function来模拟无参的构造函数        function Person(){}        var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class        person.name=&quot;Mark&quot;;        person.age=&quot;25&quot;;        person.work=function(){        alert(person.name+&quot; hello...&quot;);        }        person.work();    3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）        function Pet(name,age,hobby){           this.name=name;//this作用域：当前对象           this.age=age;           this.hobby=hobby;           this.eat=function(){              alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);           }        }        var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象        maidou.eat();//调用eat方法    4、用工厂方式来创建（内置对象）         var wcDog =new Object();         wcDog.name=&quot;旺财&quot;;         wcDog.age=3;         wcDog.work=function(){           alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);         }         wcDog.work();    5、用原型方式来创建        function Dog(){         }         Dog.prototype.name=&quot;旺财&quot;;         Dog.prototype.eat=function(){         alert(this.name+&quot;是个吃货&quot;);         }         var wangcai =new Dog();         wangcai.eat();    5、用混合方式来创建        function Car(name,price){          this.name=name;          this.price=price;         }         Car.prototype.sell=function(){           alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);          }        var camry =new Car(&quot;凯美瑞&quot;,27);        camry.sell(); </code></pre><ul><li><p>Javascript作用链域?</p><pre><code> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</code></pre></li><li><p>谈谈This对象的理解。<a href="http://www.jb51.net/article/71155.htm" target="_blank" rel="noopener">http://www.jb51.net/article/71155.htm</a></p><ol><li>不像C#，this一定是指向当前对象。<br> js的this指向是不确定的，也就是说是可以动态改变的。call/apply 就是用于改变this指向的函数，这样设计可以让代码更加灵活，复用性更高。</li><li>this 一般情况下，都是指向函数的拥有者。</li><li>在函数自执行里，this 指向的是 window 对象</li></ol></li><li><p>eval是做什么的？</p><pre><code> 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</code></pre></li><li><p>什么是window对象? 什么是document对象?<a href="http://www.jb51.net/article/25826.htm" target="_blank" rel="noopener">http://www.jb51.net/article/25826.htm</a><br> [document对象]<br> 　　该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档。 </p><p> 　　属性 </p><p> 　　alinkColor 活动链接的颜色(ALINK)<br> 　　anchor 一个HTMI锚点,使用&lt;A NAME=&gt;标记创建(该属性本身也是一个对象)<br> 　　anchors array 列出文档锚点对象的数组(&lt;A NAME=&gt;)(该属性本身也是一个对象)<br> 　　bgColor 文档的背景颜色(BGCOLOR)<br> 　　cookie 存储于cookie.txt文件内的一段信息,它是该文档对象的一个属性<br> 　　fgColor 文档的文本颜色(<BODY>标记里的TEXT特性)<br> 　　form 文档中的一个窗体(<FORM>)(该属性本身也是一个对象)<br> 　　forms anay 按照其出现在文档中的顺序列出窗体对象的一个数组(该属性本身也是一个对象)<br> 　　lastModified 文档最后的修改日期<br> 　　linkColor 文档的链接的颜色,即<BODY>标记中的LINK特性(链接到用户没有观察到的文档)<br> 　　link 文档中的一个&lt;A HREF=&gt;标记(该属性本身也是一个对象)<br> 　　links array 文档中link对象的一个数组,按照它们出现在文档中的顺序排列(该属性本身也是一个对象)<br> 　　location 当前显示文档的URL。用户不能改变document.location(因为这是当前显示文档的位置)。但是,可以改变window.location (用其它文档取代当前文档)window.location本身也是一个对象,而document.location不是对象<br> 　　referrer 包含链接的文档的URL,用户单击该链接可到达当前文档<br> 　　title 文档的标题((TITLE&gt;)<br> 　　vlinkColor 指向用户已观察过的文档的链接文本颜色,即<BODY>标记的VLINK特性 </p><p> 　　方法 </p><p> 　　clear 清除指定文档的内容<br> 　　close 关闭文档流<br> 　　open 打开文档流<br> 　　write 把文本写入文档<br> 　　writeln 把文本写入文档,并以换行符结尾 </p><p> [window对象] </p><p> 　　它是一个顶层对象,而不是另一个对象的属性即浏览器的窗口。 </p><p> 　　属性 </p><p> 　　defaultStatus 缺省的状态条消息<br> 　　document 当前显示的文档(该属性本身也是一个对象)<br> 　　frame 窗口里的一个框架((FRAME&gt;)(该属性本身也是一个对象)<br> 　　frames array 列举窗口的框架对象的数组,按照这些对象在文档中出现的顺序列出(该属性本身也是一个对象)<br> 　　history 窗口的历史列表(该属性本身也是一个对象)<br> 　　length 窗口内的框架数<br> 　　location 窗口所显示文档的完整(绝对)URL(该属性本身也是一个对象)不要把它与如document.location混淆,后者是当前显示文档的URL。用户可以改变window.location(用另一个文档取代当前文档),但却不能改变document.location(因为这是当前显示文档的位置)<br> 　　name 窗口打开时,赋予该窗口的名字<br> 　　opener 代表使用window.open打开当前窗口的脚本所在的窗口(这是Netscape Navigator 3.0beta 3所引入的一个新属性)<br> 　　parent 包含当前框架的窗口的同义词。frame和window对象的一个属性<br> 　　self 当前窗口或框架的同义词<br> 　　status 状态条中的消息<br> 　　top 包含当前框架的最顶层浏览器窗口的同义词<br> 　　window 当前窗口或框架的同义词,与self相同 </p><p> 　　方法 </p><p> 　　alert() 打开一个Alert消息框<br> 　　clearTimeout() 用来终止setTimeout方法的工作<br> 　　close() 关闭窗口<br> 　　confirm() 打开一个Confirm消息框,用户可以选择OK或Cancel,如果用户单击OK,该方法返回true,单击Cancel返回false<br> 　　blur() 把焦点从指定窗口移开(这是Netscape Navigator 3.0 beta 3引入的新方法)<br> 　　focus() 把指定的窗口带到前台(另一个新方法)<br> 　　open() 打开一个新窗口<br> 　　prompt() 打开一个Prompt对话框,用户可向该框键入文本,并把键入的文本返回到脚本<br> 　　setTimeout() 等待一段指定的毫秒数时间,然后运行指令事件处理程序 </p><p> 　　事件处理程序 </p><p> 　　Onload() 页面载入时触发<br> 　　Onunload() 页面关闭时触发</p></li><li><p>null，undefined 的区别？</p><pre><code> null         表示一个对象被定义了，值为“空值”； undefined     表示不存在这个值。</code></pre></li></ul><pre><code>    typeof undefined        //&quot;undefined&quot;        undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；         例如变量被声明了，但没有赋值时，就等于undefined    typeof null        //&quot;object&quot;        null : 是一个对象(空对象, 没有任何属性和方法)；        例如作为函数的参数，表示该函数的参数不是对象；    注意：        在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined    再来一个例子：        null        Q：有张三这个人么？        A：有！        Q：张三有房子么？        A：没有！        undefined        Q：有张三这个人么？        A：没有！</code></pre><ul><li><p>写一个通用的事件侦听器函数。</p><pre><code>     // event(事件)工具集，来源：github.com/markyun     markyun.Event = {         // 页面加载完成后         readyEvent : function(fn) {             if (fn==null) {                 fn=document;             }             var oldonload = window.onload;             if (typeof window.onload != &#39;function&#39;) {                 window.onload = fn;             } else {                 window.onload = function() {                     oldonload();                     fn();                 };             }         },         // 视能力分别使用dom0||dom2||IE方式 来绑定事件         // 参数： 操作的元素,事件名称 ,事件处理程序         addEvent : function(element, type, handler) {             if (element.addEventListener) {                 //事件类型、需要执行的函数、是否捕捉                 element.addEventListener(type, handler, false);             } else if (element.attachEvent) {                 element.attachEvent(&#39;on&#39; + type, function() {                     handler.call(element);                 });             } else {                 element[&#39;on&#39; + type] = handler;             }         },         // 移除事件         removeEvent : function(element, type, handler) {             if (element.removeEventListener) {                 element.removeEventListener(type, handler, false);             } else if (element.datachEvent) {                 element.detachEvent(&#39;on&#39; + type, handler);             } else {                 element[&#39;on&#39; + type] = null;             }         },         // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)         stopPropagation : function(ev) {             if (ev.stopPropagation) {                 ev.stopPropagation();             } else {                 ev.cancelBubble = true;             }         },         // 取消事件的默认行为         preventDefault : function(event) {             if (event.preventDefault) {                 event.preventDefault();             } else {                 event.returnValue = false;             }         },         // 获取事件目标         getTarget : function(event) {             return event.target || event.srcElement;         },         // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；         getEvent : function(e) {             var ev = e || window.event;             if (!ev) {                 var c = this.getEvent.caller;                 while (c) {                     ev = c.arguments[0];                     if (ev &amp;&amp; Event == ev.constructor) {                         break;                     }                     c = c.caller;                 }             }             return ev;         }     };</code></pre></li><li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p><pre><code>  [1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，  其中 radix 表示解析时用的基数。  map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</code></pre></li><li><p>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p><pre><code>  1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。  2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；  3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</code></pre></li></ul><ul><li><p>什么是闭包（closure），为什么要用它？</p><pre><code> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性： 1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收 //li节点的onclick事件都能正确的弹出当前被点击的li索引  &lt;ul id=&quot;testUL&quot;&gt;     &lt;li&gt; index = 0&lt;/li&gt;     &lt;li&gt; index = 1&lt;/li&gt;     &lt;li&gt; index = 2&lt;/li&gt;     &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt;     var nodes = document.getElementsByTagName(&quot;li&quot;);     for(i = 0;i&lt;nodes.length;i+= 1){         nodes[i].onclick = function(){             console.log(i+1);//不用闭包的话，值每次都是4         }(i);     } &lt;/script&gt;</code></pre></li></ul><pre><code>    执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在    使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源    因为say667()的内部函数的执行需要依赖say667()中的变量    这是对闭包作用的非常直白的描述      function say667() {        // Local variable that ends up within closure        var num = 666;        var sayAlert = function() {            alert(num);        }        num++;        return sayAlert;    }     var sayAlert = say667();     sayAlert()//执行结果应该弹出的667</code></pre><ul><li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p><pre><code> use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。</code></pre></li></ul><ul><li><p>如何判断一个对象是否属于某个类？</p><pre><code>    使用instanceof （待完善）    if(a instanceof Person){        alert(&#39;yes&#39;);    }</code></pre></li><li><p>new操作符具体干了什么呢?</p><pre><code>      1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。          2、属性和方法被加入到 this 引用的对象中。       3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。     var obj  = {};     obj.__proto__ = Base.prototype;     Base.call(obj);</code></pre></li></ul><ul><li><p>用原生JavaScript的实现过什么功能吗？<br> <a href="http://www.cnblogs.com/lhb25/p/you-might-not-need-jquery.html" target="_blank" rel="noopener">http://www.cnblogs.com/lhb25/p/you-might-not-need-jquery.html</a></p></li><li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p><pre><code> hasOwnProperty javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</code></pre></li><li><p>JSON 的了解？</p><pre><code> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小        如：{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></pre></li><li><p><code>[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)})</code> 能解释一下这段代码的意思吗？<br> 这段代码只是首先获取了所有的页面元素，然后使用一个不同的颜色为它们添加了一个1ps的边框<br> <a href="http://sentsin.com/web/881.html" target="_blank" rel="noopener">http://sentsin.com/web/881.html</a></p></li><li><p>js延迟加载的方式有哪些？</p><pre><code> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</code></pre></li></ul><ul><li><p>Ajax 是什么? 如何创建一个Ajax？</p><pre><code> ajax的全称：Asynchronous Javascript And XML。 异步传输+js+xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新</code></pre></li><li><p>同步和异步的区别?</p><p> 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,j进行下一步操作。</p><p> 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p><p> （待完善）</p></li><li><p>如何解决跨域问题?<a href="http://blog.csdn.net/joyhen/article/details/21631833" target="_blank" rel="noopener">http://blog.csdn.net/joyhen/article/details/21631833</a></p><pre><code> jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</code></pre></li><li><p>页面编码和被请求的资源编码如果不一致如何处理？<br> String str1 = new String(str.getBytes(“你的编码方式”),”它的编码方式”);</p></li><li><p>模块化开发怎么做？</p><p>  <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="noopener"> 立即执行函数</a>,不暴露私有成员</p><pre><code>     var module1 = (function(){     　　　　var _count = 0;     　　　　var m1 = function(){     　　　　　　//...     　　　　};     　　　　var m2 = function(){     　　　　　　//...     　　　　};     　　　　return {     　　　　　　m1 : m1,     　　　　　　m2 : m2     　　　　};     　　})();</code></pre><p> （待完善）</p></li><li><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p><blockquote><p>AMD 规范在这里：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">https://github.com/amdjs/amdjs-api/wiki/AMD</a></p></blockquote><blockquote><p>CMD 规范在这里：<a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/242</a></p></blockquote><pre><code> Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。  区别：     1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： // CMD define(function(require, exports, module) {     var a = require(&#39;./a&#39;)     a.doSomething()     // 此处略去 100 行     var b = require(&#39;./b&#39;) // 依赖可以就近书写     b.doSomething()     // ... }) // AMD 默认推荐 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好     a.doSomething()     // 此处略去 100 行     b.doSomething()     // ... })</code></pre></li></ul><ul><li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何<br>缓存的？）</p></li><li><p>谈一谈你对ECMAScript6的了解？<br> <a href="http://www.oschina.net/news/71566/es6-developers-will-have-to-know" target="_blank" rel="noopener">http://www.oschina.net/news/71566/es6-developers-will-have-to-know</a></p></li><li><p>ECMAScript6 怎么写class么，为什么会出现class这种东西? </p></li><li><p>异步加载JS的方式有哪些？</p><pre><code>   (1) defer，只支持IE   (2) async：   (3) 创建script，插入到DOM中，加载完毕后callBack</code></pre></li><li><p>documen.write和 innerHTML的区别</p><pre><code>  document.write只能重绘整个页面  innerHTML可以重绘页面的一部分</code></pre></li><li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p><pre><code>  （1）创建新节点    createDocumentFragment()    //创建一个DOM片段    createElement()   //创建一个具体的元素    createTextNode()   //创建一个文本节点  （2）添加、移除、替换、插入    appendChild()    removeChild()    replaceChild()    insertBefore() //在已有的子节点前插入一个新的子节点  （3）查找    getElementsByTagName()    //通过标签名称    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)    getElementById()    //通过元素Id，唯一性</code></pre></li><li><p>.call() 和 .apply() 的区别？</p></li></ul><pre><code>      例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);      注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。        function add(a,b)        {            alert(a+b);        }        function sub(a,b)        {            alert(a-b);        }        add.call(sub,3,1);</code></pre><ul><li><p>数组和对象有哪些原生方法，列举一下？</p></li><li><p>JS 怎么实现一个类。怎么实例化这个类<br> function Users(obj) {<br> var name = obj.name;<br> var age = obj.age;<br> var addr = obj.addr;</p><pre><code> function User(name, age, addr) {</code></pre><p> this.name = name;<br> this.age = age;<br> this.addr = addr;<br> }<br> return new User(name, age, addr);<br> }</p><p> var x = Users({name:”user1”, age:25, addr:”china”});<br> alert(x.name);</p></li><li><p>JavaScript中的作用域与变量声明提升？<br> <a href="http://blog.csdn.net/sunxing007/article/details/9034253" target="_blank" rel="noopener">http://blog.csdn.net/sunxing007/article/details/9034253</a></p></li><li><p>如何编写高性能的Javascript？<br> <a href="http://developer.51cto.com/art/200906/131335.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/200906/131335.htm</a></p></li><li><p>那些操作会造成内存泄漏？<a href="http://www.ibm.com/developerworks/cn/web/wa-jsmemory/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/web/wa-jsmemory/</a><br> 闭包 控制台日志 循环</p></li><li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p></li><li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p></li><li><p>jquery中如何将数组转化为json字符串，然后再转化回来？<br> JSON.stringify 把一个对象转换成json字符串，<br> JSON.parse 把一个json字符串解析成对象。</p></li><li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？<a href="http://www.jb51.net/article/60689.htm" target="_blank" rel="noopener">http://www.jb51.net/article/60689.htm</a> </p></li><li><p>jquery.extend 与 jquery.fn.extend的区别？<a href="http://www.jb51.net/article/60689.htm" target="_blank" rel="noopener">http://www.jb51.net/article/60689.htm</a><br> 一个用来扩展静态方法，一个用来扩展实例方法。</p></li><li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p></li><li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？<br> bind(type,[data],fn) 为每个匹配元素的特定事件绑定事件处理函数<br> live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的<br> delegate(selector,[type],[data],fn) 指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数<br> on(events,[selector],[data],fn) 在选择元素上绑定一个或多个事件的事件处理函数<br> 差别：</p><p> .bind()是直接绑定在元素上</p><p> .live()则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和.bind()的优势是支持动态数据。</p><p> .delegate()则是更精确的小范围使用事件代理，性能优于.live()</p><p> .on()则是最新的1.9版本整合了之前的三种方式的新事件绑定机制</p></li><li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？<br> .bind()是直接绑定在元素上</p><p> .live()则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和.bind()的优势是支持动态数据。</p><p> .delegate()则是更精确的小范围使用事件代理，性能优于.live()</p><p> .on()则是最新的1.9版本整合了之前的三种方式的新事件绑定机制</p></li><li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p></li><li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？<br> （jQuery.fn.find()进入Sizzle）</p></li><li><p>针对 jQuery性能的优化方法？<br> 1，总是从ID选择器开始继承<br> 2，在class前使用tag(标签名)<br> 3，将jQuery对象缓存起来<br> 4，对直接的DOM操作进行限制<br> 5，冒泡<br> 6，推迟到 $(window).load<br> 7，压缩JavaScript<br> 8，尽量使用ID代替Class。<br> 9，给选择器一个上下文<br> 10，慎用 .live()方法（应该说尽量不要使用）</p></li><li><p>Jquery与jQuery UI 有啥区别？</p></li></ul><pre><code>*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。    提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</code></pre><ul><li>jquery 中如何将数组转化为json字符串，然后再转化回来？</li></ul><p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</p><pre><code>    $.fn.stringifyArray = function(array) {        return JSON.stringify(array)    }    $.fn.parseArray = function(array) {        return JSON.parse(array)    }    然后调用：    $(&quot;&quot;).stringifyArray(array)</code></pre><ul><li><p>jQuery和Zepto的区别？各自的使用场景？<br> zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。<br> jquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。</p><p> jq自身也注意到了这个总是，所有它的2.x版本是不支持ie6 7 8的，大致就是这些。</p></li><li><p>针对 jQuery 的优化方法？</p><pre><code> *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。  比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); *for (var i = size; i &lt; arr.length; i++) {}  for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：  for (var i = size, length = arr.length; i &lt; length; i++) {}</code></pre></li></ul><ul><li><p>Zepto的点透问题如何解决？<br> <a href="http://www.bubuko.com/infodetail-649496.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-649496.html</a></p></li><li><p>jQueryUI如何自定义组件?<br> <a href="http://bbs.chinaunix.net/linux/jqueryui.shtml" target="_blank" rel="noopener">http://bbs.chinaunix.net/linux/jqueryui.shtml</a></p></li><li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p></li><li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p><pre><code>  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</code></pre></li><li><p>移动端最小触控区域是多大？</p></li><li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p></li><li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？<br> 如下的经验规则：<br> 1.当JavaScript要在页面加载过程中动态建立一些Web页面的内容时，应将JavaScript放在body中。<br> 2.定义为函数并用于页面事件的JavaScript应当放在head标记中，因为它会在body之前加载。<br> 采用这种方法，页面就不会被脚本搞得一团糟，易于阅读，在每个页面中，总可以在同一个位置找到脚本。</p></li><li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p></li><li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p></li><li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p></li><li><p>那些操作会造成内存泄漏？</p><pre><code>  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。     垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</code></pre></li></ul><ul><li><p>Node.js的适用场景？</p></li><li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p></li><li><p>解释一下 Backbone 的 MVC 实现方式？</p></li><li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p></li><li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?<br>  <a href="http://www.infoq.com/cn/articles/webkit-for-developers/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/webkit-for-developers/</a>   fierbug</p></li><li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p></li><li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p></li><li><p>简述一下 Handlebars 的基本用法？</p></li><li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p></li><li><p>用js实现千位分隔符?(来源：<a href="http://div.io/topic/744" target="_blank" rel="noopener">前端农民工</a>，提示：正则+replace)</p><pre><code>  function commafy(num) {       num = num + &#39;&#39;;       var reg = /(-?d+)(d{3})/;      if(reg.test(num)){       num = num.replace(reg, &#39;$1,$2&#39;);      }      return num;  }</code></pre></li></ul><ul><li><p>检测浏览器版本版本有哪些方式？</p><pre><code>  功能检测、userAgent特征检测  比如：navigator.userAgent  //&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot;</code></pre></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><a name='other'>其他问题</a></h2><ul><li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？</p></li><li><p>你遇到过比较难的技术问题是？你是如何解决的？</p></li><li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p></li><li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p></li><li><p>页面重构怎么操作？</p><pre><code>  网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。  也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。  对于传统的网站来说重构通常是：  表格(table)布局改为DIV+CSS  使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)  对于移动平台的优化  针对于SEO进行优化  深层次的网站重构应该考虑的方面  减少代码间的耦合  让代码保持弹性  严格按规范编写代码  设计可扩展的API  代替旧有的框架、语言(如VB)  增强用户体验  通常来说对于速度的优化也包含在重构中  压缩JS、CSS、image等前端资源(通常是由服务器来解决)  程序的性能优化(如数据读写)  采用CDN来加速资源加载  对于JS DOM的优化  HTTP服务器的文件缓存</code></pre></li><li><p>列举IE与其他浏览器不一样的特性？</p></li></ul><pre><code>    1、事件不同之处：           触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；        获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；        阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；        停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</code></pre><ul><li><p>99%的网站都需要被重构是那本书上写的？</p><pre><code>  网站重构：应用web标准进行设计（第2版）</code></pre></li><li><p>什么叫优雅降级和渐进增强？</p><pre><code>  优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。  如：border-shadow  渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。  如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</code></pre></li><li><p>是否了解公钥加密和私钥加密。</p><pre><code>  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</code></pre></li></ul><ul><li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p><pre><code>  html5提供的Websocket  不可见的iframe  WebSocket通过Flash  XHR长时间连接  XHR Multipart Streaming  &lt;script&gt;标签的长时间连接(可跨域)</code></pre></li><li><p>对Node的优点和缺点提出了自己的看法？</p></li></ul><pre><code>    *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，      因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。      此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，      因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。    *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，      而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</code></pre><ul><li><p>你有用过哪些前端性能优化的方法？</p><pre><code>    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数    （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。    （4） 当需要设置的样式很多时设置className而不是直接操作style。    （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。    （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。    （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。    （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</code></pre></li><li><p>http状态码有那些？分别代表是什么意思？</p><pre><code>      简单版      [          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息          200  OK         正常返回信息          201  Created      请求成功并且服务器创建了新的资源          202  Accepted     服务器已接受请求，但尚未处理          301  Moved Permanently  请求的网页已永久移动到新位置。          302 Found          临时性重定向。          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。          304  Not Modified 自从上次请求后，请求的网页未修改过。          400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。          401 Unauthorized 请求未授权。          403 Forbidden      禁止访问。          404 Not Found      找不到如何与 URI 相匹配的资源。          500 Internal Server Error  最常见的服务器端错误。          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。      ]    完整版    1**(信息类)：表示接收到请求并且继续处理      100——客户必须继续发出请求      101——客户要求服务器根据请求转换HTTP协议版本    2**(响应成功)：表示动作被成功接收、理解和接受      200——表明该请求被成功地完成，所请求的资源发送回客户端      201——提示知道新文件的URL      202——接受和处理、但处理未完成      203——返回信息不确定或不完整      204——请求收到，但返回信息为空      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件      206——服务器已经完成了部分用户的GET请求    3**(重定向类)：为了完成指定的动作，必须接受进一步处理      300——请求的资源可在多处得到      301——本网页被永久性转移到另一个URL      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。      303——建议客户访问其他URL或访问方式      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用      305——请求的资源必须从服务器指定的地址得到      306——前一版本HTTP中使用的代码，现行版本中不再使用      307——申明请求的资源临时性删除    4**(客户端错误类)：请求包含错误语法或不能正确执行      400——客户端请求有语法错误，不能被服务器所理解      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用      HTTP 401.1 - 未授权：登录失败      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败      　　HTTP 401.3 - ACL 禁止访问资源      　　HTTP 401.4 - 未授权：授权被筛选器拒绝      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败      402——保留有效ChargeTo头响应      403——禁止访问，服务器收到请求，但是拒绝提供服务      HTTP 403.1 禁止访问：禁止可执行访问      　　HTTP 403.2 - 禁止访问：禁止读访问      　　HTTP 403.3 - 禁止访问：禁止写访问      　　HTTP 403.4 - 禁止访问：要求 SSL      　　HTTP 403.5 - 禁止访问：要求 SSL 128      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝      　　HTTP 403.7 - 禁止访问：要求客户证书      　　HTTP 403.8 - 禁止访问：禁止站点访问      　　HTTP 403.9 - 禁止访问：连接的用户过多      　　HTTP 403.10 - 禁止访问：配置无效      　　HTTP 403.11 - 禁止访问：密码更改      　　HTTP 403.12 - 禁止访问：映射器拒绝访问      　　HTTP 403.13 - 禁止访问：客户证书已被吊销      　　HTTP 403.15 - 禁止访问：客户访问许可过多      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL      405——用户在Request-Line字段定义的方法不允许      406——根据用户发送的Accept拖，请求资源不可访问      407——类似401，用户必须首先在代理服务器上得到授权      408——客户端没有在用户指定的饿时间内完成请求      409——对当前资源状态，请求不能完成      410——服务器上不再有此资源且无进一步的参考地址      411——服务器拒绝用户定义的Content-Length属性请求      412——一个或多个请求头字段在当前请求中错误      413——请求的资源大于服务器允许的大小      414——请求的资源URL长于服务器允许的长度      415——请求资源不支持请求项目格式      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。    5**(服务端错误类)：服务器不能正确执行一个正确的请求      HTTP 500 - 服务器遇到错误，无法完成请求      　　HTTP 500.100 - 内部服务器错误 - ASP 错误      　　HTTP 500-11 服务器关闭      　　HTTP 500-12 应用程序重新启动      　　HTTP 500-13 - 服务器太忙      　　HTTP 500-14 - 应用程序无效      　　HTTP 500-15 - 不允许请求 global.asa      　　Error 501 - 未实现    HTTP 502 - 网关错误    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</code></pre></li><li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p><pre><code>    注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，    而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、    到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；    详细版：      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;      4、进行HTTP协议会话，客户端发送报头(请求报头);      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。    简洁版：      浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；      服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；      浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；      载入解析到的资源文件，渲染页面，完成。</code></pre></li><li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p></li><li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p></li><li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p></li><li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p><pre><code>  Sublime Text 3 + 相关插件编写前端代码  Google chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能  Node.js+Gulp  git 用于版本控制和Code Review</code></pre></li><li><p>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</p><pre><code>  前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。  1、实现界面交互  2、提升用户体验  3、有了Node.js，前端可以实现服务端的一些事情</code></pre></li></ul><pre><code>    前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，    参与项目，快速高质量完成实现效果图，精确到1px；    与团队成员，UI设计，产品经理的沟通；    做好的页面结构，页面重构和用户体验；    处理hack，兼容、写出优美的代码格式；    针对服务器的优化、拥抱最新前端技术。</code></pre><ul><li><p>你怎么看待Web App 、hybrid App、Native App？</p></li><li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p></li><li><p>你对加班的看法？</p></li></ul><pre><code>       加班就像借钱，原则应当是------救急不救穷</code></pre><ul><li><p>平时如何管理你的项目？</p><pre><code>  先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；  编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；  标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；  页面进行标注（例如 页面 模块 开始和结束）；  CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；  JS 分文件夹存放 命名以该JS功能为准的英文翻译。  图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</code></pre></li><li><p>如何设计突发大规模并发架构？</p></li></ul><ul><li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p></li><li><p>说说最近最流行的一些东西吧？常去哪些网站？</p><pre><code>      ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化</code></pre></li><li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p></li></ul><ul><li><p>移动端（Android IOS）怎么做好用户体验?</p><pre><code>  清晰的视觉纵线、  信息的分组、极致的减法、  利用选择代替输入、  标签及文字的排布方式、  依靠明文确认密码、  合理的键盘利用、</code></pre></li><li><p>简单描述一下你做过的移动APP项目研发流程？</p></li><li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p></li><li><p>你认为怎样才是全端工程师（Full Stack developer）？</p></li><li><p>介绍一个你最得意的作品吧？</p></li><li><p>你有自己的技术博客吗，用了哪些技术？</p></li><li><p>对前端安全有什么看法？</p></li><li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p><p>  XSS，跨站脚本攻击<br>  CSRF(Cross Site Request Forgery)，跨站点伪造请求<br>  cookie劫持</p></li><li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p></li><li><p>最近在学什么东西？</p></li><li><p>你的优点是什么？缺点是什么？</p></li><li><p>如何管理前端团队?</p></li><li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p></li></ul><h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a><a name='web'>前端学习网站推荐</a></h2><pre><code>1. 极客标签：     http://www.gbtags.com/2. 码农周刊：     http://weekly.manong.io/issues/3. 前端周刊：     http://www.feweekly.com/issues4. 慕课网：       http://www.imooc.com/5. div.io：         http://div.io6. Hacker News： https://news.ycombinator.com/news7. InfoQ：       http://www.infoq.com/8. w3cplus：     http://www.w3cplus.com/9. Stack Overflow： http://stackoverflow.com/10.w3school：    http://www.w3school.com.cn/11.mozilla：     https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</code></pre><h2 id="文档推荐"><a href="#文档推荐" class="headerlink" title="文档推荐"></a><a name='web'>文档推荐</a></h2><ol><li><p><a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html" target="_blank" rel="noopener" title="jQuery 基本原理">jQuery 基本原理</a></p></li><li><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">JavaScript 秘密花园</a></p></li><li><p><a href="http://css.doyoe.com/" target="_blank" rel="noopener">CSS参考手册</a></p></li><li><p><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">JavaScript 标准参考教程</a></p></li><li><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6入门</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>apply 和 call</title>
      <link href="/2020/04/19/web/js/apply/"/>
      <url>/2020/04/19/web/js/apply/</url>
      
        <content type="html"><![CDATA[<p>#call()</p><pre><code>function add(a,b) {alert(a+b);}function sub(a,b) {alert(a-b);}add.call(sub,3,1);//4</code></pre><p>用 add 来替换 sub，add.call(sub,3,1) == add(3,1)</p><pre><code>var numbers = [5, 458 , 120 , -215 ];var maxInNumbers = Math.max.apply(this, numbers);console.log(maxInNumbers); // 458var maxInNumbers = Math.max.call(this,5, 458 , 120 , -215); console.log(maxInNumbers); // 458</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Node深入浅出</title>
      <link href="/2020/04/19/node/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/19/node/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>//基础<br>    // 模块引用和定义<br>        var math = require(‘math’);<br>        // math.js<br>        module.exports.add = function () {<br>            varsum = 0, i = 0,<br>                args = arguments,<br>                l = args.length; while (i &lt; l) { sum += args[i++]; }<br>            return sum;<br>        };</p><pre><code>// GYP项目生成工具// V8引擎C++库：实现js和C++互相调用// libuv库：实现跨平台的一层封装// NODE内部库// 其他库：zlib\openssl\http_parser// NPM:// npm -v// npm install express -g // npm install &lt; tarball file&gt;// npm install &lt; tarball url &gt;    // npm install &lt;folder&gt;// --registry=http://registry.url//遍历目录    fs.readdir(path.join(__dirname, &#39;..&#39;), function (err, files) {        files.forEach(function (filename, index) {            fs.readFile(filename, &#39;utf8&#39;, function (err, file) { // TODO            });        });    });</code></pre><p>//网络编辑<br>    // net、dgram、http、https分别处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端<br>        var net = require(‘net’);<br>        var server = net.createServer(function (socket) {<br>            //新的连接<br>            socket.on(‘data’, function (data) {<br>                socket.write(“你好”);<br>            });<br>            socket.on(‘end’, function () {<br>                console.log(‘连接断开’);<br>            });<br>            socket.write(“Node.js示例:\n”);<br>        });<br>        server.listen(8124, function () {<br>            console.log(‘server bound’);<br>        });<br>        //$ telnet 127.0.0.1 8124<br>        server.listen(‘/tmp/echo.sock’);<br>        //$ nc -U /tmp/echo.sock</p><pre><code>//client.js    var net = require(&#39;net&#39;);    var client = net.connect({ port: 8124 }, function () { //&#39;connect&#39; listener        console.log(&#39;client connected&#39;);        client.write(&#39;world!\r\n&#39;);    });    // var client = net.connect({ path: &#39;/tmp/echo.sock&#39; });    client.on(&#39;data&#39;, function (data) {        console.log(data.toString()); client.end();    });    client.on(&#39;end&#39;, function () {        console.log(&#39;client disconnected&#39;);    });    // $ node client.js    // client connected    // Node.js示例:    //    // 你好    // client disconnected//服务器事件    listening: server.listen(port, listeningListener)    connection: net.createServer()    close: server.close()    error//连接事件    data    end    connect    drain    error    close    timeout//管道操作    var net = require(&#39;net&#39;);    var server = net.createServer(function (socket) {        socket.write(&#39;Echo server\r\n&#39;);        socket.pipe(socket);    });    server.listen(1337, &#39;127.0.0.1&#39;);//TCP默认启用Nagle算法，合并极小数据包，累积发送，有可能延迟发送，关闭方法如下：    socket.setNoDelay(true)//UDP服务器    var dgram = require(&quot;dgram&quot;);    var server = dgram.createSocket(&quot;udp4&quot;);    server.on(&quot;message&quot;, function (msg, rinfo) {        console.log(&quot;server got: &quot; + msg + &quot; from &quot; +            rinfo.address + &quot;:&quot; + rinfo.port);    });    server.on(&quot;listening&quot;, function () {        var address = server.address();        console.log(&quot;server listening &quot; + address.address + &quot;:&quot; + address.port);    });    //将接收所有网卡上41234端口上的消息。并触发listening事件    server.bind(41234);    // $ node server.js    // server listening 0.0.0.0:41234    // server got: Node.js from 127.0.0.1:58682//UDP客户端    //client.js    var dgram = require(&#39;dgram&#39;);    var message = new Buffer(&quot;Node.js&quot;);    var client = dgram.createSocket(&quot;udp4&quot;);    client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function (err, bytes) {        client.close();    });    // socket.send(buf, offset, length, port, address, [callback])//HTTP服务器    var http = require(&#39;http&#39;);    http.createServer(function (req, res) {        //req.method: GET、POST、DELETE、PUT、CONNECT        //req.url: /        //req.httpVersion: 1.1        res.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39; });        res.end(&#39;Hello World\n&#39;);    }).listen(1337, &#39;127.0.0.1&#39;);    console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);//HTTP客户端    var options = {        hostname: &#39;127.0.0.1&#39;,        port: 1334,        path: &#39;/&#39;,        // host        // localAddress        // socketPath        // method        // headers        // auth    };    var req = http.request(options, function (res) {        console.log(&#39;STATUS: &#39; + res.statusCode);        console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));        res.setEncoding(&#39;utf8&#39;);        res.on(&#39;data&#39;, function (chunk) {            console.log(chunk);        });    });    req.end();    // $ node client.js    // STATUS: 200    // HEADERS: { &quot;date&quot;:&quot;Sat, 06 Apr 2013 11:08:01 GMT&quot;, &quot;connection&quot;:&quot;keep-alive&quot;, &quot;transfer-encoding&quot;:&quot;chunked&quot; }     // Hello World//WebSocket服务器//WebSocket客户端    var socket = new WebSocket(&#39;ws://127.0.0.1:12010/updates&#39;);    socket.onopen = function () {        setInterval(function () {            if (socket.bufferedAmount == 0)                socket.send(getUpdateData());        }, 50);    };    socket.onmessage = function (event) {        // TODO:event.data     };</code></pre><p>//网络安全<br>    // crypto 加密解密<br>    // tls 类似于net,建立在TLS加密的TCP连接上<br>    // https 与http一致</p><pre><code>//TLS服务    //证书和密钥        //生成私钥            $ openssl genrsa - out ca.key 1024        //生成csr文件            $ openssl req - new -key ca.key - out ca.csr        //通过私钥自签名生成证书            $ openssl x509 - req -in ca.csr - signkey ca.key - out ca.crt    //服务器端        var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);        var options = {            key: fs.readFileSync(&#39;./keys/server.key&#39;), cert: fs.readFileSync(&#39;./keys/server.crt&#39;), requestCert: true,            ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]        };        var server = tls.createServer(options, function (stream) {            console.log(&#39;server connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;); stream.write(&quot;welcome!\n&quot;);            stream.setEncoding(&#39;utf8&#39;);            stream.pipe(stream);        });        server.listen(8000, function () {            console.log(&#39;server bound&#39;);        });        //测试证书是否正常            $ openssl s_client - connect 127.0.0.1:8000    //客户端        // 创建私钥            $ openssl genrsa - out client.key 1024        // 生成CSR            $ openssl req - new -key client.key - out client.csr        // 生成签名证书            $ openssl x509 - req - CA ca.crt - CAkey ca.key - CAcreateserial -in client.csr - out client.crt        var fs = require(&#39;fs&#39;);        var tls = require(&#39;tls&#39;);        var options = {            key: fs.readFileSync(&#39;./keys/client.key&#39;),            cert: fs.readFileSync(&#39;./keys/client.crt&#39;),            ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]        };        var stream = tls.connect(8000, options, function () {            console.log(&#39;client connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);            process.stdin.pipe(stream);        });        stream.setEncoding(&#39;utf8&#39;);        stream.on(&#39;data&#39;, function (data) {            console.log(data);        });        stream.on(&#39;end&#39;, function () {            server.close();        });//HTTPS服务    //服务端        var https = require(&#39;https&#39;);        var fs = require(&#39;fs&#39;);        var options = {            key: fs.readFileSync(&#39;./keys/server.key&#39;),            cert: fs.readFileSync(&#39;./keys/server.crt&#39;)        };        https.createServer(options, function (req, res) {            res.writeHead(200);            res.end(&quot;hello world\n&quot;);        }).listen(8000);        // $ curl - k https://localhost:8000/         // hello world        // $ curl --cacert keys/ ca.crt https://localhost:8000/         // hello world    //客户端        var https = require(&#39;https&#39;);        var fs = require(&#39;fs&#39;); 2        var options = {            hostname: &#39;localhost&#39;,            port: 8000,            path: &#39;/&#39;,            method: &#39;GET&#39;,            key: fs.readFileSync(&#39;./keys/client.key&#39;),            cert: fs.readFileSync(&#39;./keys/client.crt&#39;),            ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]        };        options.agent = new https.Agent(options);        var req = https.request(options, function (res) {            res.setEncoding(&#39;utf-8&#39;);            res.on(&#39;data&#39;, function (d) {                console.log(d);            });        }); req.end();        req.on(&#39;error&#39;, function (e) {            console.log(e);        });        // $ node client.js        // hello world</code></pre><p>//WEB应用<br>    //请求方法<br>        function (req, res) {<br>            switch (req.method) {<br>            case ‘POST’:<br>                update(req, res);<br>                break;<br>                case ‘DELETE’:<br>                    remove(req, res);<br>                    break;<br>                case ‘PUT’:<br>                    create(req, res);<br>                    break;<br>                case ‘GET’:<br>                default:<br>                    get(req, res);<br>            }<br>        }<br>    //路径解析<br>        function (req, res) {<br>            var pathname = url.parse(req.url).pathname;<br>            fs.readFile(path.join(ROOT, pathname), function (err, file) {<br>                if (err) {<br>                    10 res.writeHead(404);<br>                    res.end(‘ 不  关文件 - -‘);<br>                    return;<br>                } res.writeHead(200);<br>                res.end(file);<br>            });<br>        }<br>    //查询字符串<br>        var url = require(‘url’);<br>        var querystring = require(‘querystring’);<br>        // var query = querystring.parse(url.parse(req.url).query);<br>        var query = url.parse(req.url, true).query;<br>        // {<br>        //     foo: ‘bar’,<br>        //     baz: ‘val’<br>        // }<br>        //如果key出现多次，值会是一个数组<br>        //{<br>        // foo: [‘bar’, ‘baz’]<br>        //}<br>    //Cookie<br>        curl - v - H “Cookie: foo=bar; baz=val” “<a href="http://127.0.0.1:1337/path?foo=bar&amp;foo=baz&quot;" target="_blank" rel="noopener">http://127.0.0.1:1337/path?foo=bar&amp;foo=baz&quot;</a><br>        var parseCookie = function (cookie) {<br>            var cookies = {};<br>            if (!cookie) {<br>                return cookies;<br>            }<br>            var list = cookie.split(‘;’);<br>            for (var i = 0; i &lt; list.length; i++) {<br>                var pair = list[i].split(‘=’);<br>                cookies[pair[0].trim()] = pair[1];<br>            }<br>            return cookies;<br>        };<br>        function (req, res) {<br>            req.cookies = parseCookie(req.headers.cookie); hande(req, res);<br>        }<br>    //Session<br>        //方法一，cookie中保存口令<br>            var sessions = {};<br>            var key = ‘session_id’;<br>            var EXPIRES = 20 * 60 * 1000;<br>            var generate = function () {<br>                var session = {};<br>                session.id = (new Date()).getTime() + Math.random(); session.cookie = {<br>                    expire: (new Date()).getTime() + EXPIRES<br>                };<br>                sessions[session.id] = session;<br>                return session;<br>            };<br>            //请求到来时检查cookie中的口令与服务器端的数据<br>            function (req, res) {<br>                var id = req.cookies[key]; if (!id) {<br>                    req.session = generate();<br>                } else {<br>                    var session = sessions[id]; if (session) {<br>                        if (session.cookie.expire &gt; (new Date()).getTime()) {<br>                            //更新超时时间<br>                            session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session;<br>                        } else {<br>                            // 超时了，删除旧的数据，并重新生成<br>                            delete sessions[id];<br>                            req.session = generate();<br>                        }<br>                    } else {<br>                        // 如果session过期或口令不对，重新生成session<br>                        req.session = generate();<br>                    }<br>                }<br>                handle(req, res);<br>            }</p><pre><code>        //重启给客户端设置新的值        var writeHead = res.writeHead;        res.writeHead = function () {            var cookies = res.getHeader(&#39;Set-Cookie&#39;);            var session = serialize(&#39;Set-Cookie&#39;, req.session.id);            cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies, session]; res.setHeader(&#39;Set-Cookie&#39;, cookies);            return writeHead.apply(this, arguments);        };        //业务操作        var handle = function (req, res) {            if (!req.session.isVisit) {                res.session.isVisit = true; res.writeHead(200); res.end(&#39;       动  &#39;);            } else {                res.writeHead(200); res.end(&#39;动       &#39;);            }        };    //方法二，通过检查查询字符串        var getURL = function (_url, key, value) {            var obj = url.parse(_url, true); obj.query[key] = value;            return url.format(obj);        };        function (req, res) {            var redirect = function (url) {                res.setHeader(&#39;Location&#39;, url); res.writeHead(302);                res.end();            };            var id = req.query[key]; if (!id) {                var session = generate();                redirect(getURL(req.url, key, session.id));            } else {                var session = sessions[id]; if (session) {                    if (session.cookie.expire &gt; (new Date()).getTime()) {                        //更新超时时间                        session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session;                        handle(req, res);                    } else {                        // 超时了，删除旧的数据，并重新生成                         delete sessions[id];                        var session = generate(); redirect(getURL(req.url, key, session.id));                    }                } else {                    // 如果session过期或口令不对，重新生成session                    var session = generate();                     redirect(getURL(req.url, key, session.id));                }            }        }//Basic认证    //URL中没带认证内容时，响应一个401未授权的状态码        function (req, res) {            var auth = req.headers[&#39;authorization&#39;] || &#39;&#39;;            var parts = auth.split(&#39; &#39;);            var method = parts[0] || &#39;&#39;; // Basic            var encoded = parts[1] || &#39;&#39;; // dXNlcjpwYXNz            var decoded = new Buffer(encoded, &#39;base64&#39;).toString(&#39;utf-8&#39;).split(&quot;:&quot;);            var user = decoded[0]; // user            var pass = decoded[1]; // pass            if (!checkUser(user, pass)) {                res.setHeader(&#39;WWW-Authenticate&#39;, &#39;Basic realm=&quot;Secure Area&quot;&#39;);                res.writeHead(401);                res.end();            } else {                handle(req, res);            }        }//数据上传        // 判断报头是否带有内容        var hasBody = function (req) {            return &#39;transfer-encoding&#39; in req.headers || &#39;content-length&#39; in req.headers;        };        //处理data        function (req, res) {            if (hasBody(req)) {                var buffers = [];                req.on(&#39;data&#39;, function (chunk) {                    buffers.push(chunk);                });                req.on(&#39;end&#39;, function () {                    req.rawBody = Buffer.concat(buffers).toString();                    handle(req, res);                }); 8            } else {                handle(req, res);            }        }        //表单        &lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;            &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt; &lt;br /&gt;            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;        &lt;/form&gt;        var handle = function (req, res) {            if (req.headers[&#39;content-type&#39;] === &#39;application/x-www-form-urlencoded&#39;) {                req.body = querystring.parse(req.rawBody);            }            todo(req, res);        };        //判断编码信息        var mime = function (req) {            var str = req.headers[&#39;content-type&#39;] || &#39;&#39;; return str.split(&#39;;&#39;)[0];        };        var handle = function (req, res) {            if (mime(req) === &#39;application/json&#39;) {                try {                    req.body = JSON.parse(req.rawBody);                } catch (e) {                    // 异常内容 响应Bad request                     res.writeHead(400);                    res.end(&#39;Invalid JSON&#39;);                    return;                }            }            todo(req, res);        };        var xml2js = require(&#39;xml2js&#39;);        var handle = function (req, res) {            if (mime(req) === &#39;application/xml&#39;) {                xml2js.parseString(req.rawBody, function (err, xml) {                    if (err) {                        // 异常内容 响应Bad request                         res.writeHead(400);                        res.end(&#39;Invalid XML&#39;);                        return;                    }                    req.body = xml; todo(req, res);                });            }        };        //文件上传        function (req, res) {            if (hasBody(req)) {                var done = function () {                    handle(req, res);                };                if (mime(req) === &#39;application/json&#39;) {                    parseJSON(req, done);                } else if (mime(req) === &#39;application/xml&#39;) {                    parseXML(req, done);                } else if (mime(req) === &#39;multipart/form-data&#39;) {                    parseMultipart(req, done);                }            } else {                handle(req, res);            }        }        //基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径        var formidable = require(&#39;formidable&#39;);        function (req, res) {            if (hasBody(req)) {                if (mime(req) === &#39;multipart/form-data&#39;) {                    var form = new formidable.IncomingForm();                    form.parse(req, function (err, fields, files) {                        req.body = fields;                        req.files = files;                        handle(req, res);                    });                }            } else {                handle(req, res);            }        }        //CSRF安全        var generateRandom = function (len) {            return crypto.randomBytes(Math.ceil(len * 3 / 4))                .toString(&#39;base64&#39;)                .slice(0, len);        };        var token = req.session._csrf || (req.session._csrf = generateRandom(24));        &lt;form id=&quot;test&quot; method=&quot;POST&quot; action=&quot;http://domain_a.com/guestbook&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;content&quot; value=&quot;vim是    上  的编辑器&quot; /&gt;            &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;&lt;%=_csrf%&gt;&quot; /&gt;        &lt;/form&gt;        function (req, res) {            var token = req.session._csrf || (req.session._csrf = generateRandom(24));            var _csrf = req.body._csrf; if (token !== _csrf) {                res.writeHead(403);                res.end(&quot;禁止访问&quot;);            } else {                handle(req, res);            }        }//路由        var match = function (pathname, routes) {            for (var i = 0; i &lt; routes.length; i++) {                var route = routes[i];                // 正则 配                var reg = route[0].regexp;                var keys = route[0].keys;                var matched = reg.exec(pathname); if (matched) {                    //   具体                     var params = {}; for (vari = 0, l = keys.length; i &lt; l; i++) {                        var value = matched[i + 1]; if (value) {                            params[keys[i]] = value;                        }                    }                    req.params = params;                    var action = route[1]; action(req, res); return true;                }            }            return false;        };        var routes = { &#39;all&#39;: [] };        var app = {};        app.use = function (path, action) {            routes.all.push([pathRegexp(path), action]);        };        [&#39;get&#39;, &#39;put&#39;, &#39;delete&#39;, &#39;post&#39;].forEach(function (method) {        routes[method] = [];            app[method] = function (path, action) {                routes[method].push([pathRegexp(path), action]);            };        });        app.post(&#39;/user/:username&#39;, addUser);        app.delete(&#39;/user/:username&#39;, removeUser);        app.put(&#39;/user/:username&#39;, updateUser);        app.get(&#39;/user/:username&#39;, getUser);//中间件        var middleware = function (req, res, next) {            // TODO            next();        }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2020/04/19/tool/git/"/>
      <url>/2020/04/19/tool/git/</url>
      
        <content type="html"><![CDATA[<p>#<a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">http://www.bootcss.com/p/git-guide/</a></p><p>#<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><pre><code>git --version</code></pre><p>#——————————————————————————————————</p><h1 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h1><pre><code>git config --global user.name &quot;Jiang Xin&quot;git config --global user.email jiangxin@ossxp.com</code></pre><p>#——————————————————————————————————</p><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><pre><code>git config --global alias.ci commit</code></pre><p>#——————————————————————————————————</p><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><pre><code>git config --global color.ui true</code></pre><p>#——————————————————————————————————</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><pre><code>git init demo# 自动创建demo目录并初始化一个空的版本库.git</code></pre><p>#——————————————————————————————————</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>git rev-parse --git-dir#   可在子目录中执行，向上查找.git目录#   /path/demo/.gitgit rev-parse --show-toplevel#   可在子目录中执行，显示工作区根目录#   /path/demogit rev-parse --show-prefix#   显示当前路径相对于工作区根目录的目录#   a/b/c/git rev-parse --show-cdup#   显示当前目录cd到工作区根目录的深度#   ../../.../</code></pre><p>#——————————————————————————————————</p><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><pre><code>cd demoecho &quot;Hello World.&quot; &gt; welcome.txtgit add welcome.txt# 已在版本库中的文件修改后同样要git add后才能提交</code></pre><p>#——————————————————————————————————</p><h1 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h1><pre><code>git ci -m &quot;init&quot;--allow-empty#   允许空白提交</code></pre><p>#——————————————————————————————————</p><h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><pre><code>git clone git://git.kernel.org/pub/scm/git/git.gitcd /pathgit clone demo demo-bak-1#   备份本地git库</code></pre><p>#——————————————————————————————————</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><pre><code>git log --stat</code></pre><p>#——————————————————————————————————</p><h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><pre><code>git statusgit status -s#   精简格式# M位于第一列表示，版本库与暂存区文件有改动#   文件修改并 git add 之后# M位于第二列表示，工作区当前文件与暂存区文件有改动#   文件修改，在git add之前# 第一二列均有M，表示git add后又修改了文件</code></pre><p>#——————————————————————————————————</p><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><pre><code>echo &quot;Nice too meet you.&quot; &gt;&gt; welcome.txtgit diff#   仅显示工作区最新改动，即工作区与暂存区相比git diff HEAD#   将工作区和HEAD（当前工作分支）相比git diff --cached#   将暂存区和版本库相比</code></pre><p>#——————————————————————————————————</p><h1 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h1><pre><code>git remote –v#   查看版本库的网址git remote#   列出所有主机名</code></pre><p>#——————————————————————————————————</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><pre><code>git fetch origin master#   将远程版本库的更新，更新到本地库。</code></pre><p>#——————————————————————————————————</p><h1 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h1><pre><code>git remote add origin git@192.168.56.1:git-test.git#   添加远程仓库地址git push origin master#   将本地master分支推送到origin主机的master分支上</code></pre><p>#——————————————————————————————————</p><h1 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h1><pre><code>git pull origin master:master#   将远程主机origin中的master分支跟新到本地分支master</code></pre><p>#——————————————————————————————————</p><h1 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h1><pre><code>git reset --soft HEAD^git reset HEAD a/b/c#   将已经add到暂存队列中的文件取消暂存，然后通过checkout可以还原文件</code></pre><p>#——————————————————————————————————</p><h1 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h1><pre><code>git checkout &lt;paths&gt;git checkout [&lt;branch&gt;]#   检出分支git checkout -- filename#   用暂存区中的文件来覆盖工作区的文件#   恢复到最后一次提交的改动</code></pre><p>#——————————————————————————————————</p><h1 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h1><pre><code>git stach list#   查看保存的进度git stash pop#   恢复最近进度</code></pre><p>#——————————————————————————————————</p><h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><pre><code>merge</code></pre><p>#——————————————————————————————————</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><pre><code>git branch#   显示当前分支git branch new-branch#   创建分支git checkout new-branch#   切换到新分支#   -b 可以在创建分支后自动切换到新分支git push origin new-branch#   合并到远程服务器git checkout master#   合并进mastergit merge new-branch#   合并进mastergit push#   合并进master#   master中也合并了new-branch中的更新git cherry-pick#   从历史提交中拣选到特性分支</code></pre><p>#——————————————————————————————————</p><h1 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h1><pre><code>git tag -m &quot;Release 1.0&quot; v1.0#   创建里程碑git push origin refs/tags/v1.0</code></pre><p>#——————————————————————————————————</p><h1 id="客户端工具"><a href="#客户端工具" class="headerlink" title="客户端工具"></a>客户端工具</h1><p>  windows<br>    TortoiseGit<br>  mac os x<br>    SourceTree</p><p>#——————————————————————————————————</p><h1 id="生成SSH公私匙"><a href="#生成SSH公私匙" class="headerlink" title="生成SSH公私匙"></a>生成SSH公私匙</h1><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>  ssh-keygen -t rsa<br>    Generating public/private rsa key pair.<br>    Enter file in which to save the key (/home/git/.ssh/id_rsa):<br>    Created directory ‘/home/git/.ssh’.<br>    Enter passphrase (empty for no passphrase):<br>    Enter same passphrase again:<br>    Your identification has been saved in /home/git/.ssh/id_rsa.<br>    Your public key has been saved in /home/git/.ssh/id_rsa.pub.<br>    The key fingerprint is:<br>    2e:38:0f:26:72:8e:3b:1f:1e:7a:74:40:1e:b9:d2:2d <a href="mailto:git@minion-test-76.ewin.com">git@minion-test-76.ewin.com</a><br>    The keys randomart image is:</p><p>   将公钥 ~/.ssh/id_rsa.pub 传给GIT管理员或将内容复制到GITLIB账号中。</p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>  安装TortoiseGit<br>  使用puttygen.exe生成公钥和ppk<br>  将公钥文件传给GIT管理员或将内容复制到GITLIB账号中。<br>  将私匙保存在本地，添加到TortoiseGit设置中的远程账号中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Immutable</title>
      <link href="/2020/04/19/tool/immutable/"/>
      <url>/2020/04/19/tool/immutable/</url>
      
        <content type="html"><![CDATA[<p>//<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">https://facebook.github.io/immutable-js/</a><br>//Immutable 是一个可实现持久数据结构的 JavaScript 库。它性能很好，并且命名符合 JavaScript API 的语言习惯<br>//Immutable 中的 Map 和 List 对应原生 Object 和 Array<br>//npm install immutable</p><p>import { Map, List, Seq, fromJS, is } from ‘immutable’;</p><p>/*———————————————————————————————————— */<br>//设置和取值<br>    var map1 = Map({ a: 1, b: 2, c: 3 });<br>    var map2 = map1.set(‘b’, 50);<br>    map1.get(‘b’); // 2<br>    map2.get(‘b’); // 50</p><pre><code>foo = fromJS({ a: { b: 1 } });bar = foo.setIn([&#39;a&#39;, &#39;b&#39;], 2); // 使用 setIn 赋值console.log(foo.getIn([&#39;a&#39;, &#39;b&#39;])); // 使用 getIn 取值，打印 1console.log(foo === bar); //  打印 falselet a = Map({    select: &#39;users&#39;,    filter: Map({ name: &#39;Cam&#39; })})let b = a.set(&#39;select&#39;, &#39;people&#39;);a === b; // falsea.get(&#39;filter&#39;) === b.get(&#39;filter&#39;); // true</code></pre><p>/*———————————————————————————————————— */<br>//key value 处理<br>    var alpha = Map({ a: 1, b: 2, c: 3, d: 4 });<br>    alpha.map((v, k) =&gt; k.toUpperCase()).join();<br>    // ‘A,B,C,D’</p><p>/*———————————————————————————————————— */<br>//合并<br>    var map1 = Map({ a: 1, b: 2, c: 3, d: 4 });<br>    var map2 = Map({ c: 10, a: 20, t: 30 });<br>    var obj = { d: 100, o: 200, g: 300 };<br>    var map3 = map1.merge(map2, obj);<br>    // Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }</p><pre><code>var myObject = { a: 1, b: 2, c: 3 };Seq(myObject).map(x =&gt; x * x).toObject();// { a: 1, b: 4, c: 9 }</code></pre><p>/*———————————————————————————————————— */<br>//和对象获取K值的区别，key会将num转为str<br>    var obj = { 1: “one” };<br>    Object.keys(obj); // [ “1” ]<br>    obj[“1”]; // “one”<br>    obj[1]; // “one”</p><pre><code>var map = fromJS(obj); //对象转MAPmap.get(&quot;1&quot;); // &quot;one&quot;map.get(1); // undefined</code></pre><p>/*———————————————————————————————————— */<br>//转换<br>    var deep = Map({ a: 1, b: 2, c: List.of(3, 4, 5) });<br>    deep.toObject() // { a: 1, b: 2, c: List [ 3, 4, 5 ] }<br>    deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]<br>    deep.toJS() // { a: 1, b: 2, c: [ 3, 4, 5 ] }<br>    JSON.stringify(deep) // ‘{“a”:1,”b”:2,”c”:[3,4,5]}’</p><p>/*———————————————————————————————————— */<br>//嵌套结构<br>    // mergeDeep, getIn, setIn, and updateIn<br>    var nested = fromJS({ a: { b: { c: [3, 4, 5] } } });<br>    // Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }<br>    var nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });<br>    // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }<br>    nested2.getIn([‘a’, ‘b’, ‘d’]); // 6<br>    var nested3 = nested2.updateIn([‘a’, ‘b’, ‘d’], value =&gt; value + 1);<br>    // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }<br>    var nested4 = nested3.updateIn([‘a’, ‘b’, ‘c’], list =&gt; list.push(6));<br>    // Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }</p><p>/*———————————————————————————————————— */<br>//比较对象的值<br>    var map1 = Map({ a: 1, b: 1, c: 1 });<br>    var map2 = Map({ a: 1, b: 1, c: 1 });<br>    assert(map1 !== map2); // two different instances<br>    assert(is(map1, map2)); // have equivalent values<br>    assert(map1.equals(map2)); // alternatively use the equals method</p><p>/*———————————————————————————————————— */<br>//判断数据是否变化<br>    // import { is } from ‘immutable’;</p><pre><code>shouldComponentUpdate(nextProps = {}, nextState = {}) {    const thisProps = this.props || {},        thisState = this.state || {};    if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||        Object.keys(thisState).length !== Object.keys(nextState).length) {        return true;    }    for (const key in nextProps) {        if (thisProps[key] !== nextProps[key] || !is(thisProps[key], nextProps[key])) {            return true;        }    }    for (const key in nextState) {        if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {            return true;        }    }    return false;};</code></pre><p>/*———————————————————————————————————— */<br>//列表对象<br>    var list1 = List.of(1, 2); //list1.get(0)取得1<br>    var list2 = list1.push(3, 4, 5);<br>    var list3 = list2.unshift(0);<br>    var list4 = list1.concat(list2, list3);</p><pre><code>var list1 = List.of(1, 2, 3);var list2 = list1.withMutations(function(list) {    list.push(4).push(5).push(6);});assert(list1.size === 3);assert(list2.size === 6);</code></pre><p>/*———————————————————————————————————— */<br>//Cursor游标，访问深层对象<br>    import Cursor from ‘immutable/contrib/cursor’;</p><pre><code>let data = fromJS({ a: { b: { c: 1 } } });// 让 cursor 指向 { c: 1 }let cursor = Cursor.from(data, [&#39;a&#39;, &#39;b&#39;], newData =&gt; {    // 当 cursor 或其子 cursor 执行 update 时调用    console.log(newData);});cursor.get(&#39;c&#39;); // 1cursor = cursor.update(&#39;c&#39;, x =&gt; x + 1);cursor.get(&#39;c&#39;); // 2</code></pre><p>/*———————————————————————————————————— */<br>//fromJS转成MAP，toJS转成对象<br>    const Apple = (state = initstate, action) =&gt; {<br>        switch (action.type) {<br>            case “EAT_APPLE”:<br>                //这里只对state中的apples数组对象中单个成员action.id的isEaten属性修改成true<br>                return fromJS(state).setIn([‘apples’, action.id, ‘isEaten’], true).toJS();<br>        }<br>    }</p><p>/*———————————————————————————————————— */<br>//Map对象方法 updateIn()    set()   setIn()<br>    nextState = state.updateIn([action.from.id, ‘props’, ‘children’], c =&gt; c.splice(action.from.index, 1));<br>    nextState = nextState.updateIn([action.to.id, ‘props’, ‘children’], c =&gt; c.splice(action.to.index, 0, action.item));</p><pre><code>nextState = state.setIn([action.id, &#39;props&#39;, key], value);nextState = state.set(action.item.id, action.item).updateIn([action.id, &#39;props&#39;, &#39;children&#39;], c =&gt; c.splice(action.index, 0, action.item.id));nextState = state.updateIn([action.parentId, &#39;props&#39;, &#39;children&#39;], c =&gt; c.splice(action.index, 1));</code></pre><p>/*———————————————————————————————————— */<br>//深度删除<br>    // @flow</p><pre><code>const deepRemove = (state: any, id: string): any =&gt; {    const children = state.getIn([id, &#39;props&#39;, &#39;children&#39;]);    if (children) {        children.forEach(c =&gt; {            state = deepRemove(state, c);        });    }    return state.delete(id);};</code></pre><p>/*———————————————————————————————————— */<br>//state的用法<br>    getInitialState() {<br>            return {<br>                data: Map({ times: 0 })<br>            }<br>        },<br>        handleAdd() {<br>            this.setState(({ data }) =&gt; ({<br>                    data: data.update(‘times’, v =&gt; v + 1)<br>                })<br>            });<br>    }</p><p>/*———————————————————————————————————— */<br>//实现一个类似带有添加和撤销功能的 Store<br>    import { Map, OrderedMap } from ‘immutable’;</p><pre><code>let todos = OrderedMap();let history = []; // 普通数组，存放每次操作后产生的数据let TodoStore = createStore({    getAll() { return todos; }});Dispatcher.register(action =&gt; {    if (action.actionType === &#39;create&#39;) {        let id = createGUID();        history.push(todos); // 记录当前操作前的数据，便于撤销        todos = todos.set(id, Map({            id: id,            complete: false,            text: action.text.trim()        }));        TodoStore.emitChange();    } else if (action.actionType === &#39;undo&#39;) {        // 这里是撤销功能实现，        // 只需从 history 数组中取前一次 todos 即可        if (history.length &gt; 0) {            todos = history.pop();        }        TodoStore.emitChange();    }});</code></pre><p>/*———————————————————————————————————— */<br>//与 Redux 搭配使用<br>    //由于 Redux 中内置的 <code>combineReducers</code> 和 reducer 中的 <code>initialState</code> 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。<br>    //幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 <code>combineReducers</code> 或使用 redux-immutablejs 来提供支持。</p><p>/*———————————————————————————————————— */<br>//优化写法，使用Record对象，可以省去fromJS()和toJS()进行数据转换，直接使用setIn updateIn等方法</p><p>import { Record } from ‘immutable’;</p><p>const recode=  Record({<br>    a:1,<br>    b:2,<br>    c:[1,2,3]<br>})</p><p>const initstate= {<br>    recode: new recode(),<br>}</p><p>initstate.recode.updateIn([‘a’],100)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MockJs</title>
      <link href="/2020/04/19/tool/mock/"/>
      <url>/2020/04/19/tool/mock/</url>
      
        <content type="html"><![CDATA[<p>// <a href="http://mockjs.com" target="_blank" rel="noopener">http://mockjs.com</a></p><p>/<strong>———————————————————————————– */<br>// String<br>    ‘name|min-max’: string<br>        “string|1-10”: “★”//随机1－10个星<br>        “string|3”: “★★★” //3个3星，即9星<br>/</strong>———————————————————————————– <em>/<br>// Number<br>    ‘name|+1’: number<br>        “number|+1”: 202 //数字递增<br>    ‘name|min-max’: number<br>        “number|1-100”: 100 //1-100内随机<br>    ‘name|min-max.dmin-dmax’: number<br>        “number|1-100.1-10”: 1 //整数位1-100内随机，小数位数随机1-10位<br>        “number|123.1-10”: 1 //整数位固定123，小数位数随机1-10位<br>        “number|123.3”: 1  //整数位固定123，小数位数随机3位<br>        “number|123.10”: 1.123 //固定123.123，小数位后7位数随机<br>/*</em>———————————————————————————– <em>/<br>// Boolean<br>    ‘name|1’: boolean<br>        “boolean|1”: true //随机true或false<br>/*</em>———————————————————————————– <em>/<br>// Object<br>    ‘name|count’: object<br>        “object|2”: {       //随机2项<br>            “310000”: “上海市”,<br>            “320000”: “江苏省”,<br>            “330000”: “浙江省”,<br>            “340000”: “安徽省”<br>        }<br>        “object|2-4”: {       //随机2-4项<br>            “110000”: “北京市”,<br>            “120000”: “天津市”,<br>            “130000”: “河北省”,<br>            “140000”: “山西省”<br>        }<br>/*</em>———————————————————————————– <em>/<br>// Array<br>    ‘name|1’: array<br>        “array|1”: [ //随机获取一个成员<br>            “AMD”,<br>            “CMD”,<br>            “UMD”<br>        ]<br>        “array|+1”: [ //按次序轮流获取一个成员<br>            “AMD”,<br>            “CMD”,<br>            “UMD”<br>        ]<br>        “array|1-10”: [<br>            {<br>                “name|+1”: [<br>                    “Hello”,·<br>                    “Mock.js”,<br>                    “!”<br>                ]<br>            }<br>        ]<br>    ‘name|min-max’: array  //随机复制次数数组成员，仍返回数组<br>            “array|1-10”: [<br>                “Mock.js”<br>            ]<br>            “array|1-10”: [<br>                “Hello”,<br>                “Mock.js”,<br>                “!”<br>            ]<br>    ‘name|count’: array //复制指定次数数组成员，仍返回数组<br>        “array|3”: [<br>            “Mock.js”<br>        ]<br>        “array|3”: [<br>            “Hello”,<br>            “Mock.js”,<br>            “!”<br>        ]<br>/*</em>———————————————————————————– <em>/<br>// Function<br>/*</em>———————————————————————————– */<br>// RegExp<br>    ‘regexp’: /[a-z][A-Z][0-9]/  //匹配一个小写一个大写一个数字，”rL7”<br>    ‘regexp’: /\w\W\s\S\d\D/    //“L;\ne0y”<br>    ‘regexp’: /\d{5,10}/        //5-10位整数，”1397379”<br>    ‘regexp|3’: /\d{5,10}-/    //“517305176-531837-967646851-07321438-“<br>    ‘regexp|1-5’: /\d{5,10}-/  //“197685-57124-“</p><p>/**———————————————————————————– */<br>// Path<br>    //数据占位符定义</p><pre><code>    Basic        boolean            &#39;@boolean()&#39; //随机true或false        natural            &#39;@natural()&#39;    //随机自然数，4010302377033728            &#39;@natural(10000)&#39; //随机自然数，最小10000            &#39;@natural(60, 100)&#39; //随机60-100        integer            &#39;@integer()&#39;    //随机正负整数            &#39;@integer(10000)&#39;            &#39;@integer(60, 100)&#39;        float            &#39;@float()&#39;          //随机浮点数            &#39;@float(0)&#39;         //排除负数            &#39;@float(60, 100)&#39;   //指定范围            &#39;@float(60, 100, 3)&#39;    //小数位最小3位            &#39;@float(60, 100, 3, 5)&#39; //小数位随机3-5位        character            &#39;@character()&#39;  //随机单个字符，大小写字母及符号            &#39;@character(&quot;lower&quot;)&#39;   //随机单个小写字母            &#39;@character(&quot;upper&quot;)&#39;   //随机单个大写字母            &#39;@character(&quot;number&quot;)&#39;  //随机单个数字            &#39;@character(&quot;symbol&quot;)&#39;  //随机单个符号            &#39;@character(&quot;aeiou&quot;)&#39;   //随机指定范围内的单个字符        string            &#39;@string()&#39;            &#39;@string(5)&#39;            &#39;@string(7, 10)&#39;            &#39;@string(&quot;lower&quot;, 5)&#39;            &#39;@string(&quot;upper&quot;, 5)&#39;            &#39;@string(&quot;number&quot;, 5)&#39;            &#39;@string(&quot;symbol&quot;, 5)&#39;            &#39;@string(&quot;aeiou&quot;, 1, 3)&#39;        range            &#39;@range(10)&#39;        //[0,1,2,3,4,5,6,7,8,9]            &#39;@range(3, 7)&#39;      //[3,4,5,6]            &#39;@range(1, 10, 2)&#39;  //[1,3,5,7,9]    Date        date            &#39;@date()&#39;               //&quot;2010-02-10&quot;            &#39;@date(&quot;yyyy-MM-dd&quot;)&#39;   //&quot;2014-11-30&quot;            &#39;@date(&quot;yy-MM-dd&quot;)&#39;     //&quot;98-02-03&quot;            &#39;@date(&quot;y-MM-dd&quot;)&#39;      //&quot;78-09-02&quot;            &#39;@date(&quot;y-M-d&quot;)&#39;        //&quot;94-4-21&quot;            &#39;@date(&quot;yyyy yy y MM M dd d&quot;)&#39;  //&quot;1990 90 90 05 5 22 22&quot;        time        datetime        now        Image        image        dataImage        Color        color        hex        rgb        rgba        hsl    Text        paragraph        sentence        word        title        cparagraph        csentence        cword        ctitle        Name        first        last        name        cfirst        clast        cname        Web        url        domain        protocol        tld        email        ip        Address        region        province        city        county        zip        Helper        capitalize        upper        lower        pick        shuffle        Miscellaneous        guid        id        increment</code></pre><p>/<strong>———————————————————————————– */<br>/</strong></p><ul><li>示例</li><li>/<br>var example_json = {<br>  “successed”: true,<br>  “status”: 200,<br>  “data”: {<pre><code>  &quot;page&quot;: 0,   &quot;pageSize&quot;: 20,   &quot;total&quot;: 120,   &quot;list|20&quot;: [      {          &quot;userID|+1&quot;: 29583,           &quot;name|1&quot;: &quot;@cfirst@clast&quot;,           &quot;mobile|1&quot;: &quot;13@integer(100000000,999999999)&quot;,           &quot;departementName|1&quot;: &quot;@ctitle(2,4)部&quot;,           &quot;positionName|1&quot;: &quot;@csentence(4)&quot;,           &quot;email|1&quot;: &quot;@email()&quot;,           &quot;manageScope|1-2&quot;: [              &quot;南昌&quot;          ],           &quot;createTime&quot;: &quot;@date(\&quot;yyyy-MM-dd\&quot;) @time(\&quot;HH:mm:ss\&quot;)&quot;,           &quot;sex|1&quot;: [              -1,               1          ],           &quot;address&quot;: &quot;@county(true)&quot;,           &quot;cardId&quot;: &quot;@id()&quot;,           &quot;originPlace&quot;: &quot;@city()&quot;,           &quot;married|1&quot;: [              0,               1,               2          ],           &quot;nation|1&quot;: [              0,               1          ],           &quot;isManager|1&quot;: false,           &quot;cardNo&quot;: &quot;10001&quot;      }  ]</code></pre>  },<br>  “query”: {<pre><code>  &quot;pageSize&quot;: &quot;15&quot;,   &quot;page&quot;: &quot;1&quot;,   &quot;keys&quot;: &quot;&quot;,   &quot;deptId&quot;: &quot;1&quot;,   &quot;corNode&quot;: &quot;1&quot;</code></pre>  }<br>}</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题</title>
      <link href="/2020/04/19/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/04/19/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML，-HTTP，web综合问题"><a href="#HTML，-HTTP，web综合问题" class="headerlink" title="HTML， HTTP，web综合问题"></a>HTML， HTTP，web综合问题</h1><p>1、前端需要注意哪些SEO<br>2、<img>的title和alt有什么区别<br>3、HTTP的几种请求方法用途<br>4、从浏览器地址栏输入url到显示页面的步骤<br>5、如何进行网站性能优化<br>6、HTTP状态码及其含义<br>7、语义化的理解<br>8、介绍一下你对浏览器内核的理解<br>9、html5有哪些新特性、移除了那些元素？<br>10、HTML5的离线储存怎么使用，工作原理能不能解释一下？<br>11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢<br>12、请描述一下 cookies，sessionStorage 和 localStorage 的区别<br>13、iframe有那些缺点？<br>14、WEB标准以及W3C标准是什么?<br>15、xhtml和html有什么区别?<br>16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?<br>17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？<br>18、HTML全局属性(global attribute)有哪些<br>19、Canvas和SVG有什么区别？<br>20、HTML5 为什么只需要写 <!DOCTYPE HTML>？<br>21、如何在页面上实现一个圆形的可点击区域？<br>22、网页验证码是干嘛的，是为了解决什么安全问题</p><h1 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h1><p>1、css sprite是什么,有什么优缺点<br>2、display: none;与visibility: hidden;的区别<br>3、link与@import的区别<br>4、什么是FOUC?如何避免<br>5、如何创建块级格式化上下文(block formatting context),BFC有什么用<br>7、清除浮动的几种方式，各自的优缺点<br>8、为什么要初始化CSS样式?<br>9、css3有哪些新特性<br>10、display有哪些值？说明他们的作用<br>11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？<br>12、CSS优先级算法如何计算？<br>13、对BFC规范的理解？<br>14、谈谈浮动和清除浮动<br>15、position的值， relative和absolute`定位原点是<br>16、display:inline-block 什么时候不会显示间隙？(携程)<br>17、PNG,GIF,JPG的区别及如何选<br>18、行内元素float:left后是否变为块级元素？<br>19、在网页中的应该使用奇数还是偶数的字体？为什么呢？<br>20、::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用<br>21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）<br>22、CSS合并方法<br>23、CSS不同选择器的权重(CSS层叠的规则)<br>24、列出你所知道可以改变页面布局的属性<br>25、CSS在性能优化方面的实践<br>26、CSS3动画（简单动画的实现，如旋转等）<br>27、base64的原理及优缺点</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>1、闭包<br>2、说说你对作用域链的理解<br>3、JavaScript原型，原型链 ? 有什么特点？<br>4、请解释什么是事件代理<br>5、Javascript如何实现继承？<br>6、谈谈This对象的理解<br>7、事件模型<br>8、new操作符具体干了什么呢?<br>9、Ajax原理<br>11、模块化开发怎么做？<br>12、异步加载JS的方式有哪些？<br>13、那些操作会造成内存泄漏？<br>14、XML和JSON的区别？<br>15、谈谈你对webpack的看法<br>17、常见web安全及防护原理<br>18、用过哪些设计模式？<br>19、为什么要有同源限制？<br>20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别<br>21、javascript有哪些方法定义对象<br>22、常见兼容性问题？<br>22、说说你对promise的了解<br>23、你觉得jQuery源码有哪些写的好的地方<br>25、Node的应用场景<br>26、谈谈你对AMD、CMD的理解<br>27、那些操作会造成内存泄漏？<br>28、web开发中会话跟踪的方法有哪些<br>29、介绍js的基本数据类型<br>30、介绍js有哪些内置对象？<br>31、说几条写JavaScript的基本规范？<br>32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？<br>33、javascript创建对象的几种方式？<br>34、eval是做什么的？<br>35、null，undefined 的区别？<br>36、[“1”, “2”, “3”].map(parseInt) 答案是多少？<br>37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？<br>38、JSON的了解？<br>39、js延迟加载的方式有哪些？<br>40、同步和异步的区别?<br>41、渐进增强和优雅降级<br>42、defer和async<br>43、说说严格模式的限制<br>44、attribute和property的区别是什么？<br>45、谈谈你对ES6的理解<br>46、ECMAScript6 怎么写class么，为什么会出现class这种东西?<br>47、什么是面向对象编程及面向过程编程，它们的异同和优缺点<br>48、从你自己的理解来看，你是如何理解面向对象编程的，它解决了什么问题，有什么作用<br>49、对web标准、可用性、可访问性的理解</p><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>1、写一个通用的事件侦听器函数<br>2、如何判断一个对象是否为数组<br>3、冒泡排序<br>4、快速排序<br>5、编写一个方法 求一个字符串的字节长度</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1、谈谈你对重构的理解<br>2、什么样的前端代码是好的<br>3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？<br>4、你觉得前端工程的价值体现在哪<br>5、平时如何管理你的项目？</p><h1 id="人事面"><a href="#人事面" class="headerlink" title="人事面"></a>人事面</h1><p>面试完你还有什么问题要问的吗<br>你有什么爱好?<br>你最大的优点和缺点是什么?<br>你为什么会选择这个行业，职位?<br>你觉得你适合从事这个岗位吗?<br>你有什么职业规划?<br>你对工资有什么要求?<br>如何看待前端开发？<br>未来三到五年的规划是怎样的？<br>常问</p><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？<br>你认为哪个项目做得最好？<br>最近在看哪些前端方面的书？<br>平时是如何学习前端开发的？<br>你最有成就感的一件事<br>你是怎么学习前端的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Normalize</title>
      <link href="/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/normalize/"/>
      <url>/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/normalize/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是Normalize-css"><a href="#一、什么是Normalize-css" class="headerlink" title="一、什么是Normalize.css"></a>一、什么是Normalize.css</h1><p>Normalize.css是一种CSS reset的替代方案。它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案</p><p><a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize Github</a><br><a href="http://nicolasgallagher.com/about-normalize-css/" target="_blank" rel="noopener">Normalize 官网</a><br><a href="https://jerryzou.com/posts/aboutNormalizeCss/" target="_blank" rel="noopener">本文出处</a></p><h1 id="二、Normalize-优点"><a href="#二、Normalize-优点" class="headerlink" title="二、Normalize 优点"></a>二、Normalize 优点</h1><h2 id="1-Normalize-css-保护了有价值的默认值"><a href="#1-Normalize-css-保护了有价值的默认值" class="headerlink" title="1. Normalize.css 保护了有价值的默认值"></a>1. Normalize.css 保护了有价值的默认值</h2><p>Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并尽可能与现代标准相符合。</p><h2 id="2-Normalize-css-修复了浏览器的bug"><a href="#2-Normalize-css-修复了浏览器的bug" class="headerlink" title="2. Normalize.css 修复了浏览器的bug"></a>2. Normalize.css 修复了浏览器的bug</h2><p>它修复了常见的桌面端和移动端浏览器的bug。这往往超出了Reset所能做到的范畴。关于这一点，Normalize.css修复的问题包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 </p><p>##3、Normalize.css 不会让你的调试工具变的杂乱<br>使用Reset最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在Normalize.css中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。 </p><h2 id="4、Normalize-css-是模块化的"><a href="#4、Normalize-css-是模块化的" class="headerlink" title="4、Normalize.css 是模块化的"></a>4、Normalize.css 是模块化的</h2><p>这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。</p><h2 id="5-Normalize-css-拥有详细的文档"><a href="#5-Normalize-css-拥有详细的文档" class="headerlink" title="5. Normalize.css 拥有详细的文档"></a>5. Normalize.css 拥有详细的文档</h2><p>Normalize.css的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在<a href="https://github.com/necolas/normalize.css/wiki" target="_blank" rel="noopener">Github Wiki</a>中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。</p><h1 id="三、如何使用Normalize"><a href="#三、如何使用Normalize" class="headerlink" title="三、如何使用Normalize"></a>三、如何使用Normalize</h1><p>安装或从Github下载<a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a>。</p><h2 id="使用方法一"><a href="#使用方法一" class="headerlink" title="使用方法一"></a>使用方法一</h2><p>将normalize.css作为你自己项目的基础CSS，自定义样式值以满足设计师的需求。</p><h2 id="使用方法二"><a href="#使用方法二" class="headerlink" title="使用方法二"></a>使用方法二</h2><p>引入normalize.css源码并在此基础上构建，在必要的时候用你自己写的CSS覆盖默认值。</p><h1 id="四、使用Normalize的参考实例"><a href="#四、使用Normalize的参考实例" class="headerlink" title="四、使用Normalize的参考实例"></a>四、使用Normalize的参考实例</h1><p><a href="http://amazeui.org/css/" target="_blank" rel="noopener">amaze ui</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>reset custom</title>
      <link href="/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/reset-custom/"/>
      <url>/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/reset-custom/</url>
      
        <content type="html"><![CDATA[<p>/* custom reset css */</p><p>button {<br>display: block;<br>width: 100%;<br>border: 0;<br>outline:none;<br>box-shadow: none;<br>padding: 0;<br>}</p><p>button:after{<br>border: none;<br>}</p><p>a {<br>color: #7e8c8d;<br>-webkit-backface-visibility: hidden;<br>background: none;<br>text-decoration:none;<br>}</p><p>li {<br>list-style: none;<br>}</p><p>::-webkit-scrollbar {<br>width: 0;<br>height: 0;<br>color: transparent;<br>}</p><p>}</p><p>::-webkit-scrollbar-track-piece {<br>background-color: rgba(0, 0, 0, 0.2);<br>-webkit-border-radius: 6px;<br>}</p><p>::-webkit-scrollbar-thumb:vertical {<br>height: 5px;<br>background-color: rgba(125, 125, 125, 0.7);<br>-webkit-border-radius: 6px;<br>}</p><p>::-webkit-scrollbar-thumb:horizontal {<br>width: 5px;<br>background-color: rgba(125, 125, 125, 0.7);<br>-webkit-border-radius: 6px;<br>}</p><p>fieldset, img {<br>border:0<br>}<br>legend {<br>display:none<br>}<br>address, caption, cite, code, dfn, em, strong, th, var{<br>font-style:normal;<br>font-weight:normal<br>}<br>caption, th {<br>text-align:left<br>}</p><p>h1, h2, h3, h4, h5, h6 {<br>font-size:100%;<br>font-weight: bold;<br>}<br>img{<br>width: 100%;<br>display: block;<br>margin: 0 auto;<br>}<br>input[type=”text”],<br>input[type=”button”],<br>input[type=”submit”],<br>input[type=”search”] {<br>-webkit-appearance:none;<br>border-radius:0;<br>}</p><p>html, body {<br>width: 100%;<br>height: 100%;<br>overflow-x: hidden;<br>-webkit-text-size-adjust: 100%!important;<br>text-size-adjust: 100%!important;<br>}</p><p>body {<br>font-family: -apple-system, BlinkMacSystemFont, “PingFang SC”,”Helvetica Neue”,STHeiti,”Microsoft Yahei”,Tahoma,Simsun,sans-serif;<br>-webkit-overflow-scrolling : touch; /* 解决ios滑动卡顿 */<br>-webkit-tap-highlight-color: rgba(0, 0, 0, 0);<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>reset</title>
      <link href="/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/reset/"/>
      <url>/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/reset/</url>
      
        <content type="html"><![CDATA[<p>/* <a href="http://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">http://meyerweb.com/eric/tools/css/reset/</a><br>v2.0 | 20110126<br>License: none (public domain)<br>*/</p><p>html, body, div, span, applet, object, iframe,<br>h1, h2, h3, h4, h5, h6, p, blockquote, pre,<br>a, abbr, acronym, address, big, cite, code,<br>del, dfn, em, img, ins, kbd, q, s, samp,<br>small, strike, strong, sub, sup, tt, var,<br>b, u, i, center,<br>dl, dt, dd, ol, ul, li,<br>fieldset, form, label, legend,<br>table, caption, tbody, tfoot, thead, tr, th, td,<br>article, aside, canvas, details, embed,<br>figure, figcaption, footer, header, hgroup,<br>menu, nav, output, ruby, section, summary,<br>time, mark, audio, video {<br>margin: 0;<br>padding: 0;<br>border: 0;<br>font-size: 100%;<br>font: inherit;<br>vertical-align: baseline;<br>}<br>/* HTML5 display-role reset for older browsers */<br>article, aside, details, figcaption, figure,<br>footer, header, hgroup, menu, nav, section {<br>display: block;<br>}<br>body {<br>line-height: 1;<br>}<br>ol, ul {<br>list-style: none;<br>}<br>blockquote, q {<br>quotes: none;<br>}<br>blockquote:before, blockquote:after,<br>q:before, q:after {<br>content: ‘’;<br>content: none;<br>}<br>table {<br>border-collapse: collapse;<br>border-spacing: 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css兼容性</title>
      <link href="/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
      <url>/2020/04/19/style/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是Polyfill"><a href="#一、什么是Polyfill" class="headerlink" title="一、什么是Polyfill"></a>一、什么是Polyfill</h1><p>用于实现浏览器并不支持的原生API的代码<br><a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills" target="_blank" rel="noopener">Polyfills</a></p><p>用于实现浏览器并不支持的原生API的代码</p><h1 id="二、有哪些Polyfill"><a href="#二、有哪些Polyfill" class="headerlink" title="二、有哪些Polyfill"></a>二、有哪些Polyfill</h1><h2 id="1、HTML5Shiv"><a href="#1、HTML5Shiv" class="headerlink" title="1、HTML5Shiv"></a>1、HTML5Shiv</h2><p><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="noopener">html5shiv</a><br>解决HTML5提出的新的元素不被IE6-8识别</p><!--[if lt IE 9]><script type="text/javascript" src="js/html5shiv.js"></script><![endif]--><h2 id="2、Respond-js"><a href="#2、Respond-js" class="headerlink" title="2、Respond.js"></a>2、Respond.js</h2><p><a href="https://github.com/scottjehl/Respond" target="_blank" rel="noopener">Respond</a></p><p>是一个快速、轻量的 polyfill，<br>用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器<br>提供媒体查询的 min-width 和 max-width 特性</p><h2 id="3、Modernizr"><a href="#3、Modernizr" class="headerlink" title="3、Modernizr"></a>3、Modernizr</h2><p>用于检测浏览器的新特性支持情况<br>现在默认包含了html5shiv的能力</p><h2 id="4、html5media-js"><a href="#4、html5media-js" class="headerlink" title="4、html5media.js"></a>4、html5media.js</h2><h2 id="5、css3pie"><a href="#5、css3pie" class="headerlink" title="5、css3pie"></a>5、css3pie</h2><p><a href="https://github.com/lojjic/PIE" target="_blank" rel="noopener">PIE</a></p><h2 id="6、ie-css3-htc"><a href="#6、ie-css3-htc" class="headerlink" title="6、ie-css3.htc"></a>6、ie-css3.htc</h2><p><a href="https://download.csdn.net/download/lxcao/9685089" target="_blank" rel="noopener">老曹</a></p><p>IE9以下的浏览器支持圆角及CSS3新特性，只有IE才能够识别</p><p>.box {<br>border-radius: 15px;<br>behavior: url(ie-css3.htc);<br>}</p><h2 id="7、Normalize-css"><a href="#7、Normalize-css" class="headerlink" title="7、Normalize.css"></a>7、Normalize.css</h2><p>在默认的HTML元素样式上提供了跨浏览器的高度一致性。<br>一种现代的、为HTML5准备的优质替代方案<br><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a><br><a href="http://jerryzou.com/posts/aboutNormalizeCss/" target="_blank" rel="noopener">谈一谈 Normalize</a></p><h1 id="三、处理兼容性常用方案"><a href="#三、处理兼容性常用方案" class="headerlink" title="三、处理兼容性常用方案"></a>三、处理兼容性常用方案</h1><h2 id="1、优雅降级"><a href="#1、优雅降级" class="headerlink" title="1、优雅降级"></a>1、优雅降级</h2><p>用户使用的是老式浏览器时，代码会针对旧版本的IE进行降级处理，如：border-shadow</p><meta http-equiv=”X-UA-Compatible” content=”IE=EmulateIE7″ />只要IE8一读到这个标签，它就会自动启动IE7兼容模式，保证页面完整展示。## 2、渐进增强从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能则用HTML5<h2 id="3、初始化CSS样式"><a href="#3、初始化CSS样式" class="headerlink" title="3、初始化CSS样式"></a>3、初始化CSS样式</h2><p>不同浏览器对有些标签的默认值是不同的，会对SEO有一定的影响<br>*{margin:0;padding:0;}</p><h2 id="4、调节浏览器的渲染方式"><a href="#4、调节浏览器的渲染方式" class="headerlink" title="4、调节浏览器的渲染方式"></a>4、调节浏览器的渲染方式</h2><p>使用meta标签来强制IE8使用最新的内核渲染页面</p><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><h2 id="5、CSS-HACK-方法"><a href="#5、CSS-HACK-方法" class="headerlink" title="5、CSS HACK 方法"></a>5、CSS HACK 方法</h2><p>顺序不能颠倒了，通用的放前面，越专用的越放后面</p><p>line-height:32px;<br>    line-height: 32px\9; /<em>IE8</em>/<br>    <em>line-height: 32px; /</em> IE7支持 <em>/<br>    _line-height: 32px; /</em> IE6支持 <em>/<br>    -ms-line-height: 32px;/*IE9+支持</em>/<br>    -webkit-line-height:32px; /<em>chrome safair</em>/<br>    -moz-line-height: 32px;/<em>火狐</em>/</p><p>所有浏览器 通用 height: 100px;<br>IE6 专用 _height: 100px;<br>IE7 专用 *+height: 100px;<br>IE6、IE7 共用 *height: 100px;<br>IE7、FF 共用 height: 100px !important;</p><h1 id="四、其它辅助工具"><a href="#四、其它辅助工具" class="headerlink" title="四、其它辅助工具"></a>四、其它辅助工具</h1><h2 id="1、测试游览器对-html5-的支持"><a href="#1、测试游览器对-html5-的支持" class="headerlink" title="1、测试游览器对 html5 的支持"></a>1、测试游览器对 html5 的支持</h2><p><a href="http://html5test.com/results/desktop.html" target="_blank" rel="noopener">http://html5test.com/results/desktop.html</a></p><h2 id="2、浏览器市场份额百度统计"><a href="#2、浏览器市场份额百度统计" class="headerlink" title="2、浏览器市场份额百度统计"></a>2、浏览器市场份额百度统计</h2><p><a href="https://tongji.baidu.com/data/browser/" target="_blank" rel="noopener">https://tongji.baidu.com/data/browser/</a></p><h2 id="3、浏览器兼容性试题"><a href="#3、浏览器兼容性试题" class="headerlink" title="3、浏览器兼容性试题"></a>3、浏览器兼容性试题</h2><p><a href="https://www.jianshu.com/p/f971aae86f4d" target="_blank" rel="noopener">https://www.jianshu.com/p/f971aae86f4d</a><br><a href="https://blog.csdn.net/lxcao/article/details/52975459" target="_blank" rel="noopener">https://blog.csdn.net/lxcao/article/details/52975459</a></p><p>IE8 兼容性<br>rgba 颜色格式<br>IE8 不支持 rgba(0, 0, 0, .5) 这种颜色格式。<br>解决方案：可以利用一张半透明的 png 图片来兼容 IE8。<br>flexbox<br>IE8 不支持 flex 布局属性的， 甚至 IE11 只支持一部分。<br>解决方案：利用 display: inline-block / display: table / display: inline 来实现部分兼容。</p><p>HTML5<br>HTML5 新增的标签在 IE8 里是不受支持滴，例如：section / main / header / footer等。<br>解决方案：html5shiv，这个脚本可以实现兼容 IE8 。<br><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="noopener">https://github.com/aFarkas/html5shiv</a></p><p>media query<br>IE8 也不支持 media query 。<br>解决方案：Respond.js<br><a href="https://github.com/scottjehl/Respond" target="_blank" rel="noopener">https://github.com/scottjehl/Respond</a><br>html5media.js<br>modernizr（一款兼容css3、html5等元素的插件）</p><p>CSS3 新特性<br>IE8 支持的 CSS3 新特性仅有 20% 。<br>解决方案：css3pie，<a href="https://github.com/lojjic/PIE" target="_blank" rel="noopener">https://github.com/lojjic/PIE</a><br>border-radius 只能使用图片代替了（整体背景图或者四个弧角的背景图）<br>box-shadow<br>border-image<br>multiple background images<br>linear-gradient as background image</p><p>innerHTML<br>IE8 不支持 innerHTML ，如果在 IE8 中运行<br>el.innerHTML = ‘<div>‘ + content + ‘</div>‘<br>Unknown runtime error<br>解决方案：可以利用这两种方法 document.createElement() &amp; appendChild() ，动态创建并插入到目标元素。</p><p>dom元素不区分name属性大小写</p><p>解决方案：在选择dom元素时可以加上其父级元素来区分</p><p class='p1'><input type='text' name='C1'/></p><p class='p2'><input type='text' name='c1'/></p>document.querySelectorAll(".p1 input[name='C1")document.querySelectorAll(".p2 input[name='c1")不兼容calc()改布局不兼容placeholder使用js插件https://github.com/mathiasbynens/jquery-placeholder不兼容text-overflowoverflow: hidden;white-space: nowrap;-o-text-overflow: ellipsis; /* for Opera */text-overflow: ellipsis; /* for IE */不兼容background-size不兼容line-height line-height:32px;     line-height: 32px\9; /*IE8*/    *line-height: 32px; /* IE7支持 */    _line-height: 32px; /* IE6支持 */    -ms-line-height: 32px;/*IE9+支持*/    -webkit-line-height:32px; /*chrome safair*/    -moz-line-height: 32px;/*火狐*/不兼容transform使用filter的Matrix（矩阵）<p>本地视频不能播放<br>jplayer插件<br>在此路径：C:\Windows\SysWOW64\Macromed\Flash\flashPlayerTrust<br>之下添加trustpath.txt文件，内容是盘符：<br>c:<br>d:<br>e:<br>降级处理</p><meta http-equiv=”X-UA-Compatible” content=”IE=EmulateIE7″ />只要IE8一读到这个标签，它就会自动启动IE7兼容模式，保证页面完整展示。调节浏览器的渲染方式使用meta标签来强制IE8使用最新的内核渲染页面<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"<p>react ie8 兼容示例<br><a href="https://github.com/GarveyZuo/React-router-redux-IE8/" target="_blank" rel="noopener">https://github.com/GarveyZuo/React-router-redux-IE8/</a><br><a href="https://blog.csdn.net/zjw0742/article/details/52981706" target="_blank" rel="noopener">https://blog.csdn.net/zjw0742/article/details/52981706</a></p><p>vue 不支持 ie8</p><h2 id="web端"><a href="#web端" class="headerlink" title="web端"></a>web端</h2><p>webSocket如何兼容低浏览器<br>Adobe Flash Socket 、<br>ActiveX HTMLFile (IE) 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR<br>Div居中问题<br>IE7、IE8、IE9在设置了margin-left和margin-right为auto后，并不能使div居中显示<br>设定body居中，定义text-algin: center<br>png24位的图片在iE6浏览器上出现背景<br>做成PNG8</p><p>默认的margin和padding不同<br>加一个全局的*{margin:0;padding:0;}</p><p>获取自定义属性<br>IE下,可以使用获取常规属性的方法，Firefox下,只能使用getAttribute()<br>统一通过getAttribute()获取<br>IE下,even对象有x,y属性,但是没有pageX,pageY属性，Firefox相反<br>var page = {};<br>page.x = event.x ? event.x : event.pageX;</p><p>Chrome 中文界面下默认会将小于12px的文本强制按照12px显示<br>-webkit-text-size-adjust: none;</p><p>超链接访问过后hover样式就不出现了<br>改变CSS属性的排列顺序<br>a:link {} a:visited {} a:hover {} a:active {}<br>添加事件和移除事件<br>IE提供了attachEvent和detachEvent两个接口，<br>而Firefox提供的是addEventListener和removeEventListener。</p><p>清除字符串前后的空格<br>兼容所有浏览器<br>if (!String.prototype.trim) {<br>String.prototype.trim = function() {<br>return this.replace(/^\s+/, “”).replace(/\s+$/,””);<br>}<br>图片默认有间距<br>使用float属性为img布局<br>多张图片需要排在一行时,使用“Float：Left”,导致图片与后面的内容存在margin不一致<br>给图片添加“Display：inline”</p><p>vertical-align:middle 对于IE浏览器没有效果<br>将文字的行高设置与DIV一样<br>设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度<br>设置overflow:hidden;或者设置行高line-height 小于你设置的高度</p><p>行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug<br>在display:block;后面加入display:inline;display:table;</p><p>min-height不兼容<br>{min-height:200px; height:auto !important; height:200px; overflow:visible;}</p><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>虚拟键盘引起的兼容问题<br>浮动窗口底部有输入框，触发键盘会遮住看不到<br><a href="http://stackoverflow.com/questions/24557780/ios-7-fixed-footer-toolbar-breaks-on-virtual-keyboard" target="_blank" rel="noopener">http://stackoverflow.com/questions/24557780/ios-7-fixed-footer-toolbar-breaks-on-virtual-keyboard</a><br>touch 事件引起的<br>iOS 和 android 系统导致的差别<br>微信浏览器<br>iOS input 内的元素居中有问题<br>将 input 隐藏，在未点击状态用 span 来模拟。点击时再切换到 input 元素</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css属性</title>
      <link href="/2020/04/19/style/css/css%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/04/19/style/css/css%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>// 选择器    示例    示例说明    CSS<br>.class .intro //选择所有class=”intro”的元素    1<br>#id #firstname //选择所有id=”firstname”的元素    1</p><ul><li><ul><li>//选择所有元素    2<br>element p //选择所有<p>元素    1<br>element,<br>element div,<br>p //选择所有<div>元素和<p>元素    1<br>element element div p //选择<div>元素内的所有<p>元素    1<br>element&gt;element div&gt;p //选择所有父级是 <div> 元素的 <p> 元素    2<br>element+element div+p //选择所有紧接着<div>元素之后的<p>元素    2<br>[attribute] [target] //选择所有带有target属性元素    2<br>[attribute=value] [target=-blank] //选择所有使用target=”-blank”的元素    2<br>[attribute<del>=value] [title</del>=flower] //选择标题属性包含单词”flower”的所有元素    2<br>[attribute|=language] [lang|=en] //选择一个lang属性的起始值=”EN”的所有元素    2<br>:link a:link //选择所有未访问链接    1<br>:visited a:visited //选择所有访问过的链接    1<br>:active a:active //选择活动链接    1<br>:hover a:hover //选择鼠标在链接上面时    1<br>:focus input:focus //选择具有焦点的输入元素    2<br>:first-letter p:first-letter //选择每一个<P>元素的第一个字母    1<br>:first-line p:first-line //选择每一个<P>元素的第一行    1<br>:first-child p:first-child //指定只有当<p>元素是其父级的第一个子级的样式。    2<br>:before p:before //在每个<p>元素之前插入内容    2<br>:after p:after //在每个<p>元素之后插入内容    2<br>:lang(language) p:lang(it) //选择一个lang属性的起始值=”it”的所有<p>元素    2<br>element1<del>element2 p</del>ul //选择p元素之后的每一个ul元素    3<br>[attribute^=value] a[src^=”https”] //选择每一个src属性的值以”https”开头的元素    3<br>[attribute$=value] a[src$=”.pdf”] //选择每一个src属性的值以”.pdf”结尾的元素    3<br>[attribute<em>=value] a[src</em>=”runoob”] //选择每一个src属性的值包含子字符串”runoob”的元素    3<br>:first-of-type p:first-of-type //选择每个p元素是其父级的第一个p元素    3<br>:last-of-type p:last-of-type //选择每个p元素是其父级的最后一个p元素    3<br>:only-of-type p:only-of-type //选择每个p元素是其父级的唯一p元素    3<br>:only-child p:only-child //选择每个p元素是其父级的唯一子元素    3<br>:nth-child(n) p:nth-child(2) //选择每个p元素是其父级的第二个子元素    3<br>:nth-last-child(n) p:nth-last-child(2) //选择每个p元素的是其父级的第二个子元素，从最后一个子项计数    3<br>:nth-of-type(n) p:nth-of-type(2) //选择每个p元素是其父级的第二个p元素    3<br>:nth-last-of-type(n) p:nth-last-of-type(2) //选择每个p元素的是其父级的第二个p元素，从最后一个子项计数    3<br>:last-child p:last-child //选择每个p元素是其父级的最后一个子级。    3<br>:root:root //选择文档的根元素    3<br>:empty p:empty //选择每个没有任何子级的p元素（包括文本节点）    3<br>:target #news:target //选择当前活动的#news元素（包含该锚名称的点击的URL）    3<br>:enabled input:enabled //选择每一个已启用的输入元素    3<br>:disabled input:disabled //选择每一个禁用的输入元素    3<br>:checked input:checked //选择每个选中的输入元素    3<br>:not(selector):not(p) //选择每个并非p元素的元素    3<br>::selection::selection //匹配元素中被用户选中或处于高亮状态的部分    3<br>:out-of-range:out-of-range //匹配值在指定区间之外的input元素    3<br>:in-range:in-range //匹配值在指定区间之内的input元素    3<br>:read-write:read-write //用于匹配可读及可写的元素    3<br>:read-only:read-only //用于匹配设置 “readonly”（只读） 属性的元素    3<br>:optional:optional //用于匹配可选的输入元素    3<br>:required:required //用于匹配设置了 “required” 属性的元素    3<br>:valid:valid //用于匹配输入值为合法的元素    3<br>:invalid:invalid //用于匹配输入值为非法的元素    3</li></ul></li></ul><p>/<em>动画属性</em>/</p><p>// @keyframes    定义一个动画,@keyframes定义的动画名称用来被animation-name所使用。    3<br>// animation    复合属性。检索或设置对象所应用的动画特效。    3<br>// animation-name    检索或设置对象所应用的动画名称 ,必须与规则@keyframes配合使用，因为动画名称由@keyframes定义    3<br>// animation-duration    检索或设置对象动画的持续时间    3<br>// animation-timing-function    检索或设置对象动画的过渡类型    3<br>// animation-delay    检索或设置对象动画的延迟时间    3<br>// animation-iteration-count    检索或设置对象动画的循环次数    3<br>// animation-direction    检索或设置对象动画在循环中是否反向运动    3<br>// animation-play-state    检索或设置对象动画的状态    3</p><p>/<em>背景属性</em>/</p><p>background //复合属性。设置对象的背景特性。    1<br>{<br>background: #00ff00 url(‘smiley.gif’) no-repeat fixed center;<br>}</p><p>background-attachment //设置或检索背景图像是随对象内容滚动还是固定的。必须先指定background-image属性。    1</p><p>/*    scroll    背景图片随页面的其余部分滚动。这是默认<br>fixed    背景图像是固定的*/</p><p>{<br>background-image: url(‘smiley.gif’);<br>background-repeat: no-repeat;<br>background-attachment: fixed;<br>}</p><p>background-color //设置或检索对象的背景颜色。    1<br>{<br>background-color: yellow;<br>background-color: #00ff00;<br>background-color: rgb(255, 0, 255);<br>}</p><p>background-image //设置或检索对象的背景图像。    1</p><p>/*    url(‘URL’)    图像的URL<br>none    无图像背景会显示。这是默认*/</p><p>background-position //设置或检索对象的背景图像位置。必须先指定background-image属性。    1</p><p>/*    left top 如果仅指定一个关键字，其他值将会是”center”<br>left center<br>left bottom<br>right top<br>right center<br>right bottom<br>center top<br>center center<br>center bottom<br>x% y%    第一个值是水平位置，第二个值是垂直。左上角是0％0％。右下角是100％100％。如果仅指定了一个值，其他值将是50％。 。默认值为：0％0％<br>xpos ypos    第一个值是水平位置，第二个值是垂直。左上角是0。单位可以是像素（0px0px）或任何其他CSS单位。如果仅指定了一个值，其他值将是50％。你可以混合使用％和positions*/</p><p>background-repeat //设置或检索对象的背景图像如何铺排填充。必须先指定background-image属性。    1</p><p>/*    repeat    背景图像将向垂直和水平方向重复。这是默认<br>repeat-x    只有水平位置会重复背景图像<br>repeat-y    只有垂直位置会重复背景图像<br>no-repeat    background-image不会重复*/</p><p>{<br>background-image: url(‘smiley.gif’);<br>background-repeat: no-repeat;<br>background-attachment: fixed;<br>background-position: center;<br>background-size: 80px 60px;<br>}</p><p>background-clip //指定对象的背景图像向外裁剪的区域。    3</p><p>/*    border-box    默认值。背景绘制在边框方框内（剪切成边框方框）。<br>padding-box    背景绘制在衬距方框内（剪切成衬距方框）。<br>content-box    背景绘制在内容方框内（剪切成内容方框）。*/</p><p>{<br>background-color: yellow;<br>background-clip: content-box;<br>}</p><p>background-origin //设置或检索对象的背景图像计算background-position时的参考原点(位置)。    3<br>background-size //检索或设置对象的背景图像的尺寸大小。    3</p><p>/*    length    设置背景图片高度和宽度。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为”atuo(自动)”<br>percentage    将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为”auto(自动)”<br>cover    此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小。<br>contain    此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。*/</p><p>/<em>边框(Border) 和 轮廓(Outline) 属性</em>/</p><p>border //复合属性。设置对象边框的特性。    1<br>{<br>border: 5px solid red;<br>}</p><p>border-color //置或检索对象的边框颜色。    1<br>{<br>border-style: solid;<br>border-color: #ff0000 #0000ff;<br>}</p><p>border-style //设置或检索对象的边框样式。    1</p><p>/*    none    定义无边框。<br>hidden    与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。<br>dotted    定义点状边框。在大多数浏览器中呈现为实线。<br>dashed    定义虚线。在大多数浏览器中呈现为实线。<br>solid    定义实线。<br>double    定义双线。双线的宽度等于 border-width 的值。<br>groove    定义 3D 凹槽边框。其效果取决于 border-color 的值。<br>ridge    定义 3D 垄状边框。其效果取决于 border-color 的值。<br>inset    定义 3D inset 边框。其效果取决于 border-color 的值。<br>outset    定义 3D outset 边框。其效果取决于 border-color 的值。*/</p><p>{<br>border-style: solid;<br>border-style: dotted solid double dashed;<br>/*    上边框是点状<br>右边框是实线<br>下边框是双线<br>左边框是虚线<em>/<br>border-style: dotted solid double;<br>/</em>    上边框是点状<br>右边框和左边框是实线<br>下边框是双线<em>/<br>border-style: dotted solid;<br>/</em>    上边框和下边框是点状<br>右边框和左边框是实线<em>/<br>border-style: dotted;<br>/</em>    所有4个边框都是点状*/<br>}</p><p>border-width //设置或检索对象的边框宽度。    1</p><p>/*    thin    定义细的边框。<br>medium    默认。定义中等的边框。<br>thick    定义粗的边框。<br>length    允许您自定义边框的宽度。*/</p><p>{<br>border-width: thin medium thick 10px;<br>/*    上边框是细边框<br>右边框是中等边框<br>下边框是粗边框<br>左边框是 10px 宽的边框<em>/<br>border-width: thin medium thick;<br>/</em>    上边框是细边框<br>右边框和左边框是中等边框<br>下边框是粗边框<em>/<br>border-width: thin medium;<br>/</em>    上边框和下边框是细边框<br>右边框和左边框是中等边框<em>/<br>border-width: thin;<br>/</em>    所有4个边框都是细边框*/<br>}</p><p>border-top //复合属性。设置对象顶部边框的特性。    1<br>border-top-color //设置或检索对象的顶部边框颜色    1<br>border-top-style //设置或检索对象的顶部边框样式。    1<br>border-top-width //设置或检索对象的顶部边框宽度。    1<br>border-left //复合属性。设置对象左边边框的特性。    1<br>border-left-color //设置或检索对象的左边边框颜色。    1<br>border-left-style //设置或检索对象的左边边框样式。    1<br>border-left-width //设置或检索对象的左边边框宽度。    1<br>border-right //复合属性。设置对象右边边框的特性。    1<br>border-right-color //设置或检索对象的右边边框颜色。    1<br>border-right-style //设置或检索对象的右边边框样式。    1<br>border-right-width //设置或检索对象的右边边框宽度。    1<br>border-bottom //复合属性。设置对象底部边框的特性。    1<br>border-bottom-color //设置或检索对象的底部边框颜色。    1<br>border-bottom-style //设置或检索对象的底部边框样式。    1<br>border-bottom-width //设置或检索对象的底部边框宽度。    1<br>outline //复合属性。设置或检索对象外的线条轮廓。    2<br>{<br>outline: #00FF00 dotted thick;<br>}</p><p>outline-color //设置或检索对象外的线条轮廓的颜色。    2<br>outline-style //设置或检索对象外的线条轮廓的样式。    2</p><p>/*    none    默认。定义无轮廓。<br>dotted    定义点状的轮廓。<br>dashed    定义虚线轮廓。<br>solid    定义实线轮廓。<br>double    定义双线轮廓。双线的宽度等同于 outline-width 的值。<br>groove    定义 3D 凹槽轮廓。此效果取决于 outline-color 值。<br>ridge    定义 3D 凸槽轮廓。此效果取决于 outline-color 值。<br>inset    定义 3D 凹边轮廓。此效果取决于 outline-color 值。<br>outset    定义 3D 凸边轮廓。此效果取决于 outline-color 值。*/</p><p>outline-width //设置或检索对象外的线条轮廓的宽度。    2</p><p>/*    thin    规定细轮廓。<br>medium    默认。规定中等的轮廓。<br>thick    规定粗的轮廓。<br>length    允许您规定轮廓粗细的值。*/</p><p>{<br>outline-style: dotted;<br>outline-width: 5px;<br>outline-color: #00ff00;<br>}</p><p>border-image //设置或检索对象的边框样式使用图像来填充。    3<br>{<br>border-image: url(border.png) 30 30 round;<br>/<em>border-image: source slice width outset repeat;</em>/<br>}</p><p>border-image-outset //规定边框图像超过边框的量。    3<br>border-image-repeat //规定图像边框是否应该被重复（repeated）、拉伸（stretched）或铺满（rounded）。</p><p>/*    stretch    默认值。拉伸图像来填充区域<br>repeat    平铺（repeated）图像来填充区域。<br>round    类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。<br>space    类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围    */</p><p>border-image-slice //规定图像边框的向内偏移。    3</p><p>/*    number    数字表示图像的像素（位图图像）或向量的坐标（如果图像是矢量图像）<br>%    百分比图像的大小是相对的：水平偏移图像的宽度，垂直偏移图像的高度<br>fill    保留图像的中间部分*/</p><p>{<br>border-image-source: url(border.png);<br>border-image-slice: 50% 50%;<br>border-image-slice: 0% 0% 100% 0%;<br>}</p><p>border-image-source //规定要使用的图像，代替 border-style 属性中设置的边框样式。    3<br>border-image-width //规定图像边框的宽度。</p><p>/*    number    表示相应的border-width 的倍数<br>%    边界图像区域的大小：横向偏移的宽度的面积，垂直偏移的高度的面积<br>auto    如果指定了，宽度是相应的image slice的内在宽度或高度*/</p><p>{<br>border-image-source: url(border.png);<br>border-image-width: 30 30;<br>}</p><p>border-radius //设置或检索对象使用圆角边框。    3</p><p>/*    length    定义弯道的形状。<br>%    使用%定义角落的形状。*/</p><p>{<br>border: 2px solid;<br>border-radius: 25px;<br>}</p><p>border-bottom-left-radius //设置或检索对象的左下角圆角边框。提供2个参数，2个参数以空格分隔，每个参数允许设置1个参数值，第1个参数表示水平半径，第2个参数表示垂直半径，如第2个参数省略，则默认等于第1个参数    3<br>border-bottom-right-radius //设置或检索对象的右下角圆角边框。    3<br>border-top-left-radius //定义左上角边框的形状。    3<br>border-top-right-radius //定义右下角边框的形状。    3<br>box-decoration-break //规定行内元素被折行    3<br>box-shadow //向方框添加一个或多个阴影。    3</p><p>/*    h-shadow    必需的。水平阴影的位置。允许负值<br>v-shadow    必需的。垂直阴影的位置。允许负值<br>blur    可选。模糊距离<br>spread    可选。阴影的大小<br>color    可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表*/</p><p>{<br>box-shadow: 10px 10px 5px #888888;<br>}</p><p>/<em>盒子(Box) 属性</em>/</p><p>overflow-x //如果内容溢出了元素内容区域，是否对内容的左/右边缘进行裁剪。    3</p><p>/*    visible    不裁剪内容，可能会显示在内容框之外。<br>hidden    裁剪内容 - 不提供滚动机制。<br>scroll    裁剪内容 - 提供滚动机制。<br>auto    如果溢出框，则应该提供滚动机制。<br>no-display    如果内容不适合内容框，则删除整个框。<br>no-content    如果内容不适合内容框，则隐藏整个内容。*/</p><p>{<br>overflow-x: hidden;<br>}</p><p>overflow-y //如果内容溢出了元素内容区域，是否对内容的上/下边缘进行裁剪。    3</p><p>/*    visible    不裁剪内容，可能会显示在内容框之外。<br>hidden    裁剪内容 - 不提供滚动机制。<br>scroll    裁剪内容 - 提供滚动机制。<br>auto    如果溢出框，则应该提供滚动机制。<br>no-display    如果内容不适合内容框，则删除整个框。<br>no-content    如果内容不适合内容框，则隐藏整个内容。*/</p><p>{<br>overflow-y: hidden;<br>}</p><p>overflow-style //规定溢出元素的首选滚动方法。    3</p><p>/<em>颜色(Color) 属性</em>/</p><p>color-profile //允许使用源的颜色配置文件的默认以外的规范    3<br>opacity //设置一个元素的透明度级别    3</p><p>/*    value    指定不透明度。从0.0（完全透明）到1.0（完全不透明）*/</p><p>{<br>opacity: 0.5;<br>}</p><p>rendering-intent //允许超过默认颜色配置文件渲染意向的其他规范    3</p><p>/<em>内边距(Padding) 属性</em>/</p><p>padding //在一个声明中设置所有填充属性    1</p><p>/*    负值是不允许的。<br>length    规定以具体单位计的填充值，比如像素、厘米等。默认值是 0px<br>%    规定基于父元素的宽度的百分比的填充*/</p><p>{<br>padding: 10px 5px 15px 20px;<br>/*    上填充是 10px<br>右填充是 5px<br>下填充是 15px<br>左填充是 20px<em>/<br>padding: 10px 5px 15px;<br>/</em>    上填充是 10px<br>右填充和左填充是 5px<br>下填充是 15px<em>/<br>padding: 10px 5px;<br>/</em>    上填充和下填充是 10px<br>右填充和左填充是 5px<em>/<br>padding: 10px;<br>/</em>    所有四个填充都是 10px*/<br>}</p><p>padding-bottom //设置元素的底填充    1<br>padding-left //设置元素的左填充    1<br>padding-right //设置元素的右填充    1<br>padding-top //设置元素的顶部填充    1</p><p>/<em>媒体页面内容属性</em>/</p><p>bookmark-label //指定书签的标签    3<br>bookmark-level //指定了书签级别    3<br>bookmark-target //指定了书签链接的目标    3<br>float-offset //在相反的方向推动浮动元素，他们一直具有浮动    3<br>hyphenate-after //指定一个断字的单词断字字符后的最少字符数    3<br>hyphenate-before //指定一个断字的单词断字字符前的最少字符数    3<br>hyphenate-character //指定了当一个断字发生时，要显示的字符串    3<br>hyphenate-lines //表示连续断字的行在元素的最大数目    3<br>hyphenate-resource //外部资源指定一个逗号分隔的列表，可以帮助确定浏览器的断字点    3<br>hyphens //设置如何分割单词以改善该段的布局    3<br>image-resolution //指定了正确的图像分辨率    3<br>marks //将crop and/or cross标志添加到文档    3<br>string-set //3</p><p>/<em>尺寸(Dimension) 属性</em>/</p><p>height //设置元素的高度    1</p><p>/*    auto    默认。浏览器会计算出实际的高度。<br>length    使用 px、cm 等单位定义高度。<br>%    基于包含它的块级对象的百分比高度。*/</p><p>width //设置元素的宽度    1<br>{<br>height: 100px;<br>width: 100px;<br>}</p><p>max-height //设置元素的最大高度    2</p><p>/*    max-height属性不包括填充，边框，或页边距！*/</p><p>max-width //设置元素的最大宽度    2<br>min-height //设置元素的最小高度    2<br>min-width //设置元素的最小宽度    2</p><p>/<em>弹性盒子模型（Flexible Box） 属性(新)</em>/</p><p>flex //复合属性。设置或检索弹性盒模型对象的子元素如何分配空间。    3<br>flex-grow //设置或检索弹性盒的扩展比率。    3<br>flex-shrink //设置或检索弹性盒的收缩比率。    3<br>flex-basis //设置或检索弹性盒伸缩基准值。    3<br>flex-flow //复合属性。设置或检索弹性盒模型对象的子元素排列方式。    3<br>flex-direction //该属性通过定义flex容器的主轴方向来决定felx子项在flex容器中的位置。    3<br>flex-wrap //该属性控制flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。    3<br>align-content //在弹性容器内的各项没有占用交叉轴上所有可用的空间时对齐容器内的各项（垂直）。    3<br>align-items //定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。    3<br>align-self //定义flex子项单独在侧轴（纵轴）方向上的对齐方式。    3<br>justify-content //设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。    3<br>order //设置或检索弹性盒模型对象的子元素出现的順序。    3</p><p>/<em>弹性盒子模型（Flexible Box） 属性(旧)</em>/</p><p>box-align //指定如何对齐一个框的子元素    3<br>box-direction //指定在哪个方向，显示一个框的子元素    3<br>box-flex //指定一个框的子元素是否是灵活的或固定的大小    3<br>box-flex-group //指派灵活的元素到Flex组    3<br>box-lines //每当它在父框的空间运行时，是否指定将再上一个新的行列    3<br>box-ordinal-group //指定一个框的子元素的显示顺序    3<br>box-orient //指定一个框的子元素是否在水平或垂直方向应铺设    3<br>box-pack //指定横向盒在垂直框的水平位置和垂直位置    3</p><p>/<em>字体（Font） 属性</em>/</p><p>font //在一个声明中设置所有字体属性    1</p><p>/*    font-style    规定字体样式。参阅：font-style 中可能的值。<br>font-variant    规定字体异体。参阅：font-variant 中可能的值。<br>font-weight    规定字体粗细。参阅：font-weight 中可能的值。<br>font-size/line-height    规定字体尺寸和行高。参阅：font-size 和 line-height 中可能的值。<br>font-family    规定字体系列。参阅：font-family 中可能的值。<br>caption    定义被标题控件（比如按钮、下拉列表等）使用的字体。<br>icon    定义被图标标记使用的字体。<br>menu    定义被下拉列表使用的字体。<br>message-box    定义被对话框使用的字体。<br>small-caption    caption 字体的小型版本。<br>status-bar    定义被窗口状态栏使用的字体。*/</p><p>{<br>font: 15px arial, sans-serif;<br>font: italic bold 12px/30px Georgia, serif;<br>}</p><p>font-family //规定文本的字体系列    1<br>{<br>font-family: “Times New Roman”, Georgia, Serif;<br>}</p><p>font-size //规定文本的字体尺寸    1</p><p>/*    medium 默认值：<br>smaller    把 font-size 设置为比父元素更小的尺寸。<br>larger    把 font-size 设置为比父元素更大的尺寸。<br>length    把 font-size 设置为一个固定的值。<br>%    把 font-size 设置为基于父元素的一个百分比值。*/</p><p>{<br>font-size: 250%<br>}</p><p>font-style //规定文本的字体样式    1</p><p>/*    normal    默认值。浏览器显示一个标准的字体样式。<br>italic    浏览器会显示一个斜体的字体样式。<br>oblique    浏览器会显示一个倾斜的字体样式。*/</p><p>{<br>font-style: normal<br>}</p><p>font-variant //规定文本的字体样式    1</p><p>/*    normal    默认值。浏览器会显示一个标准的字体。<br>small-caps    浏览器会显示小型大写字母的字体。*/</p><p>{<br>font-variant: small-caps;<br>}</p><p>font-weight //规定字体的粗细    1</p><p>/*    normal    默认值。定义标准的字符。<br>bold    定义粗体字符。<br>bolder    定义更粗的字符。<br>lighter    定义更细的字符。<br>100-900    定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。*/</p><p>{<br>font-weight: normal;<br>}</p><p>@font-face {}</p><p>//一个规则，允许网站下载并使用其他超过”Web- safe”字体的字体    3</p><p>/*    font-family    name    必需的。定义字体的名称。<br>src    URL    必需的。定义该字体下载的网址（S）<br>font-stretch    normal<br>condensed<br>ultra-condensed<br>extra-condensed<br>semi-condensed<br>expanded<br>semi-expanded<br>extra-expanded<br>ultra-expanded    可选。定义该字体应该如何被拉长。默认值是”正常”<br>font-style    normal<br>italic<br>oblique    可选。定义该字体应该是怎样样式。默认值是”正常”<br>font-weight    normal<br>bold<br>100-900    可选。定义字体的粗细。默认值是”正常”<br>unicode-range    unicode-range    可选。定义该字体支持Unicode字符的范围。默认值是”ü+0-10 FFFF”*/</p><p>@font-face {<br>font-family: myFirstFont;<br>src: url(‘Sansation_Light.ttf’), url(‘Sansation_Light.eot’);<br>/* IE9 */<br>}</p><p>font-size-adjust //为元素规定 aspect 值    3<br>{<br>font-size-adjust: 0.58;<br>}</p><p>font-stretch //收缩或拉伸当前的字体系列    3</p><p>/<em>内容生成属性(Generated Content Properties)</em>/</p><p>//content    与 :before 以及 :after 伪元素配合使用，来插入生成内容    2<br>counter-increment //递增或递减一个或多个计数器    2<br>counter-reset //创建或重置一个或多个计数器    2<br>quotes //设置嵌套引用的引号类型    2<br>crop //允许replaced元素只是作为一个对象代替整个对象的矩形区域    3<br>move-to //Causes an element to be removed from the flow and reinserted at a later point in the document    3<br>page-policy //判定基于页面的给定元素的适用于计数器的字符串值    3</p><p>/<em>网格（Grid） 属性</em>/</p><p>grid-columns //指定在网格中每列的宽度    3<br>grid-rows //指定在网格中每列的高度    3</p><p>/<em>超链接(Hyperlink) 属性</em>/</p><p>target //简写属性设置target-name, target-new,和target-position属性    3<br>target-name //指定在何处打开链接（目标位置）    3<br>target-new //指定是否有新的目标链接打开一个新窗口或在现有窗口打开新标签    3<br>target-position //指定应该放置新的目标链接的位置    3</p><p>/<em>线框(Linebox) 属性</em>/</p><p>alignment-adjust //允许更精确的元素的对齐方式    3<br>alignment-baseline //其父级指定的内联级别的元素如何对齐    3<br>baseline-shift //允许重新定位相对于dominant-baseline的dominant-baseline    3<br>dominant-baseline //指定scaled-baseline-table    3<br>drop-initial-after-adjust //设置下拉的主要连接点的初始对齐点    3<br>drop-initial-after-align //校准行内的初始行的设置就是具有首字母的框使用初级连接点    3<br>drop-initial-before-adjust //设置下拉的辅助连接点的初始对齐点    3<br>drop-initial-before-align //校准行内的初始行的设置就是具有首字母的框使用辅助连接点    3<br>drop-initial-size //控制局部的首字母下沉    3<br>drop-initial-value //激活一个下拉式的初步效果    3<br>inline-box-align //设置一个多行的内联块内的行具有前一个和后一个内联元素的对齐    3<br>line-stacking //一个速记属性设置line-stacking-strategy, line-stacking-ruby,和line-stacking-shift属性    3<br>line-stacking-ruby //设置包含Ruby注释元素的行对于块元素的堆叠方法    3<br>line-stacking-shift //设置base-shift行中块元素包含元素的堆叠方法    3<br>line-stacking-strategy //设置内部包含块元素的堆叠线框的堆叠方法    3<br>text-height //行内框的文本内容区域设置block-progression维数    3</p><p>/<em>列表(List) 属性</em>/</p><p>list-style //在一个声明中设置所有的列表属性    1<br>list-style-image //将图象设置为列表项标记    1<br>list-style-position //设置列表项标记的放置位置    1<br>list-style-type //设置列表项标记的类型    1</p><p>/<em>外边距(Margin) 属性</em>/</p><p>margin //在一个声明中设置所有外边距属性    1<br>{<br>margin: 10px 5px 15px 20px;<br>/*    上边距是 10px<br>右边距是 5px<br>下边距是 15px<br>左边距是 20px<em>/<br>margin: 10px 5px 15px;<br>/</em>    上边距是 10px<br>右边距和左边距是 5px<br>下边距是 15px<em>/<br>margin: 10px 5px;<br>/</em>    上边距和下边距是 10px<br>右边距和左边距是 5px<em>/<br>margin: 10px;<br>/</em>    所有四个边距都是 10px*/<br>}</p><p>margin-bottom //设置元素的下外边距    1<br>margin-left //设置元素的左外边距    1<br>margin-right //设置元素的右外边距    1<br>margin-top //设置元素的上外边距    1</p><p>/<em>字幕(Marquee) 属性</em>/</p><p>marquee-direction //设置内容移动的方向    3<br>marquee-play-count //设置内容移动多少次    3<br>marquee-speed //设置内容滚动的速度有多快    3<br>marquee-style //设置内容移动的样式    3</p><p>/<em>多列(Multi-column) 属性</em>/</p><p>column-count //指定元素应该分为的列数    3<br>column-fill //指定如何填充列    3<br>column-gap //指定列之间的差距    3<br>column-rule //对于设置所有column-rule-*属性的简写属性    3<br>column-rule-color //指定列之间的颜色规则    3<br>column-rule-style //指定列之间的样式规则    3<br>column-rule-width //指定列之间的宽度规则    3<br>column-span //指定元素应该跨越多少列    3<br>column-width //指定列的宽度    3<br>columns //缩写属性设置列宽和列数    3</p><p>/<em>页面媒体(Paged Media) 属性</em>/</p><p>fit //如果其宽度和高度属性都不是auto给出一个提示，如何大规模替换元素    3<br>fit-position //判定方框内对象的对齐方式    3<br>image-orientation //指定用户代理适用于图像中的向右或顺时针方向的旋转    3<br>page //指定一个元素应显示的页面的特定类型    3<br>size //指定含有BOX的页面内容的大小和方位    3</p><p>/<em>定位（Positioning） 属性</em>/</p><p>position //规定元素的定位类型    2</p><p>/*    absolute    生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。<br>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。<br>fixed    生成绝对定位的元素，相对于浏览器窗口进行定位。<br>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。<br>relative    生成相对定位的元素，相对于其正常位置进行定位。<br>因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。<br>static    默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。*/</p><p>h2 {<br>position: absolute;<br>left: 100px;<br>top: 150px;<br>}</p><p>top //设置定位元素的上外边距边界与其包含块上边界之间的偏移    2<br>img {<br>position: absolute;<br>top: 5px;<br>}</p><p>bottom //设置定位元素下外边距边界与其包含块下边界之间的偏移    2</p><p>/*    对于绝对定位元素，bottom属性设置单位高于/低于包含它的元素的底边。<br>对于相对定位元素，bottom属性设置单位高于/低于其正常位置的元素的底边。*/</p><p>{<br>position: absolute;<br>bottom: 5px;<br>}</p><p>left //设置定位元素左外边距边界与其包含块左边界之间的偏移    2</p><p>/*    auto    默认值。通过浏览器计算左边缘的位置。<br>%    设置以包含元素的百分比计的左边位置。可使用负值。<br>length    使用 px、cm 等单位设置元素的左边位置。可使用负值。*/</p><p>img {<br>position: absolute;<br>left: 5px;<br>}</p><p>right //设置定位元素右外边距边界与其包含块右边界之间的偏移    2<br>img {<br>position: absolute;<br>right: 5px;<br>}</p><p>clear //规定元素的哪一侧不允许其他浮动元素    1</p><p>/*    left    在左侧不允许浮动元素。<br>right    在右侧不允许浮动元素。<br>both    在左右两侧均不允许浮动元素。<br>none    默认值。允许浮动元素出现在两侧。*/</p><p>img {<br>float: left;<br>}</p><p>p.clear {<br>clear: both;<br>}</p><p>clip //剪裁绝对定位元素    2</p><p>/*    shape    设置元素的形状。唯一合法的形状值是：rect (top, right, bottom, left)<br>auto    默认值。不应用任何剪裁。*/</p><p>img {<br>position: absolute;<br>clip: rect(0px, 60px, 200px, 0px);<br>}</p><p>cursor //规定要显示的光标的类型（形状）    2</p><p>/*    url    需使用的自定义光标的 URL<br>default    默认光标（通常是一个箭头）<br>auto    默认。浏览器设置的光标。<br>crosshair    光标呈现为十字线。<br>pointer    光标呈现为指示链接的指针（一只手）<br>move    此光标指示某对象可被移动。<br>e-resize    此光标指示矩形框的边缘可被向右（东）移动。<br>ne-resize    此光标指示矩形框的边缘可被向上及向右移动（北/东）。<br>nw-resize    此光标指示矩形框的边缘可被向上及向左移动（北/西）。<br>n-resize    此光标指示矩形框的边缘可被向上（北）移动。<br>se-resize    此光标指示矩形框的边缘可被向下及向右移动（南/东）。<br>sw-resize    此光标指示矩形框的边缘可被向下及向左移动（南/西）。<br>s-resize    此光标指示矩形框的边缘可被向下移动（北/西）。<br>w-resize    此光标指示矩形框的边缘可被向左移动（西）。<br>text    此光标指示文本。<br>wait    此光标指示程序正忙（通常是一只表或沙漏）。<br>help    此光标指示可用的帮助（通常是一个问号或一个气球）。*/</p><p>span.crosshair {<br>cursor: crosshair<br>}</p><p>span.help {<br>cursor: help<br>}</p><p>span.wait {<br>cursor: wait<br>}</p><p>display //规定元素应该生成的框的类型    1</p><p>/*    none    此元素不会被显示。<br>block    此元素将显示为块级元素，此元素前后会带有换行符。<br>inline    默认。此元素会被显示为内联元素，元素前后没有换行符。<br>inline-block    行内块元素。（CSS2.1 新增的值）<br>list-item    此元素会作为列表显示。<br>run-in    此元素会根据上下文作为块级元素或内联元素显示。<br>compact    CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。<br>marker    CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。<br>table    此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。<br>inline-table    此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。<br>table-row-group    此元素会作为一个或多个行的分组来显示（类似 <tbody>）。<br>table-header-group    此元素会作为一个或多个行的分组来显示（类似 <thead>）。<br>table-footer-group    此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。<br>table-row    此元素会作为一个表格行显示（类似 <tr>）。<br>table-column-group    此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。<br>table-column    此元素会作为一个单元格列显示（类似 <col>）<br>table-cell    此元素会作为一个表格单元格显示（类似 <td> 和 <th>）<br>table-caption    此元素会作为一个表格标题显示（类似 <caption>）*/</p><p>p.inline {<br>display: inline;<br>}</p><p>float //规定框是否应该浮动    1</p><p>/*    left    元素向左浮动。<br>right    元素向右浮动。<br>none    默认值。元素不浮动，并会显示在其在文本中出现的位置。*/</p><p>img {<br>float: right;<br>}</p><p>overflow //规定当内容溢出元素框时发生的事情    2</p><p>/*    visible    默认值。内容不会被修剪，会呈现在元素框之外。<br>hidden    内容会被修剪，并且其余内容是不可见的。<br>scroll    内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。<br>auto    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。*/</p><p>div {<br>width: 150px;<br>height: 150px;<br>overflow: scroll;<br>}</p><p>visibility //规定元素是否可见    2</p><p>/*    visible    默认值。元素是可见的。<br>hidden    元素是不可见的。<br>collapse    当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。<br>被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。*/</p><p>h2 {<br>visibility: hidden;<br>}</p><p>z-index //设置元素的堆叠顺序    2<br>img {<br>position: absolute;<br>left: 0px;<br>top: 0px;<br>z-index: -1;<br>}</p><p>/<em>分页（Print） 属性</em>/</p><p>orphans //设置当元素内部发生分页时必须在页面底部保留的最少行数    2<br>page-break-after //设置元素后的分页行为    2<br>page-break-before //设置元素前的分页行为    2<br>page-break-inside //设置元素内部的分页行为    2<br>widows //设置当元素内部发生分页时必须在页面顶部保留的最少行数    2</p><p>/<em>Ruby 属性</em>/</p><p>ruby-align //控制Ruby文本和Ruby基础内容相对彼此的文本对齐方式    3<br>ruby-overhang //当Ruby文本超过Ruby的基础宽，确定ruby文本是否允许局部悬置任意相邻的文本，除了自己的基础    3<br>ruby-position //它的base控制Ruby文本的位置    3<br>ruby-span //控制annotation 元素的跨越行为    3</p><p>/<em>语音（Speech） 属性</em>/</p><p>mark //缩写属性设置mark-before和mark-after属性    3<br>mark-after //允许命名的标记连接到音频流    3<br>mark-before //允许命名的标记连接到音频流    3<br>phonemes //指定包含文本的相应元素中的一个音标发音    3<br>rest //一个缩写属性设置rest-before和rest-after属性    3<br>rest-after //一个元素的内容讲完之后，指定要休息一下或遵守韵律边界    3<br>rest-before //一个元素的内容讲完之前，指定要休息一下或遵守韵律边界    3<br>voice-balance //指定了左，右声道之间的平衡    3<br>voice-duration //指定应采取呈现所选元素的内容的长度    3<br>voice-pitch //指定平均说话的声音的音调（频率）    3<br>voice-pitch-range //指定平均间距的变化    3<br>voice-rate //控制语速    3<br>voice-stress //指示着重力度    3<br>voice-volume //语音合成是指波形输出幅度    3</p><p>/<em>表格（Table） 属性</em>/</p><p>border-collapse //规定是否合并表格边框    2<br>border-spacing //规定相邻单元格边框之间的距离    2<br>caption-side //规定表格标题的位置    2<br>empty-cells //规定是否显示表格中的空单元格上的边框和背景    2<br>table-layout //设置用于表格的布局算法    2</p><p>/<em>文本（Text） 属性</em>/</p><p>color //设置文本的颜色    1<br>{<br>color: #00ff00;<br>color: red;<br>color: rgb(0, 0, 255);<br>}</p><p>direction //规定文本的方向 / 书写方向    2</p><p>/*    ltr    默认。文本方向从左到右。<br>rtl    文本方向从右到左。*/</p><p>{<br>direction: rtl;<br>}</p><p>letter-spacing //设置字符间距    1<br>{<br>letter-spacing: 2px<br>}</p><p>line-height //设置行高    1</p><p>/*    normal    默认。设置合理的行间距。<br>number    设置数字，此数字会与当前的字体尺寸相乘来设置行间距。<br>length    设置固定的行间距。<br>%    基于当前字体尺寸的百分比行间距。*/</p><p>{<br>line-height: 90%<br>}</p><p>text-align //规定文本的水平对齐方式    1</p><p>/*    left    把文本排列到左边。默认值：由浏览器决定。<br>right    把文本排列到右边。<br>center    把文本排列到中间。<br>justify    实现两端对齐文本效果。*/</p><p>{<br>text-align: center<br>}</p><p>text-decoration //规定添加到文本的装饰效果    1</p><p>/*    none    默认。定义标准的文本。<br>underline    定义文本下的一条线。<br>overline    定义文本上的一条线。<br>line-through    定义穿过文本下的一条线。<br>blink    定义闪烁的文本。*/</p><p>{<br>text-decoration: overline<br>}</p><p>text-indent //规定文本块首行的缩进    1<br>{<br>text-indent: 50px;<br>}</p><p>text-transform //控制文本的大小写    1</p><p>/*    none    默认。定义带有小写字母和大写字母的标准的文本。<br>capitalize    文本中的每个单词以大写字母开头。<br>uppercase    定义仅有大写字母。<br>lowercase    定义无大写字母，仅有小写字母。*/</p><p>{<br>text-transform: uppercase;<br>}</p><p>unicode-bidi //2<br>vertical-align //设置元素的垂直对齐方式    1</p><p>/*    baseline    默认。元素放置在父元素的基线上。<br>sub    垂直对齐文本的下标。<br>super    垂直对齐文本的上标<br>top    把元素的顶端与行中最高元素的顶端对齐<br>text-top    把元素的顶端与父元素字体的顶端对齐<br>middle    把此元素放置在父元素的中部。<br>bottom    把元素的顶端与行中最低的元素的顶端对齐。<br>text-bottom    把元素的底端与父元素字体的底端对齐。<br>length<br>%    使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。*/</p><p>{<br>vertical-align: text-top;<br>}</p><p>white-space //设置怎样给一元素控件留白    1</p><p>/*    normal    默认。空白会被浏览器忽略。<br>pre    空白会被浏览器保留。<br>nowrap    文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。<br>pre-wrap    保留空白符序列，但是正常地进行换行。<br>pre-line    合并空白符序列，但是保留换行符。*/</p><p>{<br>white-space: nowrap;<br>}</p><p>word-spacing //设置单词间距    1<br>hanging-punctuation //指定一个标点符号是否可能超出行框    3<br>punctuation-trim //指定一个标点符号是否要去掉    3<br>text-align-last //当 text-align 设置为 justify 时，最后一行的对齐方式。    3<br>text-justify //当 text-align 设置为 justify 时指定分散对齐的方式。    3<br>text-outline //设置文字的轮廓。    3<br>text-overflow //指定当文本溢出包含的元素，应该发生什么    3<br>text-shadow //为文本添加阴影    3<br>text-wrap //指定文本换行规则    3<br>word-break //指定非CJK文字的断行规则    3<br>word-wrap //设置浏览器是否对过长的单词进行换行。    3</p><p>/<em>2D/3D 转换属性</em>/</p><p>transform //适用于2D或3D转换的元素    3<br>transform-origin //允许您更改转化元素位置    3<br>transform-style //3D空间中的指定如何嵌套元素    3<br>perspective //指定3D元素是如何查看透视图    3<br>perspective-origin //指定3D元素底部位置    3<br>backface-visibility //定义一个元素是否应该是可见的，不对着屏幕时    3</p><p>/<em>过渡（Transition） 属性</em>/</p><p>transition //此属性是 transition-property、transition-duration、transition-timing-function、transition-delay 的简写形式。    3<br>transition-property //设置用来进行过渡的 CSS 属性。    3<br>transition-duration //设置过渡进行的时间长度。    3<br>transition-timing-function //设置过渡进行的时序函数。    3<br>transition-delay //指定过渡开始的时间。    3</p><p>/<em>用户外观(User-interface) 属性</em>/</p><p>appearance //定义元素的外观样式    3<br>box-sizing //允许您为了适应区域以某种方式定义某些元素    3<br>icon //为元素指定图标    3<br>nav-down //指定用户按向下键时向下导航的位置    3<br>nav-index //指定导航（tab）顺序。    3<br>nav-left //指定用户按向左键时向左导航的位置    3<br>nav-right //指定用户按向右键时向左导航的位置    3<br>nav-up //指定用户按向上键时向上导航的位置a    3<br>outline-offset //设置轮廓框架在 border 边缘外的偏移    3<br>resize //定义元素是否可以改变大小    3</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css3属性</title>
      <link href="/2020/04/19/style/css/css3%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/04/19/style/css/css3%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、框模型"><a href="#一、框模型" class="headerlink" title="一、框模型"></a>一、框模型</h1><h2 id="1、-border-radius"><a href="#1、-border-radius" class="headerlink" title="1、    border-radius"></a>1、    border-radius</h2><p>圆角边框<br>IE9以下不支持<br>border-radius: 1-4 length|% / 1-4 length|%;<br>border-top-left-radius:2em;<br>border-top-right-radius:2em;<br>border-bottom-right-radius:2em;<br>border-bottom-left-radius:2em;</p><h2 id="2、-box-shadow"><a href="#2、-box-shadow" class="headerlink" title="2、    box-shadow"></a>2、    box-shadow</h2><p>阴影<br>IE9以下不支持<br>box-shadow: h-shadow v-shadow blur spread color inset;<br>水平位置 垂直位置 模糊距离 阴影的尺寸 阴影的颜色 内部阴影</p><h2 id="3、-border-image"><a href="#3、-border-image" class="headerlink" title="3、    border-image"></a>3、    border-image</h2><p>使用图片来绘制边框<br>IE不支持<br>Safari 5加前缀 -webkit-<br>Opera加前缀 -o-<br>border-image:url(border.png) 30 30 round;<br>border-image-source<br>图片的路径<br>border-image-slice<br>图片边框向内偏移<br>border-image-width<br>图片边框的宽度<br>border-image-outset<br>边框图像区域超出边框的量<br>border-image-repeat<br>是否应平铺</p><h1 id="二、背景和边框"><a href="#二、背景和边框" class="headerlink" title="二、背景和边框"></a>二、背景和边框</h1><h2 id="1、-background-size"><a href="#1、-background-size" class="headerlink" title="1、    background-size"></a>1、    background-size</h2><p>IE9以下不支持<br>背景图像尺寸<br>background-origin<br>IE9以下不支持<br>规定背景图片的定位区域<br>background-origin: padding-box|border-box|content-box;<br>background-clip<br>规定背景的绘制区域<br>background-clip: border-box|padding-box|content-box;</p><h2 id="2、文本效果"><a href="#2、文本效果" class="headerlink" title="2、文本效果"></a>2、文本效果</h2><p>text-shadow<br>IE10以下不支持<br>向文本添加阴影<br>word-wrap<br>IE10以下不支持<br>允许对长单词进行拆分，并换行<br>hanging-punctuation<br>规定标点字符是否位于线框之外<br>punctuation-trim<br>规定是否对标点字符进行修剪<br>text-align-last<br>设置如何对齐最后一行<br>text-emphasis<br>向元素的文本应用重点标记<br>text-justify<br>当 text-align 设置为 “justify” 时所使用的对齐方法<br>text-outline<br>文本的轮廓<br>text-overflow<br>当文本溢出包含元素时<br>word-break<br>规定非中日韩文本的换行规则</p><h2 id="3、-font-face-字体"><a href="#3、-font-face-字体" class="headerlink" title="3、@font-face 字体"></a>3、@font-face 字体</h2><p>IE9以下不支持<br>可以使用客户端未安装的字体，需要时自动从服务器下载</p><style>## 4、@font-face```css{font-family: myFirstFont;src: url('Sansation_Light.ttf'),url('Sansation_Light.eot'); /* IE9+ */}div {font-family:myFirstFont;}```# 三、变形与动画## 1、transform 2/3D转换transform: none|transform-functions;对元素进行旋转、缩放、移动或倾斜matrix(n,n,n,n,n,n)2D 拉伸、旋转、移动matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)3D 转换，使用 16 个值的 4x4 矩阵translate(x,y)2D 移动translate3d(x,y,z)3D 移动translateX(x)水平移动translateY(y)垂直移动translateZ(z)scale(x,y)2D 缩放（以中心点）scale3d(x,y,z)3D 缩放scaleX(x)水平缩放scaleY(y)垂直缩放scaleZ(z)rotate(angle)2D 旋转，传入角度angle: 0~360degrotate3d(x,y,z,angle)3D 旋转rotateX(angle)沿着 X 轴的 3D 旋转。90deg就是条线了rotateY(angle)沿着 Y 轴的 3D 旋转。90deg就是条线了rotateZ(angle)沿着 Z 轴的 3D 旋转，和2D旋转效果一样skew(x-angle,y-angle)沿着 X 和 Y 轴的 2D 倾斜转换skewX(angle)沿着 X 轴的 2D 倾斜转换skewY(angle)perspective(n)为 3D 转换元素定义透视视图。transform-origin : x-axis y-axis z-axis;设置旋转元素的基点位置x-axisleftcenterrightlength%y-axistopcenterbottomlength%z-axislength必须与 transform 属性一同使用默认以元素中心旋转 （50% 50% 0）transform-style : flat|preserve-3d;被嵌套元素如何在 3D 空间中显示。perspective : number|none;3D 元素的透视效果。子元素会获得透视效果，而不是元素本身number 元素距离视图的距离，以像素计。perspective-origin : x-axis y-axis;3D 元素的底部位置。子元素会获得透视效果，而不是元素本身backface-visibility: visible|hidden;定义元素在不面对屏幕时是否可见。兼容性IE 9 需要前缀 -ms-Chrome 和 Safari -webkit-Opera -o-Firefox -moz-## 2、transition 过渡transition : property duration timing-function delay;简写属性多项过渡用逗号分隔，可分别设置下面各属性transition-property : none|all|property;应用过渡的 CSS 属性的名称。transition-duration : time;定义过渡效果花费的时间。transition-timing-function : cubic-bezier(n,n,n,n);规定过渡效果的时间曲线。linear均度运动等于 cubic-bezier(0,0,1,1)ease快慢快cubic-bezier(0.25,0.1,0.25,1)ease-in慢速开始cubic-bezier(0.42,0,1,1)ease-out慢速结束cubic-bezier(0,0,0.58,1)ease-in-out慢速开始和结束cubic-bezier(0.42,0,0.58,1)cubic-bezier(n,n,n,n)自定义各阶段的速度，值0-1transition-delay规定过渡效果何时开始。兼容性IE10 以下不支持Chrome 25 以及更早的版本，需要前缀 -webkit-示例transition-duration: 1.2stransition-delay: 3s;transition-property: width;transition-timing-function: cubic-bezier(0.455, 0.03, 0.515, 0.955);background: linear-gradient(to right, #00fcd5, #00c6ff);背景渐变色transition: opacity 1s cubic-bezier(0.215, 0.61, 0.355, 1) 0.2s;透明度transition: opacity 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) 0.4s, transform 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) 0.4s;## 3、animation 动画@keyframes animationname {keyframes-selector {css-styles;}}创建动画animationname动画的名称keyframes-selector动画时长的百分比0-100%from（与 0% 相同）to（与 100% 相同）animation : name duration timing-function delay iteration-count direction;简写属性，将动画与 div 元素绑定animation-name : keyframename|none;规定 @keyframes 动画的名称。animation-duration : time;完成一个周期所花费的时间animation-timing-function : value;速度曲线linear匀速ease慢快慢ease-in慢速开始ease-out慢速结束ease-in-out慢速开始和结束cubic-bezier(n,n,n,n)自定义，0-1animation-delay : time;何时开始animation-iteration-count : n|infinite;被播放的次数infinite 无限次播放animation-direction : normal|alternate;是否在下一周期逆向地播放alternate 轮流反向播放animation-play-state : paused|running;是否正在运行或暂停animation-fill-mode : none | forwards | backwards | both;动画时间之外的状态forwards动画完成后，保持最后一个属性值backwards在动画显示之前，应用第一个关键帧中定义的属性值兼容性Chrome 和 Safari 需要前缀 -webkit-@-webkit-keyframesIE10 以下不支持## 4、示例```cssposition: relative;animation: mymove 5s infinite;@keyframes mymove{from {top:0px;}to {top:200px;}}// 从上到下移动@keyframes mymove{0% {top:0px; left:0px; background:red;}25% {top:0px; left:100px; background:blue;}50% {top:100px; left:100px; background:yellow;}75% {top:100px; left:0px; background:green;}100% {top:0px; left:0px; background:red;}}```# 四、多列布局columns设置 column-width 和 column-count 的简写属性column-width列的宽度column-count将元素下的内容分成几列column-gap规定列之间的间隔column-rule设置列之间的宽度、样式和颜色规则column-rule-colorcolumn-rule-stylecolumn-rule-widthcolumn-fill如何填充列column-span元素应该横跨的列数兼容性Firefox 需要前缀 -moz-Chrome 和 Safari 需要前缀 -webkit-IE10 以下不支持# 五、用户界面resize兼容性IE Opera 不支持规定是否可由用户调整元素尺寸box-sizing兼容性Firefox 需要前缀 -moz-设置使用哪种盒模型outline兼容性IE 不支持对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓轮廓不占用空间轮廓可能是非矩形outline-offset偏移距离]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css布局</title>
      <link href="/2020/04/19/style/css/%E5%B8%83%E5%B1%80/"/>
      <url>/2020/04/19/style/css/%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、盒模型"><a href="#一、盒模型" class="headerlink" title="一、盒模型"></a>一、盒模型</h1><blockquote><p>来源：imooc.com 快乐动起来前端面试题视频</p></blockquote><h2 id="1、标准模型"><a href="#1、标准模型" class="headerlink" title="1、标准模型"></a>1、标准模型</h2><p>content-box padding border margin<br>width/height = content-box</p><h2 id="2、IE模型"><a href="#2、IE模型" class="headerlink" title="2、IE模型"></a>2、IE模型</h2><p>content-box padding border margin<br>width/height = content-box + border + padding</p><h2 id="3、指定模型"><a href="#3、指定模型" class="headerlink" title="3、指定模型"></a>3、指定模型</h2><p>box-sizing: content-box // 标准<br>box-sizing: border-box // IE</p><h2 id="4、获取元素宽高"><a href="#4、获取元素宽高" class="headerlink" title="4、获取元素宽高"></a>4、获取元素宽高</h2><p>dom.style.width/height<br>dom.currenStyle.width/height<br>只支持ie<br>window.getComputedStyle(dom).width/height<br>兼容性更好<br>dom.getBoundingClientRect().width/height</p><h2 id="5、边距重叠-BFC"><a href="#5、边距重叠-BFC" class="headerlink" title="5、边距重叠(BFC)"></a>5、边距重叠(BFC)</h2><h3 id="5-1、现象"><a href="#5-1、现象" class="headerlink" title="5.1、现象"></a>5.1、现象</h3><p>父子元素</p><p>父元素上边距与子元素上边距重叠<br>兄弟元素</p><p>上面元素的下边和下面元素的上边取最大值作为边距<br>这是因为没有内边距或边框把外边距分隔开<br>对外框设置padding或border解决<br>自身</p><p>空元素，它有外边距，但是没有边框或填充<br>外边距合并<br>上边距合并<br>上下边距相撞</p><h3 id="5-2、特点"><a href="#5-2、特点" class="headerlink" title="5.2、特点"></a>5.2、特点</h3><blockquote><p>只有普通文档流中块框的垂直外边距才会发生外边距合并</p></blockquote><blockquote><p>行内框、浮动框或绝对定位之间的外边距不会合并</p></blockquote><h3 id="5-3、解决"><a href="#5-3、解决" class="headerlink" title="5.3、解决"></a>5.3、解决</h3><blockquote><p>设置padding或border</p></blockquote><blockquote><p>float</p></blockquote><blockquote><p>overflow: hidden/auto</p></blockquote><h1 id="二、布局模型"><a href="#二、布局模型" class="headerlink" title="二、布局模型"></a>二、布局模型</h1><h2 id="1、流动模型"><a href="#1、流动模型" class="headerlink" title="1、流动模型"></a>1、流动模型</h2><p>文档默认的布局模型<br>块元素独占一行，从上向下垂直分布<br>内联元素从左向右水平分布</p><h2 id="2、浮动模型"><a href="#2、浮动模型" class="headerlink" title="2、浮动模型"></a>2、浮动模型</h2><p>脱离文档流<br>使用float: left/right;让元素浮动<br>让块元素水平分布<br>多个框浮动时，宽度不够时会换行，高度不够时会卡住<br>清除<br>clear<br>left right both none<br>侧面是否允许其他的浮动元素<br>图片左float，段落右float，可增加一个空元素<br>进行clear，所容器元素框可以包含它们<br>overflow<br>hidden auto<br>防止浮动元素底下的元素溢出<br>但是容易出现滚动条或截断内容</p><h3 id="2-2、浮动元素引起的问题"><a href="#2-2、浮动元素引起的问题" class="headerlink" title="2.2、浮动元素引起的问题"></a>2.2、浮动元素引起的问题</h3><blockquote><p>父元素的高度无法被撑开，影响与父元素同级的元素<br>与浮动元素同级的非浮动元素会跟随其后<br>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p></blockquote><h2 id="3、层模型"><a href="#3、层模型" class="headerlink" title="3、层模型"></a>3、层模型</h2><h3 id="3-1、绝对定位"><a href="#3-1、绝对定位" class="headerlink" title="3.1、绝对定位"></a>3.1、绝对定位</h3><p>元素脱离文档流<br>position: absolute<br>使用left、right、top、bottom属性定位<br>相对于其最接近的一个具有定位属性的父包含块<br>没有则相对于浏览器窗口</p><h3 id="3-2、相对定位"><a href="#3-2、相对定位" class="headerlink" title="3.2、相对定位"></a>3.2、相对定位</h3><p>position: relative<br>使用left、right、top、bottom属性定位<br>相对于元素自身原来的位置定位<br>原来的位置仍然被保留着</p><h3 id="3-3、固定定位"><a href="#3-3、固定定位" class="headerlink" title="3.3、固定定位"></a>3.3、固定定位</h3><p>元素脱离文档流<br>position: fixed<br>相对网页窗口进行定位<br>位置固定，不会随着滚动条滚动而变化</p><h1 id="三、-对齐"><a href="#三、-对齐" class="headerlink" title="三、    对齐"></a>三、    对齐</h1><h2 id="1、水平居中"><a href="#1、水平居中" class="headerlink" title="1、水平居中"></a>1、水平居中</h2><h3 id="1-1、行内元素"><a href="#1-1、行内元素" class="headerlink" title="1.1、行内元素"></a>1.1、行内元素</h3><p>给父元素设置 text-align:center</p><h3 id="1-2、块状元素"><a href="#1-2、块状元素" class="headerlink" title="1.2、块状元素"></a>1.2、块状元素</h3><p>####（1）定宽</p><pre><code>width:200px;/*定宽*/margin:0 auto;/* margin-left 与 margin-right 设置为 auto */</code></pre><p>####（2）不定宽<br>方法一：table标签</p><pre><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;ul&gt;&lt;li&gt;我是第一行文本&lt;/li&gt;&lt;li&gt;我是第二行文本&lt;/li&gt;&lt;li&gt;我是第三行文本&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;table{margin:0 auto;}</code></pre><p>方法二：转为行内元素</p><p>子元素设为行内元素inline-block，然后父元素设置 text-align:center</p><h4 id="3）浮云元素"><a href="#3）浮云元素" class="headerlink" title="(3）浮云元素"></a>(3）浮云元素</h4><p>宽度不固定时</p><p>给父元素设置 float:left; position:relative; 和 left:50%;<br>子元素设置 float:left; position:relative; 和 left: -50%;<br>宽度固定时<br>width:500px ;<br>position:relative;<br>left:50%;<br>margin-left: -250px;</p><h4 id="4-绝对定位元素"><a href="#4-绝对定位元素" class="headerlink" title="(4)绝对定位元素"></a>(4)绝对定位元素</h4><p>position: absolute;<br>margin: 0 auto;<br>left: 0;<br>right: 0;</p><h2 id="2、垂直居中"><a href="#2、垂直居中" class="headerlink" title="2、垂直居中"></a>2、垂直居中</h2><h3 id="2-1、父元素高度确定"><a href="#2-1、父元素高度确定" class="headerlink" title="2.1、父元素高度确定"></a>2.1、父元素高度确定</h3><p>####（1）单行文本<br>父元素的 height 和 line-height 高度一致</p><pre><code>height:100px;line-height:100px;</code></pre><h4 id="（2）块级元素"><a href="#（2）块级元素" class="headerlink" title="（2）块级元素"></a>（2）块级元素</h4><p>父元素高度固定时<br>父元素的height与line-height值相同<br>子元素设置：<br>vertical-align:middle;<br>display:inline|inline-block;</p><p>父元素高度不固定时<br>父元素的padding-top和padding-bottom一样</p><h1 id="四、布局示例"><a href="#四、布局示例" class="headerlink" title="四、布局示例"></a>四、布局示例</h1><h2 id="1、三栏，左右固定，中间自适应"><a href="#1、三栏，左右固定，中间自适应" class="headerlink" title="1、三栏，左右固定，中间自适应"></a>1、三栏，左右固定，中间自适应</h2><p>float<br>左、右浮动，设置left和rign即可，但中间内容撑高后会有问题<br>position: fixd<br>左右绝对定位<br>flex<br>中间flex:1自适应<br>tab<br>表格<br>grid<br>栅格，兼容性太高<br>dispaly: grid</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css选择器</title>
      <link href="/2020/04/19/style/css/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2020/04/19/style/css/%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h1 id="1、-元素"><a href="#1、-元素" class="headerlink" title="1、    元素"></a>1、    元素</h1><p>元素标签名称<br>如html p a img</p><h1 id="2、-ID"><a href="#2、-ID" class="headerlink" title="2、    ID"></a>2、    ID</h1><p>#intro {font-weight:bold;}</p><h1 id="3、-单类"><a href="#3、-单类" class="headerlink" title="3、    单类"></a>3、    单类</h1><p>.important {color:red;}</p><h1 id="4、-多类"><a href="#4、-多类" class="headerlink" title="4、    多类"></a>4、    多类</h1><p>某个元素上有多个class类时<br>.important.warning {background:silver;}</p><h1 id="5、-分组"><a href="#5、-分组" class="headerlink" title="5、    分组"></a>5、    分组</h1><p>逗号分隔多个选择器<br>h2, p {color:gray;}</p><h1 id="6、-后代"><a href="#6、-后代" class="headerlink" title="6、    后代"></a>6、    后代</h1><p>所有子孙后辈<br>h1 em {color:red;}</p><h1 id="7、-子"><a href="#7、-子" class="headerlink" title="7、    子"></a>7、    子</h1><p>子辈<br>h1 &gt; strong {color:red;}</p><h1 id="8、-相邻"><a href="#8、-相邻" class="headerlink" title="8、    相邻"></a>8、    相邻</h1><p>有相同的父元素<br>紧接在另一个元素后<br>h1 + p {margin-top:50px;}</p><h1 id="9、-属性"><a href="#9、-属性" class="headerlink" title="9、    属性"></a>9、    属性</h1><h2 id="按是否有属性选择"><a href="#按是否有属性选择" class="headerlink" title="按是否有属性选择"></a>按是否有属性选择</h2><p>a[href] {color:red;}<br>*[title] {color:red;}<br>所有有title属性的标签<br>a[href][title] {color:red;}<br>同时有href title属性的a标签</p><h2 id="按属性值选择"><a href="#按属性值选择" class="headerlink" title="按属性值选择"></a>按属性值选择</h2><p>p[class=”important warning”] {color: red;}<br>指定属性具体值的p标签<br>p[class~=”important”] {color: red;}<br>class 属性中包含 important 的元素<br>[abc^=”def”]<br>值以 “def” 开头<br>[abc$=”def”]<br>值以 “def” 结尾<br>[abc*=”def”]<br>值中包含子串 “def”<br>*[lang|=”en”] {color: red;}<br>等于 en 或以 en- 开头的</p><h1 id="10、-通配符"><a href="#10、-通配符" class="headerlink" title="10、    通配符"></a>10、    通配符</h1><p>应用所有元素</p><ul><li>{margin:0; padding:0;}</li><li>可以与任何元素匹配<h1 id="11、-伪类"><a href="#11、-伪类" class="headerlink" title="11、    伪类"></a>11、    伪类</h1><h2 id="a"><a href="#a" class="headerlink" title="a"></a>a</h2>a:link {color: #FF0000}    /* 未访问的链接 <em>/<br>a:visited {color: #00FF00}    /</em> 已访问的链接 <em>/<br>a:hover {color: #FF00FF}    /</em> 鼠标移动到链接上 <em>/<br>a:active {color: #0000FF}    /</em> 选定的链接 */<h2 id="first-child"><a href="#first-child" class="headerlink" title=":first-child"></a>:first-child</h2>第一个子元素<br>p:first-child {font-weight: bold;}<h2 id="lang"><a href="#lang" class="headerlink" title=":lang"></a>:lang</h2><h2 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h2><h2 id="hover"><a href="#hover" class="headerlink" title=":hover"></a>:hover</h2><h2 id="p-first-of-type"><a href="#p-first-of-type" class="headerlink" title="p:first-of-type"></a>p:first-of-type</h2>属于其父元素的首个 <p> 元素的每个 <p> 元素<h2 id="p-last-of-type"><a href="#p-last-of-type" class="headerlink" title="p:last-of-type"></a>p:last-of-type</h2>属于其父元素的最后 <p> 元素的每个 <p> 元素<h2 id="p-only-of-type"><a href="#p-only-of-type" class="headerlink" title="p:only-of-type"></a>p:only-of-type</h2>属于其父元素唯一的 <p> 元素的每个 <p> 元素<h2 id="p-only-child"><a href="#p-only-child" class="headerlink" title="p:only-child"></a>p:only-child</h2>属于其父元素的唯一子元素的每个 <p> 元素<h2 id="p-last-child"><a href="#p-last-child" class="headerlink" title="p:last-child"></a>p:last-child</h2>属于其父元素最后一个子元素的每个 <p> 元素<h2 id="p-nth-child-2"><a href="#p-nth-child-2" class="headerlink" title="p:nth-child(2)"></a>p:nth-child(2)</h2>属于其父元素的第二个子元素的每个 <p> 元素<h2 id="p-nth-last-child-2"><a href="#p-nth-last-child-2" class="headerlink" title="p:nth-last-child(2)"></a>p:nth-last-child(2)</h2>同上，倒数<h2 id="p-nth-of-type-2"><a href="#p-nth-of-type-2" class="headerlink" title="p:nth-of-type(2)"></a>p:nth-of-type(2)</h2>属于其父元素第二个元素的每个 <p> 元素<h2 id="p-nth-last-of-type-2"><a href="#p-nth-last-of-type-2" class="headerlink" title="p:nth-last-of-type(2)"></a>p:nth-last-of-type(2)</h2>同上，倒数<h2 id="root"><a href="#root" class="headerlink" title=":root"></a>:root</h2>根元素<h2 id="p-empty"><a href="#p-empty" class="headerlink" title="p:empty"></a>p:empty</h2>没有子元素的的每个 <p> 元素<h2 id="news-target"><a href="#news-target" class="headerlink" title="#news:target"></a>#news:target</h2>当前活动的 #news 元素。<h2 id="input-enabled"><a href="#input-enabled" class="headerlink" title="input:enabled##"></a>input:enabled##</h2>每个启用的 <input><h2 id="input-disabled"><a href="#input-disabled" class="headerlink" title="input:disabled"></a>input:disabled</h2>每个禁用的 <input><h2 id="input-checked"><a href="#input-checked" class="headerlink" title="input:checked"></a>input:checked</h2>每个被选中的 <input><h2 id="not-p"><a href="#not-p" class="headerlink" title=":not(p)"></a>:not(p)</h2>非 <p> 元素的每个元素<h2 id="selection"><a href="#selection" class="headerlink" title="::selection"></a>::selection</h2>被用户选取的元素部分<h1 id="12、-伪元素"><a href="#12、-伪元素" class="headerlink" title="12、    伪元素"></a>12、    伪元素</h1><h2 id="first-line"><a href="#first-line" class="headerlink" title=":first-line"></a>:first-line</h2>向文本的首行设置特殊样式<br>只能用于块级元素<h2 id="first-letter"><a href="#first-letter" class="headerlink" title=":first-letter"></a>:first-letter</h2>向文本的首字母设置特殊样式<br>只能用于块级元素<h2 id="before"><a href="#before" class="headerlink" title=":before"></a>:before</h2>在元素的内容前面插入新内容<br>h1:before<br>{<br>content:url(logo.gif);<br>}<h2 id="after"><a href="#after" class="headerlink" title=":after"></a>:after</h2>在元素的内容之后插入新内容<br>h1:after<br>{<br>content:url(logo.gif);<br>}<h1 id="13、-组合选择"><a href="#13、-组合选择" class="headerlink" title="13、    组合选择"></a>13、    组合选择</h1>p.important {color:red;}<br>table.company td &gt; p<br>html &gt; body table + ul {margin-top:20px;}</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端H5开发</title>
      <link href="/2020/04/19/style/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
      <url>/2020/04/19/style/%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、移动端滚动插件"><a href="#一、移动端滚动插件" class="headerlink" title="一、移动端滚动插件"></a>一、移动端滚动插件</h1><p><a href="https://ustbhuangyi.github.io/better-scroll/doc/" target="_blank" rel="noopener">better-scroll</a></p><p>#二、移动端弹性适配<br><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">lib-flexible</a><br>淘宝弹性布局方案，UI按照iphone6尺寸（750px）进行设计,<br>html的font-size:75px；所以，项目中配置rem基准为75px;<br>配合webpack打包，自动将px转化成rem，使用px2rem-loader</p><p>#三、VSCode插件cssrem<br>输入px单位自动转为rem单位</p><p>“cssrem.rootFontSize”:75<br>// root font-size (unit: px), 默认为: 16；<br>“cssrem.fixedDigits” px转rem小数点最大长度，默认：6；<br>“cssrem.autoRemovePrefixZero” 自动移除0开头的前缀，默认：true；<br>“css.remoteStyleSheets”: []</p><p>#四、解决点击延迟<br>fastclick<br>从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间，因为它想看看你是不是要进行双击（double tap）操作。</p><p>#五、开发调试工具<br><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">vConsole</a><br>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>#六、Webpack跨域</p><pre><code>dev: {env: require(&#39;./dev.env&#39;),port: 8080,autoOpenBrowser: true,assetsSubDirectory: &#39;static&#39;,assetsPublicPath: &#39;/&#39;,cssSourceMap: false,proxyTable: {&#39;/api&#39;: {target: &#39;http://www.abc.com&#39;, //目标接口域名changeOrigin: true, //是否跨域secure: false, // 允许https请求pathRewrite: {&#39;^/api&#39;: &#39;/api&#39; //重写接口}}}</code></pre><p>#七、Meta标签设置</p><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />// 页面窗口自动调整到设备宽度，并禁止用户缩放页面<meta name="renderer" content="webkit" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">// 告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame.<meta name="keywords" content="新闻 新闻中心 事实派 新闻频道,时事报道"><meta name="description" content="腾讯新闻，事实派。新闻中心,包含有时政新闻、国内新闻、国际新闻、社会新闻、时事评论、新闻图片、新闻专题、新闻论坛、军事、历史、的专业时事报道门户网站"><meta name="author" content="skeetershi" /><meta content="yes" name="apple-mobile-web-app-capable">// 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 。<meta content="black" name="apple-mobile-web-app-status-bar-style">// 设置苹果工具栏颜色。<meta content="telephone=no，email=no" name="format-detection">// 忽略页面中的数字识别为电话，忽略email识别。<meta name="screen-orientation" content="portrait">// uc强制竖屏<meta name="full-screen" content="yes">// UC强制全屏<meta name="x5-orientation" content="portrait">// QQ强制竖屏<meta name="x5-fullscreen" content="true">// QQ强制全屏<meta name="renderer" content="webkit">//默认webkit内核<meta name="renderer" content="ie-comp">//默认IE兼容模式<meta name="renderer" content="ie-stand">//默认IE标准模式// 指定双核浏览器默认以何种方式渲染页面。PS：360浏览器支持<p>#八、video播放问题<br>自动播放属性autoplay，无法正常播放视频<br>解决方案：添加muted属性，静音</p><p>安卓浏览器播放系统会自动接管<br>解决方案：webkit-playsinline playsinline</p><p>有时候无法直接播放或有卡顿<br>解决方案：启用H5内核H5播放器 x5-video-player-type=”h5”</p><p>无法铺满整个屏幕<br>解决方案：style=”width= 100%; height=100%; object-fit: fill”</p><p>监听视频是否结束<br>myVideo.addEventListener(‘ended’, function () {<br>alert(“视频结束啦”);<br>}, false);</p><p>参考资料<br><a href="https://www.jianshu.com/p/b20174503d3e" target="_blank" rel="noopener">https://www.jianshu.com/p/b20174503d3e</a><br><a href="https://www.cnblogs.com/baihuaxiu/p/6654496.html" target="_blank" rel="noopener">https://www.cnblogs.com/baihuaxiu/p/6654496.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>响应式</title>
      <link href="/2020/04/19/style/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
      <url>/2020/04/19/style/%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实现响应式方式"><a href="#一、实现响应式方式" class="headerlink" title="一、实现响应式方式"></a>一、实现响应式方式</h1><p>什么是响应式<br>同一个网站兼容不同的大小的设备。如PC端、移动端（平板、横屏、竖排）的显示风格。</p><h2 id="1、头部导入"><a href="#1、头部导入" class="headerlink" title="1、头部导入"></a>1、头部导入</h2><p>在link标签上用media属性指定媒体查询的内容，条件符合的则引入样式文件。</p><pre><code>&lt;link media=&quot;screen and (min-width:620px)&quot;href=&quot;../css/index-large-screen.css&quot;type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;</code></pre><h2 id="2、使用-media媒体查询"><a href="#2、使用-media媒体查询" class="headerlink" title="2、使用@media媒体查询"></a>2、使用@media媒体查询</h2><pre><code>/*媒体查询，宽屏*/@media screen and (min-width: 620px) {.header-wrapper .nav-list li{float: left;}.more-list button{display: none;}}/*媒体查询，窄屏*/@media screen and (max-width: 620px) {/*对展开列表定位、设置背景颜色*/.header-wrapper .nav-collapse{position: relative;top:40px;background-color: #3c3f41;}/*列表第一个元素除外列表上边距为1.2px*/.header-wrapper .nav-list li:not(:first-child){margin-top: 1.2px;}.more-list button{display:block;}}</code></pre><h2 id="3、使用BootStrap"><a href="#3、使用BootStrap" class="headerlink" title="3、使用BootStrap"></a>3、使用BootStrap</h2><pre><code>&lt;head&gt;&lt;link href=&quot;css/bootstrap.css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;/head&gt;</code></pre><h2 id="4、使用em或rem做尺寸单位"><a href="#4、使用em或rem做尺寸单位" class="headerlink" title="4、使用em或rem做尺寸单位"></a>4、使用em或rem做尺寸单位</h2><p>用于文字大小的响应和弹性布局。</p><h2 id="5、禁止页面缩放"><a href="#5、禁止页面缩放" class="headerlink" title="5、禁止页面缩放"></a>5、禁止页面缩放</h2><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, width=device-width, maximum-scale=1, user-scalable=no&quot; /&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/04/19/web/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/19/web/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>面向对象模式</p><p>四人帮设计模式</p><p>MVC模式</p><p>MVVM模式</p><p>模块化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/04/19/web/js/%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/19/web/js/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><h2 id="1、链表结构"><a href="#1、链表结构" class="headerlink" title="1、链表结构"></a>1、链表结构</h2><p>递归算法</p><h2 id="2、二叉树结构"><a href="#2、二叉树结构" class="headerlink" title="2、二叉树结构"></a>2、二叉树结构</h2><p>二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。</p><h2 id="3、堆"><a href="#3、堆" class="headerlink" title="3、堆"></a>3、堆</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（<strong>如果有的话） 的元</strong>素，则称此完全二叉树为最大堆。</p><p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p><p>最大堆的根结点中的元素在整个堆中是最大的；</p><p>最小堆的根结点中的元素在整个堆中是最小的。</p><h2 id="4、哈弗曼树"><a href="#4、哈弗曼树" class="headerlink" title="4、哈弗曼树"></a>4、哈弗曼树</h2><p>定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p><h2 id="5、哈希表"><a href="#5、哈希表" class="headerlink" title="5、哈希表"></a>5、哈希表</h2><p>是根据关键码值 (Key-Value) 而直接进行访问的数据结构。</p><h1 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h1><h2 id="2-1、排序算法"><a href="#2-1、排序算法" class="headerlink" title="2.1、排序算法"></a>2.1、排序算法</h2><p>冒泡排序</p><h2 id="2-2、随机算法"><a href="#2-2、随机算法" class="headerlink" title="2.2、随机算法"></a>2.2、随机算法</h2><h2 id="2-3、贪心算法"><a href="#2-3、贪心算法" class="headerlink" title="2.3、贪心算法"></a>2.3、贪心算法</h2><pre><code class="javascript">function(){}</code></pre><p>#<br>一、快速排序<br>快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想—-分治法也确实实用。快速排序是一种既不浪费空间又可以快一点的排序算法。</p><h1 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h1><p>先从数列中取出一个数作为“基准”。<br>分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。<br>再对左右区间重复第二步，直到各区间只有一个数。</p><h1 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h1><pre><code class="javascript">var quickSort = function(arr) {if (arr.length &lt;= 1) { return arr; }var pivotIndex = Math.floor(arr.length / 2); //基准位置（理论上可任意选取）var pivot = arr.splice(pivotIndex, 1)[0]; //基准数var left = [];var right = [];for (var i = 0; i &lt; arr.length; i++){if (arr[i] &lt; pivot) {left.push(arr[i]);} else {right.push(arr[i]);}}return quickSort(left).concat([pivot], quickSort(right));//链接左数组、基准数构成的数组、右数组};</code></pre><p>#<br>一、选择排序<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是O(n2) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。通俗来说就是你们中间谁最小谁就出列，站到队列的最后边，然后继续对着剩余的无序数组说你们中间谁最小谁就出列，站到队列的最后边，一直到最后一个，继续站到最后边，这样数组就有了顺序，从小到大。</p><h1 id="二、步骤-1"><a href="#二、步骤-1" class="headerlink" title="二、步骤"></a>二、步骤</h1><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><h1 id="三、实现-1"><a href="#三、实现-1" class="headerlink" title="三、实现"></a>三、实现</h1><pre><code class="javascript">function selectionSort(arr) {var len = arr.length;var minIndex, temp;for (var i = 0; i &lt; len - 1; i++) {minIndex = i;for (var j = i + 1; j &lt; len; j++) {if (arr[j] &lt; arr[minIndex]) { // 寻找最小的数minIndex = j; // 将最小数的索引保存}}temp = arr[i];arr[i] = arr[minIndex];arr[minIndex] = temp;}return arr;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2020/04/19/web/js/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/04/19/web/js/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DOM事件类"><a href="#一、DOM事件类" class="headerlink" title="一、DOM事件类"></a>一、DOM事件类</h1><h2 id="1、DOM事件的级别"><a href="#1、DOM事件的级别" class="headerlink" title="1、DOM事件的级别"></a>1、DOM事件的级别</h2><h3 id="DOM0"><a href="#DOM0" class="headerlink" title="DOM0"></a>DOM0</h3><p>element.onclick=function(){}</p><h3 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h3><p>element.addEventListener(‘click’,function(){},false)<br>参数3<br>false 默认 表示冒泡<br>true 表示捕获</p><h3 id="DOM3"><a href="#DOM3" class="headerlink" title="DOM3"></a>DOM3</h3><p>element.addEventListener(‘keyup’,function(){},false)<br>比2增加了很多事件，如键盘鼠</p><h2 id="2、DOM事件的模型"><a href="#2、DOM事件的模型" class="headerlink" title="2、DOM事件的模型"></a>2、DOM事件的模型</h2><p>冒泡 从下向上<br>捕获 从上向下</p><h2 id="3、DOM事件流"><a href="#3、DOM事件流" class="headerlink" title="3、DOM事件流"></a>3、DOM事件流</h2><p>事件 -&gt; 捕获 -&gt; 目标元素 -&gt; 冒泡</p><h2 id="4、捕获流程"><a href="#4、捕获流程" class="headerlink" title="4、捕获流程"></a>4、捕获流程</h2><p>window document html body … 目标元素 然后返回向上冒泡</p><h2 id="5、Event对象常见应用"><a href="#5、Event对象常见应用" class="headerlink" title="5、Event对象常见应用"></a>5、Event对象常见应用</h2><p>event.preventDefault()<br>阻止默认行为，如a标签可以阻止跳转行为<br>event.stopPropagation()<br>阻止冒泡行为，子元素可以阻止父元素事件<br>event.stopImmediatePropagation()<br>优生级阻止<br>event.currentTarget<br>父包含多个子时，父的click事件时，currentTarget指父元素<br>event.target<br>元素</p><h2 id="6、自定义事件"><a href="#6、自定义事件" class="headerlink" title="6、自定义事件"></a>6、自定义事件</h2><p>var eve = new Event(‘custome’,[object option])<br>ev.addEventListener(‘custome’,function(){<br>console.log(‘custome’)<br>})<br>ev.dispathEvent(eve) //事件触发</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Loadash工具库</title>
      <link href="/2020/04/19/tool/loadash/"/>
      <url>/2020/04/19/tool/loadash/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p><a href="https://www.lodashjs.com" target="_blank" rel="noopener">Loadash</a></p><p>Loadash是一个一致性、模块化、高性能的 JavaScript 实用工具库。<br>通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。</p><pre><code class="shell">npm i --save lodash</code></pre><pre><code>// Load the full build.var _ = require(&#39;lodash&#39;);// Load the core build.var _ = require(&#39;lodash/core&#39;);// Load the FP build for immutable auto-curried iteratee-first data-last methods.var fp = require(&#39;lodash/fp&#39;);// Load method categories.var array = require(&#39;lodash/array&#39;);var object = require(&#39;lodash/fp/object&#39;);// Cherry-pick methods for smaller browserify/rollup/webpack bundles.var at = require(&#39;lodash/at&#39;);var curryN = require(&#39;lodash/fp/curryN&#39;);</code></pre><h1 id="二、函数使用"><a href="#二、函数使用" class="headerlink" title="二、函数使用"></a>二、函数使用</h1><h2 id="1、限制操作频率-debounced"><a href="#1、限制操作频率-debounced" class="headerlink" title="1、限制操作频率 debounced"></a>1、限制操作频率 debounced</h2><p>该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。</p><pre><code>_.debounce(function () {var vm = thisif (this.question.indexOf(&#39;?&#39;) === -1) {vm.answer = &#39;Questions usually contain a question mark. ;-)&#39;return}vm.answer = &#39;Thinking...&#39;axios.get(&#39;https://yesno.wtf/api&#39;).then(function (response) {vm.answer = _.capitalize(response.data.answer)}).catch(function (error) {vm.answer = &#39;Error! Could not reach the API. &#39; + error})},// 这是我们为用户停止输入等待的毫秒数500)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>taro框架</title>
      <link href="/2020/04/19/node/express/"/>
      <url>/2020/04/19/node/express/</url>
      
        <content type="html"><![CDATA[<p>npm install express –save</p><p>hello world示例</p><pre><code>const express = require(&#39;express&#39;)const app = express()app.get(&#39;/&#39;, function (req, res) {res.send(&#39;Hello World!&#39;)})app.listen(3000, function () {console.log(&#39;Example app listening on port 3000!&#39;)})</code></pre><p>提供静态文件访问</p><pre><code>app.use(express.static(&#39;public&#39;))app.use(&#39;/static&#39;, express.static(&#39;public&#39;)app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))</code></pre><p>路由</p><pre><code>app.route(&#39;/book&#39;).get(function (req, res) {res.send(&#39;Get a random book&#39;)}).post(function (req, res) {res.send(&#39;Add a book&#39;)}).put(function (req, res) {res.send(&#39;Update the book&#39;)}</code></pre><p>方法<br>app.get()<br>app.post()<br>app.put()<br>app.patch()<br>app.delete()<br>app.all()</p><p>路径<br>可以是字符串，字符串模式或正则表达式。</p><p>‘/ab?cd’ 匹配acd并abcd<br>‘/ab+cd’ 匹配abcd，abbcd，abbbcd等等<br>‘/ab<em>cd’ 匹配abcd，abxcd，abRANDOMcd，ab123cd等<br>/.</em>fly$/ 匹配butterfly和dragonfly，但不butterflyman，dragonflyman等</p><p>‘/users/:userId/books/:bookId’ 使用路由参数定义路由</p><p>响应方法</p><pre><code>app.get(&#39;/example/b&#39;, function (req, res, next) {console.log(&#39;the response will be sent by the next function ...&#39;)next()}, function (req, res) {res.send(&#39;Hello from B!&#39;)})</code></pre><p>res.download() 提示要下载的文件。<br>res.end() 结束响应过程。<br>res.json（） 发送JSON响应。<br>res.jsonp（） 用JSONP支持发送JSON响应。<br>res.redirect（） 重定向请求。<br>res.render（） 呈现视图模板。<br>res.send（） 发送各种类型的响应。<br>res.sendFile（） 以八位字节流的形式发送文件。<br>res.sendStatus（） 设置响应状态代码并将其字符串表示形式作为响应主体发送。</p><p>中间件</p><pre><code>var router = express.Router()// middleware that is specific to this routerrouter.use(function timeLog (req, res, next) {console.log(&#39;Time: &#39;, Date.now())next()})</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs开发框架</title>
      <link href="/2020/04/19/node/node/"/>
      <url>/2020/04/19/node/node/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Express"><a href="#一-Express" class="headerlink" title="一 Express"></a>一 Express</h1><p>Express 是一个简洁而灵活的 node.js Web 应用框架, 提供一系列强大特性帮助你创建各种 Web 应用。<br>Express 不对 node.js 已有的特性进行二次抽象，只是在它之上扩展了 Web 应用所需的功能。<br>丰富的 HTTP 工具以及来自 Connect 框架的中间件随取随用，创建强健、友好的 API 变得快速又简单。</p><h1 id="二、KNEX"><a href="#二、KNEX" class="headerlink" title="二、KNEX"></a>二、<a href="https://knexjs.org" target="_blank" rel="noopener">KNEX</a></h1><p>基于nodejs的面向未来的框架</p><h1 id="三、Koa"><a href="#三、Koa" class="headerlink" title="三、Koa"></a>三、<a href="https://koa.bootcss.com" target="_blank" rel="noopener">Koa</a></h1><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa2</title>
      <link href="/2020/04/19/node/koa2/"/>
      <url>/2020/04/19/node/koa2/</url>
      
        <content type="html"><![CDATA[<p>k<br>oa-router</p><p>koa-gentrator</p><p>npm i -g koa-genaritor</p><p>koa-genaritor -e project</p><p>cd project</p><p>npm i</p><p>npm run dev</p><p>ctx.cookies.set()</p><p>mongodb<br>非关系型数据库<br>brew install mongodb<br>mongod<br>mongodb://localhost:27017</p><p>mongoose<br>数据库模型化<br>npm install mongoose<br><a href="http://mongoose.shujuwajue.com" target="_blank" rel="noopener">http://mongoose.shujuwajue.com</a><br><a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a></p><p>RoBo 3T 可视化工具<br>robomongo.org/download</p><p>redis<br>非关系型数据库<br>内存缓存数据<br>数据可持久化<br>用于存储服务器端session</p><p>brew install redis<br>brew services start redis<br>redis-server /usr/local/etc/redis.conf</p><p>koa-sesion<br>npm i koa-genric-session koa-redis</p><p>e.target.querySelecter(‘.class’).className</p><p>1、 pm2需要全局安装<br>npm install -g pm2<br>2、进入项目根目录<br>2.1 启动进程/应用 pm2 start bin/www 或 pm2 start app.js</p><p>2.2 重命名进程/应用 pm2 start app.js –name wb123</p><p>2.3 添加进程/应用 watch pm2 start bin/www –watch</p><p>2.4 结束进程/应用 pm2 stop www</p><p>2.5 结束所有进程/应用 pm2 stop all</p><p>2.6 删除进程/应用 pm2 delete www</p><p>2.7 删除所有进程/应用 pm2 delete all</p><p>2.8 列出所有进程/应用 pm2 list</p><p>2.9 查看某个进程/应用具体情况 pm2 describe www</p><p>2.10 查看进程/应用的资源消耗情况 pm2 monit</p><p>2.11 查看pm2的日志 pm2 logs</p><p>2.12 若要查看某个进程/应用的日志,使用 pm2 logs www</p><p>2.13 重新启动进程/应用 pm2 restart www</p><p>2.14 重新启动所有进程/应用 pm2 restart all</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> koa2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue SSR</title>
      <link href="/2020/04/19/web/vue/vuessr/"/>
      <url>/2020/04/19/web/vue/vuessr/</url>
      
        <content type="html"><![CDATA[<h1 id="一、vue-ssr-服务端渲染"><a href="#一、vue-ssr-服务端渲染" class="headerlink" title="一、vue ssr 服务端渲染"></a>一、vue ssr 服务端渲染</h1><p>只能在 Node.js 中使用</p><p><a href="https://ssr.vuejs.org/zh/guide/" target="_blank" rel="noopener">官网</a></p><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><pre><code>npm install vue vue-server-renderer --save</code></pre><h2 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h2><pre><code class="javascript">const Vue = require(&#39;vue&#39;)const app = new Vue({template: `&lt;div&gt;Hello World&lt;/div&gt;`})const renderer = require(&#39;vue-server-renderer&#39;).createRenderer()renderer.renderToString(app, (err, html) =&gt; {if (err) throw errconsole.log(html)// =&gt; &lt;div data-server-rendered=&quot;true&quot;&gt;Hello World&lt;/div&gt;})renderer.renderToString(app).then(html =&gt; {console.log(html)}).catch(err =&gt; {console.error(err)})</code></pre><h2 id="3、服务端"><a href="#3、服务端" class="headerlink" title="3、服务端"></a>3、服务端</h2><pre><code>npm install express --save</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt框架</title>
      <link href="/2020/04/19/web/vue/nuxt/"/>
      <url>/2020/04/19/web/vue/nuxt/</url>
      
        <content type="html"><![CDATA[<h1 id="一、nuxt-js"><a href="#一、nuxt-js" class="headerlink" title="一、nuxt.js"></a>一、nuxt.js</h1><p>vue ssr框架<br>支持vue2 vue-router vuex vue-meta<br><a href="https://zh.nuxtjs.org" target="_blank" rel="noopener">官网</a><br><a href="https://github.com/nuxt-community/koa-template" target="_blank" rel="noopener">示例</a></p><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><pre><code>npm i -g npxnpx create-nuxt-app project</code></pre><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>mounted方式不在ssr中渲染，改用asyncData()<br>fetch()用于提交vuex数据</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nuxt </tag>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack4</title>
      <link href="/2020/04/19/tool/webpack4/"/>
      <url>/2020/04/19/tool/webpack4/</url>
      
        <content type="html"><![CDATA[<p>// Webpack</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 安装<br>// npm install webpack webpack-dev-server react react-dom babel babel-core babel-loader –save-dev<br>// open-browser-webpack-plugin html-webpack-plugin<br>// 命令<br>webpack<br>// 在开发环境构建一次<br>webpack -d<br>// 构建并生成源代码映射文件<br>webpack -p<br>// 在生产环境构建，压缩、混淆代码，移除无用代码<br>webpack –watch<br>// 快速增量构建，可和其他参数同用<br>webpack-dev-server –devtool –progress<br>webpack –display-error-details –colors –watch</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 加载器 style-loader css-loader url-loader babel-loader sass-loader file-loader<br>/**————————————————————————————————————————– */<br>// jsx<br>// 用于加载.js或.jsx文件，支持react的jsx语法、ES6语法<br>// npm install react react-dom babel babel-core babel-loader babel-preset-react babel-preset-es2015 –save-dev<br>loaders:[<br>{<br>test: /.js[x]?$/,<br>exclude: /node_modules/,<br>loader: ‘babel-loader?presets[]=es2015&amp;presets[]=react’,<br>},<br>]<br>loaders:[<br>{<br>test: /.js[x]?$/,<br>exclude: /node_modules/,<br>loader: ‘babel-loader’,<br>query: {<br>presets: [‘es2015’, ‘react’]<br>}<br>},<br>]</p><p>/**————————————————————————————————————————– */<br>// Image<br>// 用于加载图片文件，限制大小为8192字节<br>// npm install url-loader –save-dev<br>loaders:[<br>{ test: /.(png|jpg)$/, loader: ‘url-loader?limit=8192’ }<br>]<br>// js设置图片源地址<br>var img1 = document.createElement(“img”);<br>img1.src = require(“./small.png”);<br>document.body.appendChild(img1);</p><p>// jsx设置图片源地址<br><img src="src/images/apple.jpg"></img></p><p>/**————————————————————————————————————————– */<br>// css<br>// 用于加载.css样式文件<br>// npm install css-loader style-loader –save-dev<br>loaders:[<br>{ test: /.css$/, loader: ‘style-loader!css-loader’ },<br>]</p><p>/**————————————————————————————————————————– */<br>// CSS Module<br>// css 模块加载器<br>loaders:[<br>{ test: /.js[x]?$/, exclude: /node_modules/, loader: ‘babel-loader?presets[]=es2015&amp;presets[]=react’ },<br>{ test: /.css$/, loader: ‘style-loader!css-loader?modules’ }<br>]<br>// .css文件中定义样式<br>// 使用css modules加载，默认CSS是本地作用域，即这里的.h1只能jsx里的组件标签有效<br>// 使用:global()取消，这里的.h2就对全局有效<br>.h1 {<br>color:red;<br>}<br>:global(.h2) {<br>color: blue;<br>}<br>// .jsx文件<br>// .h1是本地的，这里有效<br>// .h2是全局的，这里有效</p><div><h1 className={style.h1}>Hello World</h1><h2 className="h2">Hello Webpack</h2></div>// .html文件// .h1是本地的，这里无效// .h2是全局的，这里有效<html><body><h1 class="h1">Hello World</h1><h2 class="h2">Hello Webpack</h2><div id="example"></div><script src="./bundle.js"></script></body></html><p>/**————————————————————————————————————————– */<br>// bundle-loader 参见下面的代码分割<br>// 分割代码块， a.js将编译成1.bundle.js<br>// main.js<br>// Now a.js is requested, it will be bundled into another file<br>var load = require(‘bundle-loader!./a.js’);<br>// To wait until a.js is available (and get the exports)<br>// you need to async wait for it.<br>load(function(file) {<br>document.open();<br>document.write(‘<h1>‘ + file + ‘</h1>‘);<br>document.close();<br>});</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 插件<br>// UglifyJs 压缩js<br>// 压缩打包后的bundle.js文件，变成无格式无空格的一行<br>var webpack = require(‘webpack’);<br>var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;</p><p>module.exports = {<br>entry: ‘./main.js’,<br>output: {<br>filename: ‘bundle.js’<br>},<br>plugins: [<br>new uglifyJsPlugin({<br>compress: {<br>warnings: false<br>}<br>})<br>]<br>}<br>/**————————————————————————————————————————– */<br>// html-webpack-plugin 和 open-browser-webpack-plugin<br>// html-webpack-plugin 用于自动生成 <code>index.html</code> 页面<br>// open-browser-webpack-plugin 会在 Webpack 运行后会自动打开一个新的浏览器页面<br>var HtmlwebpackPlugin = require(‘html-webpack-plugin’);<br>var OpenBrowserPlugin = require(‘open-browser-webpack-plugin’);</p><p>module.exports = {<br>entry: ‘./main.js’,<br>output: {<br>filename: ‘bundle.js’<br>},<br>plugins: [<br>new HtmlwebpackPlugin({<br>title: ‘Webpack-demos’,<br>filename: ‘index.html’<br>}),<br>new OpenBrowserPlugin({<br>url: ‘<a href="http://localhost:8080&#39;">http://localhost:8080&#39;</a><br>})<br>]<br>};</p><p>/**————————————————————————————————————————– */<br>// CommonsChunkPlugin<br>// 将多个文件使用的常用代码块提取到一个单独文件<br>// main1.jsx<br>var React = require(‘react’);<br>var ReactDOM = require(‘react-dom’);<br>ReactDOM.render(</p><h1>Hello World</h1>,document.getElementById('a'));// main2.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render(<h2>Hello Webpack</h2>,document.getElementById('b'));<p>// 两个jsx文件作为入口文件，编译成bundle1.js和bundle2.js<br>// 这两个文件存有差异部分，相同部分将提取到init.js中<br>var CommonsChunkPlugin = require(“webpack/lib/optimize/CommonsChunkPlugin”);<br>module.exports = {<br>entry: {<br>bundle1: ‘./main1.jsx’,<br>bundle2: ‘./main2.jsx’<br>},<br>output: {<br>filename: ‘[name].js’<br>},<br>plugins: [<br>new CommonsChunkPlugin(‘init.js’)<br>]<br>}<br>/<strong>————————————————————————————————————————– */<br>// extract-text-webpack-plugin<br>// 独立出css样式,通过<link>引入<br>// $ npm install extract-text-webpack-plugin –save-dev<br>var ExtractTextPlugin = require(“extract-text-webpack-plugin”);<br>module.exports = {<br>// …省略各种代码<br>module: {<br>loaders: [<br>{test: /.js$/, loader: “babel”},<br>{test: /.css$/, loader: ExtractTextPlugin.extract(“style-loader”, “css-loader”)},<br>{test: /.(jpg|png|svg)$/, loader: “url?limit=8192”},<br>{test: /.scss$/, loader: “style!css!sass”}<br>]<br>},<br>plugins: [<br>new webpack.optimize.CommonsChunkPlugin(‘common.js’),<br>new ExtractTextPlugin(“[name].css”)<br>]<br>}<br>/</strong>————————————————————————————————————————– */<br>// HotModuleReplacementPlugin<br>// 热服务模块插件， 参见下面的 Hot Module<br>var webpack = require(‘webpack’);<br>var path = require(‘path’);<br>module.exports = {<br>entry: [<br>‘webpack/hot/dev-server’,<br>‘webpack-dev-server/client?<a href="http://localhost:8080&#39;">http://localhost:8080&#39;</a>,<br>‘./index.js’<br>],<br>plugins: [<br>new webpack.HotModuleReplacementPlugin()<br>],<br>}</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// Hot Module<br>// 以热模式响应启用服务，并将服务嵌入到bundle中<br>// 修改代码不需要重启服务即可在网页上更新<br>webpack-dev-server –hot –inline</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 代码分割<br>// 大型WebApp将所有代码放在一个文件中不是很有效率<br>// Webpack可以将代码分割成多个块，且可以按需要加载相应块<br>// require.ensure定义分割点，./a.js从bunle.js中分离出来并编译成一个单独的块文件<br>// main.js<br>require.ensure([‘./a’], function(require) {<br>var content = require(‘./a’);<br>document.open();<br>document.write(‘<h1>‘ + content + ‘</h1>‘);<br>document.close();<br>});<br>// 编译结果为两个文件<code>bundle.js</code> and <code>1.bundle.js</code><br>// a.js<br>module.exports = ‘Hello World’;</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 环境标签<br>// 让某些代码只在开发环境中运行<br>document.write(‘<h1>Hello World</h1>‘);<br>if (<strong>DEV</strong>) {<br>document.write(new Date());<br>}</p><p>// 自定义插件devFlagPlugin<br>// process.env.DEBUG 获取环境变量，赋值给<strong>DEV</strong>标签<br>var webpack = require(‘webpack’);<br>var devFlagPlugin = new webpack.DefinePlugin({<br><strong>DEV</strong>: JSON.stringify(JSON.parse(process.env.DEBUG || ‘false’))<br>});<br>module.exports = {<br>entry: ‘./main.js’,<br>output: {<br>filename: ‘bundle.js’<br>},<br>plugins: [devFlagPlugin]<br>};</p><p>// 通过环境变量DEBUG来控制运行开发环境标签中的代码<br>// # Linux &amp; Mac<br>env DEBUG=true<br>webpack-dev-server</p><p>// # Windows<br>$ set DEBUG=true<br>$ webpack-dev-server</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 全局变量<br>// data.js<br>var data = ‘Hello World’;</p><p>// 使用external来调用全局变量<br>externals: {<br>‘data’: ‘data’<br>}</p><p>// require(‘data’)在这里就是全局变量了<br>// main.jsx<br>var data = require(‘data’);<br>var React = require(‘react’);<br>var ReactDOM = require(‘react-dom’);<br>ReactDOM.render(</p><h1>{data}</h1>,document.body);<p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 示例<br>// 创建项目<br>mkdir reactApp<br>cd reactApp/<br>npm init // 生成 package.json<br>// 依赖包及插件<br>npm install react –save<br>npm install react-dom –save<br>npm install babel-core –save-dev<br>npm install babel-loader –save-dev<br>npm install babel-preset-react<br>npm install babel-preset-es2015<br>// 创建文件<br>mkdir build<br>touch index.html<br>touch App.jsx<br>touch main.js<br>touch webpack.config.js</p><p>// webpack.config.js<br>var config = {<br>entry: ‘./main.js’,<br>output: {<br>path:’./dist’,<br>filename: ‘index.js’,<br>},<br>resolve: {<br>extensions: [‘’, ‘.js’, ‘.jsx’]<br>},<br>devServer: {<br>inline: true,<br>port: 7777<br>},<br>module: {<br>loaders: [ {<br>test: /.js|jsx$/,<br>exclude: /node_modules/,<br>loader: ‘babel’,<br>query: {<br>presets: [‘es2015’, ‘react’]<br>}<br>}]<br>}<br>}<br>module.exports = config;</p><p>// package.json<br>{<br>“name”: “runoob-react-test”,<br>“version”: “1.0.0”,<br>“description”: “react 测试”,<br>“author”: “”,<br>“license”: “ISC”,</p><p>“main”: “index.js”,<br>“scripts”: {<br>“start”: “webpack-dev-server –hot”<br>},<br>“dependencies”: {<br>“react”: “^0.14.7”,<br>“react-dom”: “^0.14.7”<br>}<br>}<br>// App.jsx<br>import React from ‘react’;<br>class App extends React.Component {<br>render() {<br>return (</p><div>Hello World!!!<br />欢迎来到教程学习！！！</div>);}}export default App;// main.jsimport React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(<App />, document.getElementById('app'))// index.html<html><head><meta charset = "UTF-8"><title>React App - 菜鸟教程(runoob.com)</title><meta name="generator" content="Hexo 4.2.0"></head><body><div id = "app"></div><script src = "index.js"></script></body></html><p>{/<em>启动服务</em>/}<br>npm start –hot<br>{/<em>访问页面</em>/}<br><a href="http://localhost:7777/" target="_blank" rel="noopener">http://localhost:7777/</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>taro框架</title>
      <link href="/2020/04/19/web/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/taro/"/>
      <url>/2020/04/19/web/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/taro/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">Taro官方源</a><br><a href="https://github.com/NervJS/awesome-taro" target="_blank" rel="noopener">学习资源汇总</a></p><p>Taro 是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。</p><p>使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等）运行的代码。</p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p><a href="https://www.jianshu.com/p/9d3318f7f219" target="_blank" rel="noopener">https://www.jianshu.com/p/9d3318f7f219</a><br><a href="https://www.jianshu.com/p/e0cd7a9e40e9" target="_blank" rel="noopener">https://www.jianshu.com/p/e0cd7a9e40e9</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> 跨端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> taro </tag>
            
            <tag> react </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpvue框架</title>
      <link href="/2020/04/19/web/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/mpvue/"/>
      <url>/2020/04/19/web/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/mpvue/</url>
      
        <content type="html"><![CDATA[<p>基于vue开发微信小程序和h5<br><a href="http://mpvue.com/change-log/" target="_blank" rel="noopener">http://mpvue.com/change-log/</a><br><a href="https://github.com/F-loat/mpvue-router-patch" target="_blank" rel="noopener">https://github.com/F-loat/mpvue-router-patch</a></p><h2 id="编译H5"><a href="#编译H5" class="headerlink" title="编译H5"></a>编译H5</h2><h3 id="打包处理"><a href="#打包处理" class="headerlink" title="打包处理"></a>打包处理</h3><p>通过vue init webpack my-project 生成h5项目<br>将build目录、config目录复制过来并在名称后加H5<br>将src下的main.js和App.vue复制过来并在名称后加H5<br>在indexH5.html中加移动端meta<br>修改buildH5、configH5中的相关目录路径<br>对比package.json，安装h5需要的包<br>修改.postcssrc.js，判断wx还是h5加载不同的css插件<br>在.babelrc中增加h5的相关插件<br></p><h3 id="单位处理"><a href="#单位处理" class="headerlink" title="单位处理"></a>单位处理</h3><p>UI稿一般使用750px宽设计，直接在样式中使用px单位<br>wx使用px2rpx-loader自动转为微信小程序单位rpx<br>h5使用px2rem-loader自动转为移动端自适应单位rem<br>修改build/utils.js中的px2rpxLoader的rpxUnit转换率为1<br>修改buildH5/utils.js增加px2remLoader</p><h3 id="路由处理"><a href="#路由处理" class="headerlink" title="路由处理"></a>路由处理</h3><p>统一使用方法<br>通过this.$router跳转<br>通过this.$route获取当前路由信息<br>统一路由地址<br>根据pages目录，如/pages/index/main<br>wx使用mpvue-router-patch<br>不需要配置统一配置路由<br>h5使用vue-router<br>需要配置router.js</p><h3 id="存储处理"><a href="#存储处理" class="headerlink" title="存储处理"></a>存储处理</h3><p>mpvue支持vuex，但wx使用时需要挂载到Vue原型上来使用</p><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p>不使用wx.request，统一使用flyio</p><h3 id="wx-API处理"><a href="#wx-API处理" class="headerlink" title="wx API处理"></a>wx API处理</h3><p>尽量不使用<br>根据是否有window对象判断是wx还是h5，分别处理</p><h3 id="wx-组件处理"><a href="#wx-组件处理" class="headerlink" title="wx 组件处理"></a>wx 组件处理</h3><p>tabbar h5使用自定义组件，wx在app.json中定义小程序的tabbar<br>swiper 使用第三方的，如swiper.js<br>video 尽量使用h5原生的一些属性值</p><p>对于微信的scroll-view需要配置<br>::-webkit-scrollbar{<br>width: 0;<br>height: 0;<br>color: transparent;<br>}</p><p>h5使用better-scroll，因为监听不到原生的scrollTop</p><p>小程序 API 自动补全和类型提示，可以通过引入 wechat-mp-types 这个 TS 声明库来实现。<br>自动补全，代码片段的话也有 mpvue-snippets 库。<br>组件封装，我正在带一个叫 mpvue-starter 的库。里面正在做 weui 组件 + vue + 小程序组件的封装。<br>加入 mpex 包， 为你的小程序开发助力</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> 跨端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> mpvue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ui框架</title>
      <link href="/2020/04/19/web/ui/ui%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/04/19/web/ui/ui%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、妹子-UI"><a href="#一、妹子-UI" class="headerlink" title="一、妹子 UI"></a>一、妹子 UI</h1><p>HTML5 跨屏前端框架<br>web、mobile<br>jquery、react<br><a href="http://amazeui.org" target="_blank" rel="noopener">http://amazeui.org</a></p><h1 id="二、Ant-Design-系列"><a href="#二、Ant-Design-系列" class="headerlink" title="二、Ant Design 系列"></a>二、Ant Design 系列</h1><p>阿里蚂蚁出品<br>适合企业级中后台产品。<br>React、Angular、Vue</p><h3 id="0、Ant-Design-React"><a href="#0、Ant-Design-React" class="headerlink" title="0、Ant Design React"></a>0、<a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design React</a></h3><h3 id="1、Ant-Design-Pro"><a href="#1、Ant-Design-Pro" class="headerlink" title="1、Ant Design Pro"></a>1、<a href="https://pro.ant.design/docs/getting-started-cn" target="_blank" rel="noopener">Ant Design Pro</a></h3><p>中后台管理控制台 antd升级版<br>更多的功能组件及业务模块</p><h3 id="2、Ant-Design-Mobile"><a href="#2、Ant-Design-Mobile" class="headerlink" title="2、Ant Design Mobile"></a>2、<a href="https://mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design Mobile</a></h3><p>用于移动端</p><h3 id="3、Ant-Design-VUE"><a href="#3、Ant-Design-VUE" class="headerlink" title="3、Ant Design VUE"></a>3、<a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design VUE</a></h3><p>Ant Design 的 Vue 实现，开发和服务于企业级后台产品。</p><h3 id="4、Ant-Design-Landing"><a href="#4、Ant-Design-Landing" class="headerlink" title="4、Ant Design Landing"></a>4、Ant Design Landing</h3><p>首页模板</p><h3 id="5、AntV"><a href="#5、AntV" class="headerlink" title="5、AntV"></a>5、<a href="https://antv.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">AntV</a></h3><p>数据可视化</p><p>G2 是以数据驱动，具有高度的易用性和扩展性的可视化图形语法。<br>G6 是一套便捷、动态和富有交互的流程图和关系分析的图表库。<br>F2 是一套为移动而生，开箱即用的可视化解决方案。<br>L7 是一套高性能，高渲染质量的地理空间数据可视化框架。</p><h3 id="6、Umi-React-应用开发框架"><a href="#6、Umi-React-应用开发框架" class="headerlink" title="6、Umi - React 应用开发框架"></a>6、<a href="https://umijs.org/zh/guide/" target="_blank" rel="noopener">Umi - React 应用开发框架</a></h3><h3 id="7、dva-数据流前端框架"><a href="#7、dva-数据流前端框架" class="headerlink" title="7、dva - 数据流前端框架"></a>7、<a href="https://dvajs.com/guide/getting-started.html" target="_blank" rel="noopener">dva - 数据流前端框架</a></h3><h3 id="8、Ant-Motion-设计动效"><a href="#8、Ant-Motion-设计动效" class="headerlink" title="8、Ant Motion - 设计动效"></a>8、<a href="https://motion.ant.design" target="_blank" rel="noopener">Ant Motion - 设计动效</a></h3><h1 id="三、Element-UI"><a href="#三、Element-UI" class="headerlink" title="三、Element UI"></a>三、<a href="http://element-cn.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">Element UI</a></h1><p>饿了么出品<br>采用 Vue 2.0 作为基础框架实现的组件库</p><h1 id="四、iView-UI"><a href="#四、iView-UI" class="headerlink" title="四、iView UI"></a>四、iView UI</h1><p>基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品</p><h1 id="五、Mint-UI"><a href="#五、Mint-UI" class="headerlink" title="五、Mint UI"></a>五、Mint UI</h1><p>基于 Vue.js 的移动端组件库</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> ui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js方法</title>
      <link href="/2020/04/19/web/js/%E5%87%BD%E6%95%B0/"/>
      <url>/2020/04/19/web/js/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>//全局函数<br>    Number() //把对象的值转换为数字。<br>        Number(false) //0<br>        Number(true) //1<br>        d = new Date();<br>        Number(d) //1404568027739<br>        Number(“3.14”) //3.14<br>        Number(“”) //0<br>        Number(“99 88”) //NaN<br>    String() //把对象的值转换为字符串。<br>        String(x)<br>        String(100 + 23)<br>        String(false)<br>        String(Date())</p><pre><code>escape() //对字符串进行编码。    escape(&quot;Need tips? Visit W3Cschool!&quot;) //Need % 20 tips % 3 F % 20 Visit % 20 W3Cschool % 21unescape() //对由 escape() 编码的字符串进行解码。    unescape(escape(&quot;Need tips? Visit W3Cschool!&quot;)) //Need tips ? Visit W3Cschool!encodeURI() //把字符串编码为 URI。    var uri = &quot;my test.php?name=ståle&amp;car=saab&quot;;    encodeURI(uri) //my % 20 test.php ? name = st % C3 % A5le &amp; car = saabdecodeURI() //解码某个编码的 URI。    var uri = &quot;my test.php?name=ståle&amp;car=saab&quot;;    decodeURI(uri) //my test.php ? name = ståle &amp; car = saabencodeURIComponent() //把字符串编码为 URI 组件。    var uri = &quot;http://w3cschool.cc/my test.asp?name=ståle&amp;car=saab&quot;;    var uri_encode = encodeURIComponent(uri); //http % 3 A % 2 F % 2 Fw3cschool.cc % 2 Fmy % 20 test.asp % 3 Fname % 3 Dst % C3 % A5le % 26 car % 3 DsaabdecodeURIComponent() //解码一个编码的 URI 组件。    decodeURIComponent(uri_encode) //http: //w3cschool.cc/my test.asp?name=ståle&amp;car=saabeval() //计算 JavaScript 字符串， 并把它作为脚本代码来执行。    eval(&quot;x=10;y=20;document.write(x*y)&quot;); //200    eval(&quot;2+2&quot;) //4    eval(x + 17) //27parseFloat() //解析一个字符串， 并返回一个浮点数。    parseFloat(&quot;10&quot;) //10    parseFloat(&quot;10.33&quot;) //10.33    parseFloat(&quot;34 45 66&quot;) //34    parseFloat(&quot; 60 &quot;) //60 开头和结尾的空格是允许的    parseFloat(&quot;40 years&quot;) //40    parseFloat(&quot;He was 40&quot;) //NaN 字符串的第一个字符不能被转换为数字， 那么 parseFloat() 会返回 NaN。parseInt() //解析一个字符串， 并返回一个整数。    parseInt(&quot;10.33&quot;) //10    parseInt(&quot;10&quot;, 8) //8    parseInt(&quot;0x10&quot;) //16    parseInt(&quot;10&quot;, 16) //16isFinite() //检查某个值是否为有穷大的数。isNaN() //检查某个值是否是数字。</code></pre><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//Object 对象<br>    // 构造函数<br>        var o = new Object();<br>        var o1 = { a: 1 };<br>        var o2 = new Object(o1);<br>        o1 === o2 // true<br>        new Object(123) instanceof Number // true</p><pre><code>    // 部署在Object对象本身    Object.print = function (o) { console.log(o) };    var o = new Object();    Object.print(o) // Object    // 部署在Object.prototype对象，所有实例对象共享    Object.prototype.print = function () { console.log(this) };    var o = new Object();    o.print() // Object// Object()    // 如果参数是原始类型的值，Object方法返回对应的包装对象的实例        Object() // 返回一个空对象        Object() instanceof Object // true        Object(undefined) // 返回一个空对象        Object(undefined) instanceof Object // true        Object(null) // 返回一个空对象        Object(null) instanceof Object // true        Object(1) // 等同于 new Number(1)        Object(1) instanceof Object // true        Object(1) instanceof Number // true        Object(&#39;foo&#39;) // 等同于 new String(&#39;foo&#39;)        Object(&#39;foo&#39;) instanceof Object // true        Object(&#39;foo&#39;) instanceof String // true        Object(true) // 等同于 new Boolean(true)        Object(true) instanceof Object // true        Object(true) instanceof Boolean // true    // 如果Object方法的参数是一个对象，它总是返回原对象。        var arr = [];        Object(arr) // 返回原数组        Object(arr) === arr // true        var obj = {};        Object(obj) // 返回原对象        Object(obj) === obj // true        var fn = function () { };        Object(fn) // 返回原函数        Object(fn) === fn // true        function isObject(value) {            return value === Object(value);        }        isObject([]) // true        isObject(true) // false// 遍历属性方法    // Object.keys() ，Object.getOwnPropertyNames() 前者返回可枚举的属性；后者可以返回不可枚举的属性名。    var o = {        p1: 123,        p2: 456    };    Object.keys(o) // [&quot;p1&quot;, &quot;p2&quot;]    Object.getOwnPropertyNames(o) // [&quot;p1&quot;, &quot;p2&quot;]    var a = [&quot;Hello&quot;, &quot;World&quot;];    Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]    Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]  数组length属性是不可枚举的属性// 属性模型方法    Object.getOwnPropertyDescriptor() //获取某个属性的attributes对象。    Object.defineProperty() //通过attributes对象，定义某个属性。    Object.defineProperties() //通过attributes对象，定义多个属性。    Object.getOwnPropertyNames() //返回直接定义在某个对象上面的全部属性的名称。// 控制对象状态方法    Object.preventExtensions() //防止对象扩展。    Object.isExtensible() //判断对象是否可扩展。    Object.seal() //禁止对象配置。    Object.isSealed() //判断一个对象是否可配置。    Object.freeze() //冻结一个对象。    Object.isFrozen() //判断一个对象是否被冻结。// 原型链方法    Object.create() //生成一个新对象，并该对象的原型。    Object.getPrototypeOf() //获取对象的Prototype对象。// Object.prototype.valueOf() 返回当前对象对应的值    var o = new Object();    o.valueOf() === o // true    var o = new Object();    1 + o // &quot;1[object Object]&quot; JavaScript会默认调用valueOf()方法    var o = new Object();    o.valueOf = function () { //覆盖Object.prototype.valueOf        return 2;    };    1 + o // 3 // Object.prototype.toString() 返回一个对象的字符串形式，默认情况下返回类型字符串。    var o1 = new Object();    o1.toString() // &quot;[object Object]&quot; 可用来判断数据类型    var o2 = { a: 1 };    o2.toString() // &quot;[object Object]&quot;    var o = new Object();    o.toString = function () { //当对象用于字符串加法时，会自动调用toString方法        return &#39;hello&#39;;    };    o + &#39; &#39; + &#39;world&#39; // &quot;hello world&quot;    [1, 2, 3].toString() // &quot;1,2,3&quot;    &#39;123&#39;.toString() // &quot;123&quot;    (function () {        return 123;    }).toString()    // &quot;function () {    //   return 123;    // }&quot;        (new Date()).toString() // &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;    // Object.prototype.toString.call(value) //实例对象可能会自定义toString方法        Object.prototype.toString.call(2) // &quot;[object Number]&quot;        Object.prototype.toString.call(&#39;&#39;) // &quot;[object String]&quot;        Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;        Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;        Object.prototype.toString.call(null) // &quot;[object Null]&quot;        Object.prototype.toString.call(Math) // &quot;[object Math]&quot;        Object.prototype.toString.call({}) // &quot;[object Object]&quot;        Object.prototype.toString.call([]) // &quot;[object Array]&quot;        // arguments对象：返回[object Arguments]。        // 函数：返回[object Function]。        // Error对象：返回[object Error]。        // Date对象：返回[object Date]。        // RegExp对象：返回[object RegExp]。        // 其他对象：返回[object Object]。        var type = function (o) {            var s = Object.prototype.toString.call(o);            return s.match(/\[object (.*?)\]/)[1].toLowerCase();        };        type({}); // &quot;object&quot;        type([]); // &quot;array&quot;        type(5); // &quot;number&quot;        type(null); // &quot;null&quot;        type(); // &quot;undefined&quot;        type(/abcd/); // &quot;regex&quot;        type(new Date()); // &quot;date&quot;</code></pre><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//String 对象<br>    charAt() //返回指定索引位置的字符<br>    charCodeAt() //返回指定索引位置字符的 Unicode 值<br>    concat() //连接两个或多个字符串，返回连接后的字符串<br>    fromCharCode() //将 Unicode 转换为字符串<br>    indexOf() //返回字符串中检索指定字符第一次出现的位置<br>    lastIndexOf() //返回字符串中检索指定字符最后一次出现的位置<br>    localeCompare() //用本地特定的顺序来比较两个字符串<br>    match() //找到一个或多个正则表达式的匹配,支持正则表达式<br>    replace() //替换与正则表达式匹配的子串,支持正则表达式<br>        “Visit w3cschool”.replace(/microsoft/i, “w3cschool”)<br>    search() //检索与正则表达式相匹配的值,支持正则表达式<br>        “Visit w3cschool”.search(/w3cschool/i)<br>    slice() //提取字符串的片断，并在新的字符串中返回被提取的部分<br>    split() //把字符串分割为子字符串数组,支持正则表达式<br>    substr() //从起始索引号提取字符串中指定数目的字符<br>    substring() //提取字符串中两个指定的索引号之间的字符<br>    toLocaleLowerCase() //根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射<br>    toLocaleUpperCase() //根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射<br>    toLowerCase() //把字符串转换为小写<br>    toString() //返回字符串对象值<br>        (100 + 23).toString() //“123”<br>        false.toString() //“false”<br>        Date().toString() //Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)<br>    toUpperCase() //把字符串转换为大写<br>    trim() //移除字符串首尾空白<br>    valueOf() //返回某个字符串对象的原始值</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//Array 对象 <a href="http://www.w3school.com.cn/jsref/jsref_obj_array.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jsref/jsref_obj_array.asp</a><br>    // 构造函数<br>        var arr = new Array(2);<br>        arr.length // 2<br>        arr // [ undefined x 2 ]</p><pre><code>    // 无参数时，返回一个空数组        new Array() // []    // 单个正整数参数，表示返回的新数组的长度        new Array(1) // [ undefined ]        new Array(2) // [ undefined x 2 ]    // 非正整数的数值作为参数，会报错        new Array(3.2) // RangeError: Invalid array length        new Array(-3) // RangeError: Invalid array length    // 单个非正整数参数（比如字符串、布尔值、对象等），则该参数是返回的新数组的成员        new Array(&#39;abc&#39;) // [&#39;abc&#39;]        new Array([1]) // [Array[1]]    // 多参数时，所有参数都是返回的新数组的成员        new Array(1, 2) // [1, 2]        new Array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]Array.isArray() // 判断一个值是否为数组    var a = [1, 2, 3];    typeof a // &quot;object&quot;  typeof运算符只能显示数组的类型是Object    Array.isArray(a) // trueconcat() //连接两个或更多的数组，并返回结果，结果是个“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用。    var hege = [&quot;Cecilie&quot;, &quot;Lone&quot;];    var stale = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];    var kai = [&quot;Robin&quot;];    var children = hege.concat(stale, kai);    //Cecilie,Lone,Emil,Tobias,Linus,Robin    [].concat.call({ a: 1 }, { b: 2 })    // [{ a: 1 }, { b: 2 }]    [].concat.call({ a: 1 }, [2])    // [{a: 1}, 2]    [2].concat({ a: 1 })    // [2, {a: 1}]every() //检测数值元素的每个元素是否都符合条件。    var ages = [32, 33, 16, 40];    function checkAdult(age, index, arr) {        return age &gt;= 18;    }    function myFunction() {        document.getElementById(&quot;demo&quot;).innerHTML = ages.every(checkAdult);    }    //falsesome() //检测数组元素中是否有元素符合指定条件。    var ages = [3, 10, 18, 20];    function checkAdult(age, index, arr) {        return age &gt;= 18;    }    function myFunction() {        document.getElementById(&quot;demo&quot;).innerHTML = ages.some(checkAdult);    }    //truefilter() //检测数值元素，并返回符合条件所有元素的数组。该方法不会改变原数组。    var ages = [32, 33, 16, 40];    function checkAdult(age) {        return age &gt;= 18;    }    function myFunction() {        document.getElementById(&quot;demo&quot;).innerHTML = ages.filter(checkAdult);    }    //32,33,40    //可以接受三个参数    [1, 2, 3, 4, 5].filter(function (elem, index, arr) {        return index % 2 === 0;    });    // [1, 3, 5]    // 接受第二个参数指定测试函数所在的上下文对象this    var Obj = function () {        this.MAX = 3;    };    var myFilter = function (item) {        if (item &gt; this.MAX) {            return true;        }    };    var arr = [2, 8, 3, 4, 1, 3, 2, 9];    arr.filter(myFilter, new Obj())    // [8, 4, 9]indexOf() //搜索数组中的元素，并返回它第一次出现时所在的位置。如果没有出现则返回-1。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    var a = fruits.indexOf(&quot;Apple&quot;);    //2    //接受第二个参数，表示搜索的开始位置。    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].indexOf(&#39;a&#39;, 1) // -1    //null不适用    [NaN].indexOf(NaN) // -1    [NaN].lastIndexOf(NaN) // -1lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    var a = fruits.lastIndexOf(&quot;Apple&quot;);    //2join() //把数组的所有元素放入一个字符串。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    var energy = fruits.join();    //Banana,Orange,Apple,Mango    [undefined, null].join(&#39;#&#39;)    // &#39;#&#39;    [&#39;a&#39;,, &#39;b&#39;].join(&#39;-&#39;)    // &#39;a--b&#39;    Array.prototype.join.call(&#39;hello&#39;, &#39;-&#39;)    // &quot;h-e-l-l-o&quot;    var obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, length: 2 };    Array.prototype.join.call(obj, &#39;-&#39;)    // &#39;a-b&#39;toString() //把数组转换为字符串，并返回结果。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.toString();    //Banana,Orange,Apple,Mangoshift() //删除数组的第一个元素并返回该元素，会改变原数组。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.shift() //&#39;Banana&#39;    fruits //Orange,Apple,Mango    // 可用来遍历并清空一个数组    var list = [1, 2, 3, 4, 5, 6];    var item;    while (item = list.shift()) {        console.log(item);    }    list // []unshift() //向数组的开头添加一个或更多元素，并返回新的长度，会改变原数组。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.unshift(&quot;Lemon&quot;, &quot;Pineapple&quot;);    fruits //Lemon,Pineapple,Banana,Orange,Apple,Mangopop() //删除数组的最后一个元素并返回删除后的元素。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.pop();    fruits //Banana,Orange,Apple    [].pop() // undefinedpush() //向数组的末尾添加一个或更多元素，并返回新的长度。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.push(&quot;Kiwi&quot;)    //Banana,Orange,Apple,Mango,Kiwi    apply()        var a = [1, 2, 3,], b = [4, 5, 6];        Array.prototype.push.apply(a, b)        //或者        a.push.apply(a, b)        // 上面两种写法等同于        a.push(4, 5, 6)        a // [1, 2, 3, 4, 5, 6]    call()        var a = { a: 1 };        [].push.call(a, 2);        a // {a:1, 0:2, length: 1}        [].push.call(a, [3]);        a // {a:1, 0:2, 1:[3], length: 2}reverse() //反转数组的元素顺序，会改变原数组。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.reverse();    //Mango,Apple,Orange,Bananasort() //对数组的元素进行排序。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.sort();    //Apple,Banana,Mango,Orange    var points = [40, 100, 1, 5, 25, 10];    points.sort(function(a, b) { return a - b });    //1,5,10,25,40,100    [        { name: &quot;张三&quot;, age: 30 },        { name: &quot;李四&quot;, age: 24 },        { name: &quot;王五&quot;, age: 28 }    ].sort(function (o1, o2) {        return o1.age - o2.age;    })    // [    //   { name: &quot;李四&quot;, age: 24 },    //   { name: &quot;王五&quot;, age: 28  },    //   { name: &quot;张三&quot;, age: 30 }    // ]返回值大于0，表示第一个元素排在第二个元素后面slice() //选取数组的的一部分，并返回一个新数组，原数组不变。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    var citrus = fruits.slice(1, 3);    citrus//Orange,Lemon    //slice没有参数，实际上等于返回一个原数组的拷贝。    //参数值大于数组成员的个数，或者第二个参数小于第一个参数，则返回空数组。    var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];    a.slice(4) // []    a.slice(2, 1) // []     //将类似数组的对象转为真正的数组。    Array.prototype.slice.call({ 0: &#39;a&#39;, 1: &#39;b&#39;, length: 2 })    // [&#39;a&#39;, &#39;b&#39;]    Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));    Array.prototype.slice.call(arguments);splice() //从数组中添加或删除元素。参数1表示起始索引，参数2表示删除的成员个数，之后的参数为添加的成员,该方法会改变原数组    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);    //Banana,Orange,Lemon,Kiwi,Apple,Mango    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.splice(2, 1, &quot;Lemon&quot;, &quot;Kiwi&quot;);    //Banana,Orange,Lemon,Kiwi,Mango    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    fruits.splice(2, 2);    //Banana,OrangevalueOf() //返回数组对象的原始值。    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];    var v = fruits.valueOf(); // [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]    var a = [1, 2, 3];    a.valueOf(); // [1, 2, 3] 返回数组本身map() //通过指定函数处理数组的每个元素，并返回处理后的数组，不改变原数组。    // map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身    var numbers = [4, 9, 16, 25];    function myFunction() {        x = document.getElementById(&quot;demo&quot;);        x.innerHTML = numbers.map(Math.sqrt);    }    //2,3,4,5    var numbers = [65, 44, 12, 4];    function multiplyArrayElement(num) {        return num * document.getElementById(&quot;multiplyWith&quot;).value;    }    function myFunction() {        document.getElementById(&quot;demo&quot;).innerHTML = numbers.map(multiplyArrayElement);    }    //通过函数的call方法间接遍历字符串的每个字符    var upper = function (x) {        return x.toUpperCase();    };    [].map.call(&#39;abc&#39;, upper)    // [ &#39;A&#39;, &#39;B&#39;, &#39;C&#39; ]    // 或者    &#39;abc&#39;.split(&#39;&#39;).map(upper)    // [ &#39;A&#39;, &#39;B&#39;, &#39;C&#39; ]    //map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象    var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];    [1, 2].map(function (e) {        return this[e];    }, arr)    // [&#39;b&#39;, &#39;c&#39;] 将回调函数内部的this对象，指向arr数组forEach() //遍历数组的所有成员,不返回值，只用来操作数据；    function log(element, index, array) {        console.log(&#39;[&#39; + index + &#39;] = &#39; + element);    }    [2, 5, 9].forEach(log);    // [0] = 2    // [1] = 5    // [2] = 9    var out = [];    //也可以接受第二个参数    [1, 2, 3].forEach(function (elem) {        this.push(elem * elem);    }, out);    out // [1, 4, 9]    //处理多层this    var obj = {        name: &#39;张三&#39;,        times: [1, 2, 3],        print: function () {            this.times.forEach(function (n) {                console.log(this.name);            }, this);        }    };    obj.print()    // 张三    // 张三    // 张三    //不可以中断执行，但会跳过数组的空位    [1, , 2].forEach(log)    // 2    // 3reduce() // 从左到右依次处理数组的每个成员，最终累计为一个值。reduceRight() //从右到左依次处理数组的每个成员，最终累计为一个值。    //接受以下四个参数:    // 累积变量，默认为数组的第一个成员    // 当前变量，默认为数组的第二个成员    // 当前位置（从0开始）    // 原数组    [1, 2, 3, 4, 5].reduce(function (x, y) {        console.log(x, y)        return x + y;    });    // 1 2    // 3 3    // 6 4    // 10 5    //最后结果：15    // 定义一个数组求和方法    Array.prototype.sum = function () {    return this.reduce(function (partial, value) {            return partial + value;        })    };    [3, 4, 5, 6, 10].sum()    // 28    // 第二参数可以指定累积变量初始值，处理空数组时尤其有用。    [1, 2, 3, 4, 5].reduce(function (x, y) {        return x + y;    }, 10);    // 25// 链式使用    var users = [        { name: &#39;tom&#39;, email: &#39;tom@example.com&#39; },        { name: &#39;peter&#39;, email: &#39;peter@example.com&#39; }    ];    users        .map(function (user) {            return user.email;        })        .filter(function (email) {            return /^t/.test(email);        })        .forEach(alert);    // 弹出tom@example.com</code></pre><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//JSON 对象<br>    parse() //JSON 字符串转换为 JavaScript 对象<br>        var text = ‘{ “employees” : [‘ + ‘{ “firstName”:”John” , “lastName”:”Doe” },’ + ‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ + ‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;<br>        var obj = JSON.parse(text);<br>        obj.employees[1].firstName<br>        JSON.parse(‘{“p”: 5}’, function(k, v) { if (k === ‘’) { return v; } return v * 2; });<br>    stringify() //将JavaScript对象转换为JSON字符串<br>        var str = { “name”: “菜鸟教程”, “site”: “<a href="http://www.runoob.com&quot;" target="_blank" rel="noopener">http://www.runoob.com&quot;</a> }<br>        str_pretty1 = JSON.stringify(str) //{ “name”: “菜鸟教程”, “site”: “<a href="http://www.runoob.com&quot;" target="_blank" rel="noopener">http://www.runoob.com&quot;</a> }<br>        str_pretty2 = JSON.stringify(str, null, 4) //使用四个空格缩进<br>        document.write(“<pre>" + str_pretty2 + "</pre>“); // pre 用于格式化输出 { “name”: “菜鸟教程”, “site”: “<a href="http://www.runoob.com&quot;" target="_blank" rel="noopener">http://www.runoob.com&quot;</a> }</p><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//Number 对象<br>    //属性<br>        Number.MAX_VALUE //可表示的最大的数。<br>            //1.7976931348623157e+308<br>        Number.MIN_VALUE //可表示的最小的数。<br>            //5e-324<br>        Number.NEGATIVE_INFINITY //负无穷大， 溢出时返回该值。<br>            //-Infinity<br>        Number.POSITIVE_INFINITY //正无穷大， 溢出时返回该值。<br>            //Infinity<br>        Number.NaN //非数字值,使用 isNaN() 全局函数来判断一个值是否是 NaN 值。</p><pre><code>//方法    toExponential(x) //把对象的值转换为指数计数法。        var num = 5.56789;        var n = num.toExponential() //5.56789e+0        var num = 5.56789;        var n = num.toExponential(3) //5.568e+0    toFixed(x) //把数字转换为字符串， 结果的小数点后有指定位数的数字。        var num = 5.56789;        var n = num.toFixed(2); //5.57        var num = 5.56789;        var n = num.toFixed(); //6    toPrecision(x) //把数字格式化为指定的长度。        var num = new Number(13.3714);        var n = num.toPrecision(2); //13    toString() //把数字转换为字符串， 使用指定的基数。    valueOf() //返回一个 Number 对象的基本数字值。</code></pre><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//Data 对象<br>    //创建<br>        Date() // 直接调用时，无论有无参数，都返回当前时间：”Tue Dec 01 2015 09:34:43 GMT+0800 (CST)”<br>        var d = new Date();// 当前日期和时间 Thu Sep 15 2016 19: 57: 12 GMT + 0800(中国标准时间)<br>        var d = new Date(1378218728000); // Tue Sep 03 2013 22:32:08 GMT+0800 (CST)<br>        var d = new Date(‘January 6, 2013’); // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)<br>        // 1970年1月2日的零时<br>        var Jan02_1970 = new Date(3600 * 24 * 1000);// Fri Jan 02 1970 08:00:00 GMT+0800 (CST)<br>        // 1969年12月31日的零时<br>        var Dec31_1969 = new Date(-3600 * 24 * 1000);// Wed Dec 31 1969 08:00:00 GMT+0800 (CST)<br>        var d = new Date(“October 13, 1975 11:13:00”)<br>        var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);<br>        var d = new Date(79, 5, 24)<br>        var d = new Date(79, 5, 24, 11, 33, 0)</p><pre><code>    new Date(&#39;2013-2-15&#39;)    new Date(&#39;2013/2/15&#39;)    new Date(&#39;02/15/2013&#39;)    new Date(&#39;2013-FEB-15&#39;)    new Date(&#39;FEB, 15, 2013&#39;)    new Date(&#39;FEB 15, 2013&#39;)    new Date(&#39;Feberuary, 15, 2013&#39;)    new Date(&#39;Feberuary 15, 2013&#39;)    new Date(&#39;15 Feb 2013&#39;)    new Date(&#39;15, Feberuary, 2013&#39;)    // Fri Feb 15 2013 00:00:00 GMT+0800 (CST)    new Date(2013, 0)    // Tue Jan 01 2013 00:00:00 GMT+0800 (CST)    new Date(2013, 0, 1)    // Tue Jan 01 2013 00:00:00 GMT+0800 (CST)    new Date(2013, 0, 1, 0)    // Tue Jan 01 2013 00:00:00 GMT+0800 (CST)    new Date(2013, 0, 1, 0, 0, 0, 0)    // Tue Jan 01 2013 00:00:00 GMT+0800 (CST)    // 超出正常范围会被自动折算    new Date(2013, 15)    // Tue Apr 01 2014 00:00:00 GMT+0800 (CST)    new Date(2013, 0, 0)    // Mon Dec 31 2012 00:00:00 GMT+0800 (CST)    //负数表示扣去的时间    new Date(2013, -1)    // Sat Dec 01 2012 00:00:00 GMT+0800 (CST)    new Date(2013, 0, -1)    // Sun Dec 30 2012 00:00:00 GMT+0800 (CST)// 查询    Date.now() // 1364026285194  返回当前距离1970年1月1日 00:00:00 UTC的毫秒数    Date.parse() //方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。        Date.parse(&#39;Aug 9, 1995&#39;)        // 返回807897600000，以下省略返回值        Date.parse(&#39;January 26, 2011 13:51:50&#39;)        Date.parse(&#39;Mon, 25 Dec 1995 13:30:00 GMT&#39;)        Date.parse(&#39;Mon, 25 Dec 1995 13:30:00 +0430&#39;)        Date.parse(&#39;2011-10-10&#39;)        Date.parse(&#39;2011-10-10T14:48:00&#39;)        Date.parse(&#39;xxx&#39;) // NaN    Date.UTC(2011, 0, 1, 2, 3, 4, 567) // 1293847384567 返回当前距离1970年1月1日 00:00:00 UTC的毫秒数    // GTM        getDate() //从 Date 对象返回一个月中的某一天(1~31)。        getDay() //从 Date 对象返回一周中的某一天(0~6)。        getYear() //返回距离1900的年数。        getFullYear() //从 Date 对象以四位数字返回年份。        getHours() //返回 Date 对象的小时(0~23)。        getMilliseconds() //返回 Date 对象的毫秒(0~999)。        getMinutes() //返回 Date 对象的分钟(0~59)。        getMonth() //从 Date 对象返回月份(0~11)。        getSeconds() //返回 Date 对象的秒数(0~59)。        getTime() //返回 1970 年 1 月 1 日至今的毫秒数。 1473940843507        getTimezoneOffset() //返回本地时间与格林威治标准时间(GMT) 的分钟差。        valueOf() //返回 Date 对象的原始值。    // UTC        UTC() //根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。        getUTCDate() //根据世界时从 Date 对象返回月中的一天(1~31)。        getUTCDay() //根据世界时从 Date 对象返回周中的一天(0~6)。        getUTCFullYear() //根据世界时从 Date 对象返回四位数的年份。        getUTCHours() //根据世界时返回 Date 对象的小时(0~23)。        getUTCMilliseconds() //根据世界时返回 Date 对象的毫秒(0~999)。        getUTCMinutes() //根据世界时返回 Date 对象的分钟(0~59)。        getUTCMonth() //根据世界时从 Date 对象返回月份(0~11)。        getUTCSeconds() //根据世界时返回 Date 对象的秒钟(0~59)。// 设置    // GTM        setDate() //设置 Date 对象中月的某一天(1~31)。            myDate.setDate(myDate.getDate() + 5); //5 天后的日期        setYear() //设置距离1900年的年数。        setFullYear() //设置 Date 对象中的年份（ 四位数字）。            myDate.setFullYear(2010, 0, 14);        setHours() //设置 Date 对象中的小时(0~23)。        setMilliseconds() //设置 Date 对象中的毫秒(0~999)。        setMinutes() //设置 Date 对象中的分钟(0~59)。        setMonth() //设置 Date 对象中月份(0~11)。        setSeconds() //设置 Date 对象中的秒钟(0~59)。        setTime() //以毫秒设置 Date 对象。    // UTC        setUTCDate() //根据世界时设置 Date 对象中月份的一天(1~31)。        setUTCFullYear() //根据世界时设置 Date 对象中的年份（ 四位数字）。        setUTCHours() //根据世界时设置 Date 对象中的小时(0~23)。        setUTCMilliseconds() //根据世界时设置 Date 对象中的毫秒(0~999)。        setUTCMinutes() //根据世界时设置 Date 对象中的分钟(0~59)。        setUTCMonth() //根据世界时设置 Date 对象中的月份(0~11)。        setUTCSeconds() //用于根据世界时(UTC) 设置指定时间的秒字段。// 转换    toDateString() //把 Date 对象的日期部分转换为字符串。        var d = new Date(2013, 0, 1);        d.toDateString() // &quot;Tue Jan 01 2013&quot;    toISOString() //使用 ISO 标准返回字符串的日期格式。        var d = new Date(2013, 0, 1);        d.toString()        // &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;        d.toISOString()        // &quot;2012-12-31T16:00:00.000Z&quot;    toJSON() //以 JSON 数据格式返回日期字符串。        var d = new Date(2013, 0, 1);        d.toJSON()        // &quot;2012-12-31T16:00:00.000Z&quot;        d.toISOString()        // &quot;2012-12-31T16:00:00.000Z&quot;    toLocaleDateString() //根据本地时间格式， 把 Date 对象的日期部分转换为字符串。        var d = new Date(2013, 0, 1);        d.toLocaleDateString()        // 中文版浏览器为&quot;2013年1月1日&quot;        // 英文版浏览器为&quot;1/1/2013&quot;    toLocaleTimeString() //根据本地时间格式， 把 Date 对象的时间部分转换为字符串。        var d = new Date(2013, 0, 1);        d.toLocaleTimeString()        // 中文版浏览器为&quot;上午12:00:00&quot;        // 英文版浏览器为&quot;12:00:00 AM&quot;    toLocaleString() //据本地时间格式， 把 Date 对象转换为字符串。    toString() //把 Date 对象转换为字符串。    toTimeString() //把 Date 对象的时间部分转换为字符串。        var d = new Date(2013, 0, 1);        d.toTimeString() // &quot;00:00:00 GMT+0800 (CST)&quot;    toUTCString() //根据世界时， 把 Date 对象转换为字符串。Thu, 15 Sep 2016 12: 01: 01 GMT        var d = new Date(2013, 0, 1);        d.toUTCString()        // &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;        d.toString()        // &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;// 示例    // 计算本年度还剩下多少天。        function leftDays() {            var today = new Date();            var endYear = new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999);            var msPerDay = 24 * 60 * 60 * 1000;            return Math.round((endYear.getTime() - today.getTime()) / msPerDay);        }</code></pre><p>////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// RegExp 对象<br>    // 语法<br>        // 定义<br>            var patt = new RegExp(pattern, modifiers);<br>            var patt = /pattern/modifiers<br>            var patt1 = new RegExp(“e”, i);<br>            var re = new RegExp(“\w+”);<br>            var re = /\w+/;<br>        // 修饰符<br>            i //执行对大小写不敏感的匹配。<br>            g //执行全局匹配（ 查找所有匹配而非在找到第一个匹配后停止）。<br>            m //执行多行匹配。<br>        //方括号<br>            [abc] //查找方括号之间的任何字符。<br>            [^abc] //查找任何不在方括号之间的字符。<br>            [0-9] //查找任何从 0 至 9 的数字。<br>            [a-z] //查找任何从小写 a 到小写 z 的字符。<br>            [A-Z] //查找任何从大写 A 到大写 Z 的字符。<br>            [A-z] //查找任何从大写 A 到小写 z 的字符。<br>            (red|blue|green) //查找任何指定的选项。<br>        //元字符<br>            . // 查找单个字符， 除了换行和行结束符。<br>            \w // 查找单词字符。<br>            \W // 查找非单词字符。<br>            \d // 查找数字。<br>            \D // 查找非数字字符。<br>            \s // 查找空白字符。<br>            \S // 查找非空白字符。<br>            \b // 匹配单词边界。<br>            \B // 匹配非单词边界。<br>            \0 // 查找 NUL 字符。<br>            \n // 查找换行符。<br>            \r // 查找回车符。<br>            \f // 查找换页符。<br>            \t // 查找制表符。<br>            \v // 查找垂直制表符。<br>            \xxx // 查找以八进制数 xxx 规定的字符。<br>            \xdd // 查找以十六进制数 dd 规定的字符。<br>            \uxxxx // 查找以十六进制数 xxxx 规定的 Unicode 字符。</p><pre><code>    // 量词        n+ //匹配任何包含至少一个 n 的字符串。        n* //匹配任何包含零个或多个 n 的字符串。        n? //匹配任何包含零个或一个 n 的字符串。        n{X} //匹配包含 X 个 n 的序列的字符串。        n{X,Y} //匹配包含 X 或 Y 个 n 的序列的字符串。        n{X,} //匹配包含至少 X 个 n 的序列的字符串。        n$ //匹配任何结尾为 n 的字符串。        ^n //匹配任何开头为 n 的字符串。        ?=n //匹配任何其后紧接指定字符串 n 的字符串。        ?!n //匹配任何其后没有紧接指定字符串 n 的字符串        ;// 方法    compile() //编译正则表达式。    exec() //检索字符串中指定的值。 返回找到的值， 并确定其位置。        var str = &quot;Hello world!&quot;;        var patt = /Hello/g;        var result = patt.exec(str);//Hello    test() //检索字符串中指定的值。 返回 true 或 false。        var str = &quot;Hello world!&quot;;        var patt = /Hello/g;        var result = patt.test(str);//true</code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步加载</title>
      <link href="/2020/04/19/web/js/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
      <url>/2020/04/19/web/js/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h1><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>只支持IE</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>创建script，插入到DOM中，加载完毕后callBack</p><h2 id="动态创建DOM方式"><a href="#动态创建DOM方式" class="headerlink" title="动态创建DOM方式"></a>动态创建DOM方式</h2><h2 id="按需异步载入js"><a href="#按需异步载入js" class="headerlink" title="按需异步载入js"></a>按需异步载入js</h2>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2020/04/19/web/js/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2020/04/19/web/js/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h1><p>协议，域名，端口相同，同源策略是一种安全协议。<br>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。<br>目的是防止某个文档或脚本从多个不同源装载。</p><h1 id="二、请求方法"><a href="#二、请求方法" class="headerlink" title="二、请求方法"></a>二、请求方法</h1><p>ajax<br>fetch<br>axios<br>fly</p><h1 id="三、什么是跨域"><a href="#三、什么是跨域" class="headerlink" title="三、什么是跨域"></a>三、什么是跨域</h1><p>发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。<br>即不满足同源策略时。</p><h1 id="四、-解决方案"><a href="#四、-解决方案" class="headerlink" title="四、 解决方案"></a>四、 解决方案</h1><h2 id="1、jsonp"><a href="#1、jsonp" class="headerlink" title="1、jsonp"></a>1、jsonp</h2><p>无法发送post请求，确定jsonp的请求是否失败并不容易</p><pre><code class="html">&lt;script&gt;$.ajax({    url:&quot;http://localhost:3000/users/userlist&quot;,    type:&quot;get&quot;,    dataType:&quot;jsonp&quot;,    success:function(e){        console.log(e);    }});&lt;/script&gt;</code></pre><h2 id="2、iframe-hash"><a href="#2、iframe-hash" class="headerlink" title="2、iframe (#hash)"></a>2、iframe (#hash)</h2><h2 id="3、window-name"><a href="#3、window-name" class="headerlink" title="3、window.name"></a>3、window.name</h2><h2 id="4、window-postMessage-h5"><a href="#4、window-postMessage-h5" class="headerlink" title="4、window.postMessage (h5)"></a>4、window.postMessage (h5)</h2><p>window.postMessage 的功能是允许程序员跨域在两个窗口/frames间发送数据信息。基本上，它就像是跨域的AJAX，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。</p><p><a href="https://www.html5tricks.com/html5-window-postmessage.html" target="_blank" rel="noopener">H5使用postMessage</a></p><pre><code class="html">&lt;script&gt;function run(){    var frm=document.getElementById(&quot;frm&quot;);    frm.contentWindow.postMessage(&quot;跨域请求信息：智学无忧IT教育&quot;,&quot;http://localhost:3000&quot;);    }&lt;/script&gt;</code></pre><pre><code class="js">// 父页面：增加一个postMessage来监听消息window.addEventListener(&#39;message&#39;, this.postMessageListener)/** iframe页面：关闭窗口 */close(removeTask, message){    let params = {        close: true,        removeData: removeTask,        message: message    }    parent.postMessage(, &#39;*&#39;)}</code></pre><h2 id="5、cors-fetch"><a href="#5、cors-fetch" class="headerlink" title="5、cors (fetch)"></a>5、cors (fetch)</h2><h2 id="6、Proxy"><a href="#6、Proxy" class="headerlink" title="6、Proxy"></a>6、Proxy</h2><p>通过 nginx 等web服务代理</p><p>Access-Control-Allow-Orign</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2020/04/19/web/js/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/04/19/web/js/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对象概念"><a href="#一、对象概念" class="headerlink" title="一、对象概念"></a>一、对象概念</h1><h2 id="1-1、对象"><a href="#1-1、对象" class="headerlink" title="1.1、对象"></a>1.1、对象</h2><h2 id="1-2-基本特征"><a href="#1-2-基本特征" class="headerlink" title="1.2 基本特征"></a>1.2 基本特征</h2><h3 id="1-2-1、封装"><a href="#1-2-1、封装" class="headerlink" title="1.2.1、封装"></a>1.2.1、封装</h3><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><h3 id="1-2-2、继承"><a href="#1-2-2、继承" class="headerlink" title="1.2.2、继承"></a>1.2.2、继承</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。<br>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。</p><h3 id="1-2-3、多态性"><a href="#1-2-3、多态性" class="headerlink" title="1.2.3、多态性"></a>1.2.3、多态性</h3><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名必须不同于原先方法的，但对于覆盖签名必须相同。</p><h1 id="二、如何创建对象"><a href="#二、如何创建对象" class="headerlink" title="二、如何创建对象"></a>二、如何创建对象</h1><h2 id="2-1、字面量方式"><a href="#2-1、字面量方式" class="headerlink" title="2.1、字面量方式"></a>2.1、字面量方式</h2><p>var obj = {}<br>obj.attr1 = 123;</p><h2 id="2-2、嵌入式字面量"><a href="#2-2、嵌入式字面量" class="headerlink" title="2.2、嵌入式字面量"></a>2.2、嵌入式字面量</h2><p>var obj = {<br>attr1 : 123,<br>}</p><h2 id="2-3、构造函数方式"><a href="#2-3、构造函数方式" class="headerlink" title="2.3、构造函数方式"></a>2.3、构造函数方式</h2><p>new Person()</p><h2 id="2-4、原型方式"><a href="#2-4、原型方式" class="headerlink" title="2.4、原型方式"></a>2.4、原型方式</h2><p>function Person(){}<br>Person.prototype.say = function(){…};</p><h2 id="2-5、构造函数-原型"><a href="#2-5、构造函数-原型" class="headerlink" title="2.5、构造函数+原型"></a>2.5、构造函数+原型</h2><p>function Person(name,age){<br>this.name = name;<br>this.age = age;<br>}<br>Person.prototype.say = function(){<br>console.log(“My name is “+this.name+”. I’m “+this.age+” years old.”);<br>}<br>var p1 = new Person(‘Peter’,20);</p><h2 id="2-6、Object-create"><a href="#2-6、Object-create" class="headerlink" title="2.6、Object.create()"></a>2.6、Object.create()</h2><p>ES5提供</p><h1 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h1><p>基本特征<br>封闭、继承、多态</p><h2 id="1、类的声明"><a href="#1、类的声明" class="headerlink" title="1、类的声明"></a>1、类的声明</h2><pre><code class="javascript">// ES5function Animal() {this.name = &#39;name&#39;}// ES6class Animal2 {constructor(){this.name = &#39;name&#39;}}</code></pre><h2 id="2、类的继承"><a href="#2、类的继承" class="headerlink" title="2、类的继承"></a>2、类的继承</h2><h3 id="借助构造函数实现继承"><a href="#借助构造函数实现继承" class="headerlink" title="借助构造函数实现继承"></a>借助构造函数实现继承</h3><pre><code class="javascript">function Parent1(){this.name = &#39;parent1&#39;}Parent1.prototype.say=function(){}function Child1(){Parent1.call(this)//将Parent1的this指向Child1实例化后的实例//但无法继承Parent1上原型对象上的方法saythis.type = &#39;child1&#39;}new Child1()</code></pre><h3 id="借助原型链继承"><a href="#借助原型链继承" class="headerlink" title="借助原型链继承"></a>借助原型链继承</h3><p>可以继承Parent2上原型对象上的方法</p><pre><code class="javascript">function Parent2 () {this.name = &#39;parent2&#39;}function Child2 () {this.type = &#39;child2&#39;}Child2.prototype = new Parent2()new Child2()</code></pre><blockquote><p>缺点：实例化两个对象，一个改变，另一个也跟着变</p></blockquote><h3 id="组合方式（推荐）"><a href="#组合方式（推荐）" class="headerlink" title="组合方式（推荐）"></a>组合方式（推荐）</h3><p>解决以上两种方式的缺点</p><pre><code class="javascript">function Parent3(){this.name = &#39;parent3&#39;}function Child3(){Parent3.call(this)this.type=&#39;child3&#39;}//Child3.prototype = new Parent3() //Parent3的构造函数会执行两次//Child3.prototype = Parent3.prototype //instanceof无法区分实例是父的还是子的//Child3.prototype = Object.create(Parent3.prototype) //隔离了父子的原型对象Child3.prototype.constructor = Child3 //设置自己的构造器，否则实例还是指向父</code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/04/19/web/js/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/04/19/web/js/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h1><h2 id="1、基本类型（栈）"><a href="#1、基本类型（栈）" class="headerlink" title="1、基本类型（栈）"></a>1、基本类型（栈）</h2><pre><code class="js">numberstringbooleanundefinednull</code></pre><p>无法给基本类型的对象添加属性和方法<br>基本类型对象的比较是值比较<br>存储在栈内存中的</p><h2 id="2、引用类型（堆）"><a href="#2、引用类型（堆）" class="headerlink" title="2、引用类型（堆）"></a>2、引用类型（堆）</h2><pre><code class="js">objectarrayfunctiondate</code></pre><p>引用类型对象的比较是引用比较<br>存储在栈内存中的一个堆内存地址</p><h1 id="二、类型判断"><a href="#二、类型判断" class="headerlink" title="二、类型判断"></a>二、类型判断</h1><h2 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h2><p>number<br>boolean<br>string<br>function<br>object<br>undefined</p><blockquote><p>局限性:<br>对于 Array,Null 等特殊对象<br>一律返回 object</p></blockquote><pre><code class="js">typeof null// Object</code></pre><blockquote><p>但null不是Object的一个实例<br>这是js的局限性</p></blockquote><h2 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、instanceof</h2><p>用于判断一个变量是否属于某个对象的实例</p><pre><code class="js">var a = new Array();alert(a instanceof Array); // truealert(a instanceof Object) // true Array 是 object 的子类function test(){};var a = new test();alert(a instanceof test) // true</code></pre><h1 id="三、类型转换"><a href="#三、类型转换" class="headerlink" title="三、类型转换"></a>三、类型转换</h1><h2 id="1、显式转换"><a href="#1、显式转换" class="headerlink" title="1、显式转换"></a>1、显式转换</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>数值 转为数值<br>字符串 不可转为数值时为NaN，空转为0<br>true 转为1<br>false 转为0<br>undefined 转为NaN<br>null 转为0<br>Object 转为NaN<br>valueOf {a:1}<br>返回基础类型 调用Number()<br>返回复合 toString ‘[object object]’<br>返回基础类型 调用Number() NaN<br>返回复合 报错</p><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>数值 转为字符串<br>字符串 转为字符串<br>true 转为1<br>false 转为0<br>undefined ‘undefined’<br>null 转为’null’<br>object 转为’[object object]’<br>先调toString<br>再调valueOf</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p>以下都转为false<br>undefined<br>null<br>+-0<br>NaN<br>‘’<br>其他都是true，包括{} []</p><h2 id="2、隐式转换"><a href="#2、隐式转换" class="headerlink" title="2、隐式转换"></a>2、隐式转换</h2><pre><code class="js">[]+[]    &#39;&#39;[]+{}    &quot;[object Object]&quot;{}+[]    0{}+{}    &quot;[object Object][object Object]&quot;true+true    21 + {a:1}    &quot;1[object Object]&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="/2020/04/19/web/js/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/04/19/web/js/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建对象方法"><a href="#一、创建对象方法" class="headerlink" title="一、创建对象方法"></a>一、创建对象方法</h1><h2 id="1、字面量"><a href="#1、字面量" class="headerlink" title="1、字面量"></a>1、字面量</h2><pre><code class="js">var a={}a.attr1=1var b={name:2}var c=new Object({name:c}) 显示的构造函数</code></pre><h2 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h2><pre><code class="javascript">var M=function (name){    this.name=name;}var o3=new M(&#39;o3&#39;)</code></pre><h2 id="3、create函数（ES5"><a href="#3、create函数（ES5" class="headerlink" title="3、create函数（ES5)"></a>3、create函数（ES5)</h2><pre><code class="javascript">var p ={name:&#39;P&#39;}var o4=Object.create(p)o4.name返回{}// o4本身没有name属性，只能通过原型链找到o4.__proto__.name</code></pre><h2 id="4、组合式-构造函数-原型"><a href="#4、组合式-构造函数-原型" class="headerlink" title="4、组合式 构造函数+原型"></a>4、组合式 构造函数+原型</h2><pre><code class="javascript">function Person(name,age){    this.name = name;    this.age = age;}Person.prototype.say = function(){    console.log(&quot;My name is &quot;+this.name+&quot;. I&#39;m &quot;+this.age+&quot; years old.&quot;);}var p1 = new Person(&#39;Peter&#39;,20);</code></pre><h1 id="二、原型对象"><a href="#二、原型对象" class="headerlink" title="二、原型对象"></a>二、原型对象</h1><p><code>__proto__</code></p><h1 id="三、构造函数"><a href="#三、构造函数" class="headerlink" title="三、构造函数"></a>三、构造函数</h1><p>prototype属性    -&gt; 原型对象<br>constructor构造器    -&gt; 原型对象<br>使用new创建实例</p><h1 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h1><p>通过new构造函数生成<br><code>__proto__</code>    -&gt; 上级原型</p><h1 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h1><p>通过原型链向上找原型对象</p><h1 id="六、instanceof原理"><a href="#六、instanceof原理" class="headerlink" title="六、instanceof原理"></a>六、instanceof原理</h1><blockquote><p>判断一个对象是否属于某个类</p></blockquote><h2 id="1、实例-instanceof-构造函数"><a href="#1、实例-instanceof-构造函数" class="headerlink" title="1、实例 instanceof 构造函数"></a>1、实例 instanceof 构造函数</h2><p>实际是判断实例的<strong>proto</strong>和构造函数的prototype是否指向同一个引用</p><pre><code class="js">o3 instanceof M trueo3 instanceof Object true</code></pre><h2 id="2、原因"><a href="#2、原因" class="headerlink" title="2、原因"></a>2、原因</h2><pre><code class="js">o3.__proto__===M.prototype trueM.prototype.__proto__===Object.prototype true</code></pre><h2 id="3、通过原型属性上的构造器判断是谁的实例"><a href="#3、通过原型属性上的构造器判断是谁的实例" class="headerlink" title="3、通过原型属性上的构造器判断是谁的实例"></a>3、通过原型属性上的构造器判断是谁的实例</h2><pre><code class="js">o3.__proto__.constructor===M trueo3.__proto__.constructor===Object false</code></pre><h1 id="七、new"><a href="#七、new" class="headerlink" title="七、new"></a>七、new</h1><p>新对象被创建，继承构造函数foo的prototype<br>foo被执行，参数被传入，同时上下文this被指定为这个新实例<br>new工作原理：</p><pre><code class="javascript">var new2 = function(func){    var o=Object.create(func.prototype);    var k = func.call(o) // call转移上下文this    if(typeof k === &#39;object&#39;){        return k    } else{        return o    }}o6=new2(M)o6 instanceof M // trueo6 instanceof Object // trueo6.__proto__===M.prototype // true</code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量</title>
      <link href="/2020/04/19/web/js/%E5%8F%98%E9%87%8F/"/>
      <url>/2020/04/19/web/js/%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1、如何声明变量"><a href="#1、如何声明变量" class="headerlink" title="1、如何声明变量"></a>1、如何声明变量</h1><p>var 关键字</p><ul><li>兼容性好</li></ul><p>const 关键字</p><ul><li>ES6语法，只读</li></ul><p>let 关键字</p><ul><li>ES6语法，可读写</li></ul><blockquote><p>注意<br>函数内部如果不对变量进行var声明，<br>实际上是在外面先var声明了一个全局变量，函数内再附值。</p></blockquote><h1 id="2、变量的作用域"><a href="#2、变量的作用域" class="headerlink" title="2、变量的作用域"></a>2、变量的作用域</h1><p>变量分为<strong>全局变量</strong>和<strong>局部变量</strong><br>函数内部可以读取函数外部的全局变量<br>在函数外部无法读取函数内的局部变量</p><h1 id="3、什么是变量提升"><a href="#3、什么是变量提升" class="headerlink" title="3、什么是变量提升"></a>3、什么是变量提升</h1><p>根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，<br>找到就返回，没找到就一直找，<br>直到window的变量，没有就返回undefined。</p><pre><code class="javascript">var x = 10;function x(){};console.log(x); // 10</code></pre><p>实际上被解释为:</p><pre><code class="javascript">var x;function x(){};x = 10;console.log(x); // 10</code></pre><h1 id="4、垃圾回收"><a href="#4、垃圾回收" class="headerlink" title="4、垃圾回收"></a>4、垃圾回收</h1><p>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p><pre><code class="js">function fn1() {    var obj = {name: &#39;hanzichi&#39;, age: 10};}function fn2() {    var obj = {name:&#39;hanzichi&#39;, age: 10};    return obj;}var a = fn1(); // 内部变量obj没有被引用，执行完后就回收var b = fn2(); // 内部变量obj被b引用，不会被回收</code></pre><h1 id="5、内存泄露"><a href="#5、内存泄露" class="headerlink" title="5、内存泄露"></a>5、内存泄露</h1><p>一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束.</p><pre><code class="html">&lt;div id=&quot;myDiv&quot;&gt;    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    var btn = document.getElementById(&quot;myBtn&quot;);    btn.onclick = function(){        btn.onclick = null; // 解决：在input元素被替换之前，解绑事件        document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;Processing...&quot;;    }    &lt;/script&gt;&lt;/div&gt;</code></pre><blockquote><p>元素绑定的事件仍没被移除，IE中不会作出恰当处理，造成内存泄露。</p></blockquote><pre><code class="js">function bindEvent(){    var obj=document.createElement(&quot;XXX&quot;);    obj.onclick=function(){        //Even if it&#39;s a empty function    }    obj=null; // 解决：手动处理}</code></pre><blockquote><p>由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。<br>闭包可以维持函数内局部变量，使其得不到释放。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化</title>
      <link href="/2020/04/19/web/js/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2020/04/19/web/js/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数</p><h1 id="模块化封装方法"><a href="#模块化封装方法" class="headerlink" title="模块化封装方法"></a>模块化封装方法</h1><h2 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h2><p>就是普通的function<br>缺点：<br>“污染”了全局变量<br>变量名冲突<br>模块之间无直接关系</p><h2 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h2><p>所有的模块成员都放到这个对象里面</p><pre><code class="js">varobj = {    age : 0,    func1 : function (){        //...    },    func2 : function (){        //...    }};</code></pre><p>变量可以被外面随意改变而导致不安全</p><h2 id="3、闭包-立即执行函数-IIFE"><a href="#3、闭包-立即执行函数-IIFE" class="headerlink" title="3、闭包 立即执行函数 IIFE"></a>3、闭包 立即执行函数 IIFE</h2><p>立即执行函数<br>不暴露私有成员<br>外部代码无法读取内部变量。</p><pre><code class="js">var oj= (function(){　　　  var _age= 0;　　　　var func1= function(){　　　　　　//...　　　　};　　　　var func2= function(){　　　　　　//...　　　　};　　　　return {　　　　　　m1 : func1,　　　　　　m2 : func2　　　　};})();</code></pre><h2 id="4、放大模式"><a href="#4、放大模式" class="headerlink" title="4、放大模式"></a>4、放大模式</h2><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块</p><pre><code class="js">var obj =(function (mod){　　　　mod.func3= function () {　　　　　　//...　　　　};　　　　returnmod;//方便方法连续调用})(obj);</code></pre><p>为obj模块添加了一个新方法func3 ()，然后返回新的obj模块，方便方法连续调用。</p><h2 id="5、宽放大模式"><a href="#5、宽放大模式" class="headerlink" title="5、宽放大模式"></a>5、宽放大模式</h2><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。</p><pre><code class="js">　　var obj =( function (mod){　　　　//...　　　　returnmod;　　})(window.obj|| {});//确保对象不为空</code></pre><h2 id="6、输入全局变量"><a href="#6、输入全局变量" class="headerlink" title="6、输入全局变量"></a>6、输入全局变量</h2><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p><pre><code class="js">(function(window, undefined ) {……})(window );</code></pre><p>这是jQuery框架的源码，将window对象作为参数传入，这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p><blockquote><p>目前，通行的JavaScript模块规范共有两种：CommonJS和AMD</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2020/04/19/web/js/%E9%97%AD%E5%8C%85/"/>
      <url>/2020/04/19/web/js/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是闭包"><a href="#一、什么是闭包" class="headerlink" title="一、什么是闭包"></a>一、什么是闭包</h1><p>闭包就是一个函数引用另外一个函数的变量，<br>因为变量被引用着所以不会被回收，<br>因此可以用来封装一个私有变量。</p><p>当一个函数的返回值是另外一个函数，<br>而返回的那个函数如果调用了其父函数内部的其它变量，<br>如果返回的这个函数在外部被执行，就产生了闭包。</p><pre><code class="javascript">function f1(){　　　　var n=999;　function f2(){　　　　　　alert(n++);　　　　}　　　　return f2;　　}　　var result=f1();　　result(); // 999　　nAdd();　　result(); // 1000</code></pre><p>在外部调用result函数，可以不断怎家内部的n值，实际上函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>原因: f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><pre><code class="js">(function(x){delete x;alert(x);})(1+5);</code></pre><p>函数参数无法delete删除<br>delete只能删除通过for in访问的属性<br>删除失败也不会报错，所以代码运行会弹出“1”</p><pre><code class="js">var count=10; //全局作用域 标记为flag1function add(){    var count=0; //函数全局作用域 标记为flag2    return function(){ // 这就是s        count+=1; //函数的内部作用域，内部没有定义，变量提升，向上查找到flag2标记的count，打印0+1        alert(count);    }}var s = add()s();//输出1s();//输出2</code></pre><h1 id="四、作用"><a href="#四、作用" class="headerlink" title="四、作用"></a>四、作用</h1><h2 id="1、读取函数内部的变量"><a href="#1、读取函数内部的变量" class="headerlink" title="1、读取函数内部的变量"></a>1、读取函数内部的变量</h2><h2 id="2、使变量的值始终保持在内存中"><a href="#2、使变量的值始终保持在内存中" class="headerlink" title="2、使变量的值始终保持在内存中"></a>2、使变量的值始终保持在内存中</h2><h2 id="3、用闭包模拟私有方法"><a href="#3、用闭包模拟私有方法" class="headerlink" title="3、用闭包模拟私有方法"></a>3、用闭包模拟私有方法</h2><p>下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：</p><pre><code class="javascript">var Counter = (function() {    var privateCounter = 0;    function changeBy(val) {        privateCounter += val;    }    return {        increment: function() {            changeBy(1);        },        decrement: function() {            changeBy(-1);        },        value: function() {            return privateCounter;        }    }})();alert(Counter.value()); /* 提示 0 */Counter.increment();Counter.increment();alert(Counter.value()); /* 提示 2 */Counter.decrement();alert(Counter.value()); /* 提示 1 */</code></pre><h2 id="4、在循环中创建闭包"><a href="#4、在循环中创建闭包" class="headerlink" title="4、在循环中创建闭包"></a>4、在循环中创建闭包</h2><pre><code class="javascript">function showHelp(help) {    document.getElementById(&#39;help&#39;).innerHTML = help;}function makeHelpCallback(help) {    return function() {        showHelp(help);    };}function setupHelp() {var helpText = [    {&#39;id&#39;: &#39;email&#39;, &#39;help&#39;: &#39;Your e-mail address&#39;},    {&#39;id&#39;: &#39;name&#39;, &#39;help&#39;: &#39;Your full name&#39;},    {&#39;id&#39;: &#39;age&#39;, &#39;help&#39;: &#39;Your age (you must be over 16)&#39;}];for (var i = 0; i &lt; helpText.length; i++) {    var item = helpText[i];    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);    }}setupHelp();</code></pre><h1 id="六、注意"><a href="#六、注意" class="headerlink" title="六、注意"></a>六、注意</h1><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><blockquote><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6语法</title>
      <link href="/2020/04/19/web/js/this%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/04/19/web/js/this%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>随着函数使用场合不同，this的值会发生变化<br>this指的是调用函数的那个对象</p><p>this的指向<br>this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象</p><h2 id="1、全局作用域下，this指向window"><a href="#1、全局作用域下，this指向window" class="headerlink" title="1、全局作用域下，this指向window"></a>1、全局作用域下，this指向window</h2><pre><code class="js">function func(){    console.log(this) ;//this指向的还是window对象}func();</code></pre><h2 id="2、对象函数调用，哪个对象调用就指向哪个对象"><a href="#2、对象函数调用，哪个对象调用就指向哪个对象" class="headerlink" title="2、对象函数调用，哪个对象调用就指向哪个对象"></a>2、对象函数调用，哪个对象调用就指向哪个对象</h2><pre><code class="html">&lt;input type=&quot;button&quot;id=&quot;btnOK&quot; value=&quot;OK&quot;&gt;&lt;script&gt;varbtnOK=document.getElementById(&quot;btnOK&quot;);btnOK.onclick=function(){    console.log(this);//this指向的是btnOK对象}&lt;/script&gt;</code></pre><h2 id="3、使用-new-实例化对象，在构造函数中的this指向实例化对象。"><a href="#3、使用-new-实例化对象，在构造函数中的this指向实例化对象。" class="headerlink" title="3、使用 new 实例化对象，在构造函数中的this指向实例化对象。"></a>3、使用 new 实例化对象，在构造函数中的this指向实例化对象。</h2><pre><code class="js">var Show=function(){    this.myName=&quot;Mr.Cao&quot;; //这里的this指向的是obj对象}var obj=new Show();</code></pre><h2 id="4、使用call或apply改变this的指向"><a href="#4、使用call或apply改变this的指向" class="headerlink" title="4、使用call或apply改变this的指向"></a>4、使用call或apply改变this的指向</h2><pre><code class="js">var Go=function(){    this.address=&quot;深圳&quot;;}var Show=function(){    console.log(this.address);//输出 深圳}var go=new Go();Show.call(go);//改变Show方法的this指向go对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>new操作符做了啥？</title>
      <link href="/2020/04/19/web/js/new%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/04/19/web/js/new%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><pre><code class="js">var obj = {};</code></pre><p>创建一个空对象<br>this 变量引用该对象</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><pre><code class="js">obj.__proto__ = Base.prototype;</code></pre><p>属性和方法被加入到 this 引用的对象中</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><pre><code class="js">Base.call(obj);</code></pre><p>新创建的对象由 this 所引用<br>最后隐式的返回 this</p>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6语法</title>
      <link href="/2020/04/19/web/es/es6%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/04/19/web/es/es6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>/**———————————————————————————– */<br>// Arrays（数组）<br>array.find(predicate)<br>//萃取数组对象中某属性值<br>array.map(value =&gt; value[propertyName])<br>//把一个类数组转换成一个数组<br>Array.from(arguments)<br>//返回一个除去所有false值的 array副本<br>array.filter(x =&gt; !!x)<br>//返回 array去重后的副本<br>[…new Set(array)]<br>//创建一个 N个数字数组，从x开始<br>Array.from({ length: n }, (v, k) =&gt; k + x)<br>//检查数组中是否包含某个元素<br>array.includes(element)<br>// includes() 方法能找到 NaN，而 indexOf() 不行</p><blockquote><p>[NaN].includes(NaN)<br>true<br>[NaN].indexOf(NaN)<br>-1<br>[-0].includes(+0)<br>true<br>/<strong>———————————————————————————– */<br>//Objects（对象）<br>// 枚举所有的属性名，包括继承过来的<br>Reflect.enumerate(object) // 返回一个迭代器<br>//检查一个对象是否是一个有限的数字<br>Number.isFinite(object)<br>//创建一个合并属性后的新对象<br>{ …source, a: false }<br>//创建一个浅拷贝对象<br>{ …object }<br>/</strong>———————————————————————————– */<br>//Functions（函数）<br>//给对象绑定一个函数<br>foo(() =&gt; {<br>this.bar();<br>});<br>foo(object.fun.bind(object));<br>//迭代行数<br>value =&gt; value<br>//返回值的函数<br>const fun = () =&gt; value;<br>//空函数<br>() =&gt; {}</p></blockquote><p>//给对象绑定一个函数<br>foo(() =&gt; {<br>this.bar();<br>});<br>foo(::object.fun);//:: 作为一个新的绑定操作符</p><p>//指数运算符<br>x ** y<br>let squared = 3 ** 2; // 9<br>let num = 3;<br>num **= 2;<br>console.log(num); // 9</p><p>// 异步函数<br>async function fetchJson(url) {<br>try {<br>let request = await fetch(url);<br>let text = await request.text();<br>return JSON.parse(text);<br>}<br>catch (error) {<br>console.log(<code>ERROR: ${error.stack}</code>);<br>}<br>}</p><p>async test(){<br>return ‘aaa’<br>}<br>this.test().then(res=&gt;{<br>console.log(‘123 ‘+res)<br>})</p><blockquote><p>‘123 aaa’<br>// async函数返回的是一个Promise对象。<br>// 如果在函数中return一个直接量，<br>// async会把这个直接量通过Promise.resolve()封装成Promise对象。<br>// async函数 在没有await的情况下执行async函数，它会立即执行，并且返回一个promise对象，并且绝不会阻塞后面的语句<br>// await 暂停当前async function的执行，等待Promise处理完成</p></blockquote><p>// 异步变同步<br>getGategory(pm){<br>console.log(‘begin:’,pm)<br>return Promise((resolve,reject)=&gt;{<br>getJson(‘/goods/gategory’,date=&gt;{<br>console.log(pm)<br>resolve(data)<br>})<br>})<br>}<br>async doIt(){<br>getGategory(‘do1’)<br>getGategory(‘do2’)<br>getGategory(‘do3’)<br>}</p><blockquote><p>‘begin: do1’<br>‘do1’<br>‘begin: do2’<br>‘do2’<br>‘begin: do3’<br>‘do3’<br>//类似于一个使用了 Promises 和 generators 让编程风格看起来更像异步的库co<br>const fetchJson2 = co(function* () {<br>try {<br>let request = yield fetch(url);<br>let text = yield request.text();<br>return JSON.parse(text);<br>}<br>catch (error) {<br>console.log(<code>ERROR: ${error.stack}</code>);<br>}<br>});</p></blockquote><p>// Generator函数</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 简介<br>// 说明<br>/<em>意思是生成器，是一个状态机，封装了多个内部状态<br>返回一个遍历器对象，可以遍历每一个状态<br>function关键字与函数名之间有一个星号<br>内部使用yield语句，定义不同的内部状态<br>yield语句在英语里的意思就是“产出”</em>/<br>// 有三个状态：hello，world和return语句<br>function* helloWorldGenerator() {<br>yield ‘hello’;<br>yield ‘world’;<br>return ‘ending’;<br>}<br>// 调用Generator函数后，该函数并不执行<br>var hw = helloWorldGenerator();<br>// done属性的值false，表示遍历还没有结束<br>hw.next() // { value: ‘hello’, done: false }<br>hw.next() // { value: ‘world’, done: false }<br>// 从上次yield语句停下的地方，一直执行到return语句<br>hw.next() // { value: ‘ending’, done: true }<br>hw.next() // { value: undefined, done: true }<br>// <em>号位置可以随意<br>function * foo(x, y) { }<br>function *foo(x, y) { }<br>function</em> foo(x, y) { }<br>function*foo(x, y) { }</p><p>// yield语句<br>/<em>遇到yield，函数暂停执行，下一次再从该位置继续向后执行<br>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行<br>yield语句不能用在普通函数中</em>/<br>var arr = [1, [[2, 3], 4], [5, 6]];<br>var flat = function* (a) {<br>var length = a.length;<br>for (var i = 0; i &lt; length; i++) {<br>var item = a[i];<br>if (typeof item !== ‘number’) {<br>yield* flat(item);<br>} else {<br>yield item;<br>}<br>}<br>};<br>for (var f of flat(arr)) {<br>console.log(f);<br>} // 1, 2, 3, 4, 5, 6<br>// forEach方法的参数是一个普通函数，但是在里面使用了yield语句，改用for循环<br>console.log(‘Hello’ + yield); // SyntaxError<br>console.log(‘Hello’ + yield 123); // SyntaxError<br>console.log(‘Hello’ + (yield)); // OK<br>console.log(‘Hello’ + (yield 123)); // OK<br>// 用在一个表达式之中，必须放在圆括号里<br>foo(yield ‘a’, yield ‘b’); // OK<br>let input = yield; // OK<br>// 用作函数参数或赋值表达式的右边，可以不加括号<br>// 与Iterator接口的关系<br>var myIterable = {};<br>myIterable[Symbol.iterator] = function* () {<br>yield 1;<br>yield 2;<br>yield 3;<br>};<br>[…myIterable] // [1, 2, 3]<br>// 可以把Generator赋值给对象的Symbol.iterator属性<br>// 使得myIterable对象具有了Iterator接口，可以被…运算符遍历了<br>function* gen(){<br>// some code<br>}<br>var g = gen();<br>g<a href="">Symbol.iterator</a> === g // true<br>// gen是一个Generator函数，调用它会生成一个遍历器对象g<br>// Symbol.iterator属性也是一个遍历器对象生成函数，执行后返回它自己</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// next的参数<br>function* f() {<br>for(var i=0; true; i++) {<br>var reset = yield i;<br>if(reset) { i = -1;<br>}<br>}<br>}<br>var g = f();<br>g.next() // { value: 0, done: false }<br>g.next() // { value: 1, done: false }<br>g.next(true) // { value: 0, done: false }<br>// next方法的参数会被当作上一个yield语句的返回值<br>// 第一次使用next方法时，不能带有参数<br>function* foo(x) {<br>var y = 2 * (yield (x + 1));<br>var z = yield (y / 3);<br>return (x + y + z);<br>}<br>var a = foo(5);<br>a.next() // Object{value:6, done:false}<br>a.next() // Object{value:NaN, done:false}<br>a.next() // Object{value:NaN, done:true}<br>var b = foo(5); b.next() // { value:6, done:false }<br>b.next(12) // { value:8, done:false }<br>b.next(13) // { value:42, done:true }<br>// a第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN）<br>// b第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8<br>// 第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24<br>function wrapper(generatorFunction) {<br>return function (…args) {<br>let generatorObject = generatorFunction(…args);<br>generatorObject.next();<br>return generatorObject;<br>};<br>}<br>const wrapped = wrapper(function* () {<br>console.log(<code>First input: ${yield}</code>);<br>return ‘DONE’;<br>});<br>wrapped().next(‘hello!’) // First input: hello!<br>// 在Generator函数外面再包一层，可以第一次调用next就输入参数<br>function* dataConsumer() {<br>console.log(‘Started’);<br>console.log(<code>1. ${yield}</code>);<br>console.log(<code>2. ${yield}</code>);<br>return ‘result’;<br>}<br>let genObj = dataConsumer();<br>genObj.next(); // Started<br>genObj.next(‘a’) // 1. a<br>genObj.next(‘b’) // 2. b</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// for…of循环<br>function <em>foo() {<br>yield 1;<br>yield 2;<br>yield 3;<br>yield 4;<br>yield 5;<br>return 6;<br>}<br>for (let v of foo()) {<br>console.log(v);<br>} // 1 2 3 4 5<br>// 返回对象的done属性为true，for…of循环就会中止<br>function</em> fibonacci() {<br>let [prev, curr] = [0, 1];<br>for (;;) {<br>[prev, curr] = [curr, prev + curr];<br>yield curr;<br>}<br>}<br>for (let n of fibonacci()) {<br>if (n &gt; 1000) break;<br>console.log(n);<br>}<br>function* objectEntries(obj) {<br>let propKeys = Reflect.ownKeys(obj);<br>for (let propKey of propKeys) {<br>yield [propKey, obj[propKey]];<br>}<br>}<br>let jane = { first: ‘Jane’, last: ‘Doe’ };<br>for (let [key, value] of objectEntries(jane)) {<br>console.log(<code>${key}: ${value}</code>);<br>} // first: Jane // last: Doe<br>// object通过Generator函数为它加上遍历接口<br>function* objectEntries() {<br>let propKeys = Object.keys(this);<br>for (let propKey of propKeys) {<br>yield [propKey, this[propKey]];<br>}<br>}<br>let jane = { first: ‘Jane’, last: ‘Doe’ };<br>jane[Symbol.iterator] = objectEntries;<br>for (let [key, value] of jane) {<br>console.log(<code>${key}: ${value}</code>);<br>} // first: Jane // last: Doe<br>// 或者将Generator函数加到对象的Symbol.iterator属性上面<br>function* numbers () {<br>yield 1<br>yield 2<br>return 3<br>yield 4<br>}<br>// 扩展运算符<br>[…numbers()] // [1, 2]<br>// Array.from 方法<br>Array.from(numbers()) // [1, 2]<br>// 解构赋值<br>let [x, y] = numbers();<br>x // 1<br>y // 2<br>// for…of 循环<br>for (let n of numbers()) {<br>console.log(n)<br>} // 1 // 2<br>// 扩展运算符（…）、解构赋值和Array.from方法都是遍历器接口<br>// 都可以将Generator函数返回的Iterator对象，作为参数</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// throw()<br>var g = function* () {<br>try {<br>yield;<br>} catch (e) {<br>console.log(‘内部捕获’, e);<br>}<br>};<br>var i = g();<br>i.next();<br>try {<br>i.throw(‘a’);<br>i.throw(‘b’);<br>} catch (e) {<br>console.log(‘外部捕获’, e);<br>}<br>// 内部捕获 a<br>// 外部捕获 b<br>// 第一个错误被Generator函数体内的catch语句捕获<br>// 第二次抛出错误，Generator函数内部的catch语句已经执行过了，不会再捕捉<br>// 错误就被抛出了Generator函数体，被函数体外的catch语句捕获<br>var g = function* () {<br>try {<br>yield;<br>} catch (e) {<br>console.log(e);<br>}<br>};<br>var i = g();<br>i.next();<br>i.throw(new Error(‘出错了！’)); // Error: 出错了！(…)<br>// 可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例<br>var g = function* () {<br>while (true) {<br>yield;<br>console.log(‘内部捕获’, e);<br>}<br>};<br>var i = g();<br>i.next();<br>try {<br>i.throw(‘a’);<br>i.throw(‘b’);<br>} catch (e) {<br>console.log(‘外部捕获’, e);<br>} // 外部捕获 a<br>// 内部没有部署try…catch代码块<br>// 抛出的错误直接被外部catch代码块捕获<br>var gen = function* gen(){<br>yield console.log(‘hello’);<br>yield console.log(‘world’);<br>}<br>var g = gen();<br>g.next();<br>g.throw(); // hello // Uncaught undefined<br>// 内部和外部，都没有部署try…catch代码块<br>// 程序将报错，直接中断执行<br>var gen = function* gen(){<br>try {<br>yield console.log(‘a’);<br>} catch (e) {<br>// …<br>}<br>yield console.log(‘b’);<br>yield console.log(‘c’);<br>}<br>var g = gen();<br>g.next() // a<br>g.throw() // b<br>g.next() // c<br>// throw方法被捕获以后，会附带执行下一条yield语句</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// return()</p><p>function* gen() {<br>yield 1;<br>yield 2;<br>yield 3;<br>}<br>var g = gen();<br>g.next() // { value: 1, done: false }<br>g.return(‘foo’) // { value: “foo”, done: true }<br>g.next() // { value: undefined, done: true }<br>// g调用return方法后，返回值的value属性就是return方法的参数foo<br>// 遍历就终止了，返回值的done属性为true<br>// 不提供参数，则返回值的value属性为undefined<br>function* numbers () {<br>yield 1;<br>try {<br>yield 2;<br>yield 3;<br>} finally {<br>yield 4;<br>yield 5;<br>}<br>yield 6;<br>}<br>var g = numbers()<br>g.next() // { done: false, value: 1 }<br>g.next() // { done: false, value: 2 }<br>g.return(7) // { done: false, value: 4 }<br>g.next() // { done: false, value: 5 }<br>g.next() // { done: true, value: 7 }<br>// 内部有try…finally代码<br>// return方法会推迟到finally代码块执行完再执行</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// yield<em>语句<br>function</em> foo() {<br>yield ‘a’; yield ‘b’; }<br>function* bar() {<br>yield ‘x’;<br>foo();<br>yield ‘y’;<br>}<br>for (let v of bar()){<br>console.log(v);<br>} // “x” // “y”<br>// 在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果<br>function* bar() {<br>yield ‘x’;<br>yield* foo();<br>yield ‘y’; }<br>// 等同于<br>function* bar() {<br>yield ‘x’;<br>yield ‘a’;<br>yield ‘b’;<br>yield ‘y’;<br>}<br>// 等同于<br>function* bar() {<br>yield ‘x’;<br>for (let v of foo()) {<br>yield v;<br>}<br>yield ‘y’;<br>}<br>for (let v of bar()){<br>console.log(v);<br>}<br>// “x”<br>// “a”<br>// “b”<br>// “y”</p><p>function* inner() {<br>yield ‘hello!’;<br>}<br>function* outer1() {<br>yield ‘open’;<br>yield inner();<br>yield ‘close’;<br>}<br>var gen = outer1()<br>gen.next().value // “open”<br>gen.next().value // 返回一个遍历器对象<br>gen.next().value // “close”<br>function* outer2() {<br>yield ‘open’<br>yield* inner()<br>yield ‘close’<br>}<br>var gen = outer2()<br>gen.next().value // “open”<br>gen.next().value // “hello!”<br>gen.next().value // “close”<br>let delegatedIterator = (function* () {<br>yield ‘Hello!’;<br>yield ‘Bye!’;<br>}());<br>let delegatingIterator = (function* () {<br>yield ‘Greetings!’;<br>yield* delegatedIterator;<br>yield ‘Ok, bye.’; }());<br>for(let value of delegatingIterator) {<br>console.log(value);<br>}<br>// “Greetings!<br>// “Hello!”<br>// “Bye!”<br>// “Ok, bye.”</p><p>function* gen(){<br>yield* [“a”, “b”, “c”];<br>}<br>gen().next() // { value:”a”, done:false }<br>let read = (function* () {<br>yield ‘hello’;<br>yield* ‘hello’;<br>})();<br>read.next().value // “hello”<br>read.next().value // “h”<br>// 任何数据结构只要有Iterator接口，就可以被yield<em>遍历<br>// 不加星号，返回的是整个数组<br>function *foo() {<br>yield 2;<br>yield 3;<br>return “foo”;<br>}<br>function *bar() {<br>yield 1;<br>var v = yield *foo();<br>console.log( “v: “ + v );<br>yield 4;<br>}<br>var it = bar();<br>it.next() // {value: 1, done: false}<br>it.next() // {value: 2, done: false}<br>it.next() // {value: 3, done: false}<br>it.next(); // “v: foo” // {value: 4, done: false}<br>it.next() // {value: undefined, done: true}<br>// 有return语句，那么就可以向代理它的Generator函数返回数据<br>// 函数foo的return语句，向函数bar提供了返回值<br>function</em> genFuncWithReturn() {<br>yield ‘a’;<br>yield ‘b’;<br>return ‘The result’;<br>}<br>function* logReturned(genObj) {<br>let result = yield* genObj;<br>console.log(result);<br>}<br>[…logReturned(genFuncWithReturn())]<br>// The result<br>// 值为 [ ‘a’, ‘b’ ]<br>function* iterTree(tree) {<br>if (Array.isArray(tree)) {<br>for(let i=0; i &lt; tree.length; i++) {<br>yield* iterTree(tree[i]);<br>}<br>} else {<br>yield tree;<br>}<br>}<br>const tree = [ ‘a’, [‘b’, ‘c’], [‘d’, ‘e’] ];<br>for(let x of iterTree(tree)) {<br>console.log(x);<br>}<br>// a<br>// b<br>// c<br>// d<br>// e<br>// 取出嵌套数组的所有成员<br>// 下面是二叉树的构造函数，<br>// 三个参数分别是左树、当前节点和右树<br>function Tree(left, label, right) {<br>this.left = left;<br>this.label = label;<br>this.right = right;<br>}<br>// 下面是中序（inorder）遍历函数。<br>// 由于返回的是一个遍历器，所以要用generator函数。<br>// 函数体内采用递归算法，所以左树和右树要用yield<em>遍历<br>function</em> inorder(t) {<br>if (t) {<br>yield* inorder(t.left);<br>yield t.label;<br>yield* inorder(t.right);<br>}<br>}<br>// 下面生成二叉树<br>function make(array) {<br>// 判断是否为叶节点<br>if (array.length == 1) return new Tree(null, array[0], null);<br>return new Tree(make(array[0]), array[1], make(array[2]));<br>}<br>let tree = make([[[‘a’], ‘b’, [‘c’]], ‘d’, [[‘e’], ‘f’, [‘g’]]]);<br>// 遍历二叉树<br>var result = [];<br>for (let node of inorder(tree)) {<br>result.push(node);<br>}<br>result // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’]<br>// 遍历完全二叉树<br>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 作为对象属性<br>let obj = {</p><ul><li>myGeneratorMethod() { ··· }<br>};<br>// 一个对象的属性是Generator函数<br>let obj = {<br>myGeneratorMethod: function* () {<br>// ···<br>}<br>};<br>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// this<br>function* g() { }<br>g.prototype.hello = function () {<br>return ‘hi!’;<br>};<br>let obj = g();<br>obj instanceof g // true<br>obj.hello() // ‘hi!’<br>// Generator函数的实例，也继承了Generator函数的prototype对象上的方法<br>function* g() {<br>this.a = 11;<br>}<br>let obj = g();<br>obj.a // undefined<br>// g返回的总是遍历器对象，而不是this对象<br>function* F() {<br>yield this.x = 2;<br>yield this.y = 3;<br>}<br>new F() // TypeError: F is not a constructor<br>// Generator函数也不能跟new命令一起用<br>// F不是构造函数<br>function* F() {<br>this.a = 1;<br>yield this.b = 2;<br>yield this.c = 3;<br>}<br>var obj = {};<br>var f = F.call(obj);<br>f.next(); // Object {value: 2, done: false}<br>f.next(); // Object {value: 3, done: false}<br>f.next(); // Object {value: undefined, done: true}<br>obj.a // 1<br>obj.b // 2<br>obj.c // 3<br>// 使用call方法绑定Generator函数内部的this<br>// F内部的this对象绑定obj对象，然后调用它<br>// 执行的是遍历器对象f，但是生成的对象实例是obj<br>function* F() {<br>this.a = 1;<br>yield this.b = 2;<br>yield this.c = 3;<br>}<br>var f = F.call(F.prototype);<br>f.next(); // Object {value: 2, done: false}<br>f.next(); // Object {value: 3, done: false}<br>f.next(); // Object {value: undefined, done: true}<br>f.a // 1 f.b // 2 f.c // 3<br>// 将obj换成F.prototype ，执行和生成的就是统一对象了<br>function* gen() {<br>this.a = 1;<br>yield this.b = 2;<br>yield this.c = 3;<br>}<br>function F() {<br>return gen.call(gen.prototype);<br>}<br>var f = new F();<br>f.next(); // Object {value: 2, done: false}<br>f.next(); // Object {value: 3, done: false}<br>f.next(); // Object {value: undefined, done: true}<br>f.a // 1<br>f.b // 2<br>f.c // 3<br>// 将F改成构造函数，就可以对它执行new命令了<br>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 应用<br>// 状态机<br>var ticking = true;<br>var clock = function () {<br>if (ticking) console.log(‘Tick!’);<br>else console.log(‘Tock!’);<br>ticking = !ticking;<br>}<br>// Generator是实现状态机的最佳结构<br>// 两种状态（Tick和Tock），每运行一次，就改变一次状态<br>var clock = function* () {<br>while (true) {<br>console.log(‘Tick!’);<br>yield;<br>console.log(‘Tock!’);<br>yield;<br>}<br>};<br>// Generator本身就包含了一个状态信息：是否处于暂停态<br>// 异步操作的同步化表达<br>function* loadUI() {<br>showLoadingScreen();<br>yield loadUIDataAsynchronously();<br>hideLoadingScreen();<br>}<br>var loader = loadUI(); // 加载UI<br>loader.next() // 卸载UI loader.next()<br>// 异步操作的后续操作可以放在yield语句下面<br>// 所有Loading界面的逻辑，都被封装在一个函数<br>function* main() {<br>var result = yield request(“<a href="http://some.url&quot;" target="_blank" rel="noopener">http://some.url&quot;</a>);<br>var resp = JSON.parse(result);<br>console.log(resp.value);<br>}<br>function request(url) {<br>makeAjaxCall(url, function (response) {<br>it.next(response);<br>});<br>}<br>var it = main();<br>it.next();<br>// main函数，就是通过Ajax操作获取数据<br>// makeAjaxCall函数中的next方法，必须加上response参数， 因为yield语句构成的表达式，本身是没有值的<br>function* numbers() {<br>let file = new FileReader(“numbers.txt”);<br>try {<br>while (!file.eof) {<br>yield parseInt(file.readLine(), 10);<br>}<br>} finally {<br>file.close();<br>}<br>}<br>// 使用yield语句可以手动逐行读取文件<br>// 控制流管理<br>Promise.resolve(step1)<br>.then(step2)<br>.then(step3)<br>.then(step4)<br>.then(function (value4) {<br>// Do something with value4<br>}, function (error) {<br>// Handle any error from step1 through step4<br>}).done();<br>// Promise方式<br>function* longRunningTask(value1) {<br>try {<br>var value2 = yield step1(value1);<br>var value3 = yield step2(value2);<br>var value4 = yield step3(value3);<br>var value5 = yield step4(value4);<br>// Do something with value4<br>} catch (e) {<br>// Handle any error from step1 through step4<br>}<br>}<br>scheduler(longRunningTask(initialValue));<br>function scheduler(task) {<br>var taskObj = task.next(task.value);<br>// 如果Generator函数未结束，就继续调用<br>if (!taskObj.done) {<br>task.value = taskObj.value;<br>scheduler(task);<br>}<br>}<br>// 按次序自动执行所有步骤<br>// 只适合同步操作<br>let steps = [step1Func, step2Func, step3Func];<br>function* iterateSteps(steps) {<br>for (var i = 0; i &lt; steps.length; i++){<br>var step = steps[i];<br>yield step();<br>}<br>}<br>// for…of循环会自动依次执行yield命令<br>let jobs = [job1, job2, job3];<br>function* iterateJobs(jobs) {<br>for (var i = 0; i &lt; jobs.length; i++){<br>var job = jobs[i];<br>yield* iterateSteps(job.steps);<br>}<br>}<br>// 还可以将项目分解成多个依次执行的任务<br>for (var step of iterateJobs(jobs)) {<br>console.log(step.id);<br>}<br>// 一次性依次执行所有任务的所有步骤<br>// 部署Iterator接口<br>function* iterEntries(obj) {<br>let keys = Object.keys(obj);<br>for (let i = 0; i &lt; keys.length; i++) {<br>let key = keys[i];<br>yield [key, obj[key]];<br>}<br>}<br>let myObj = { foo: 3, bar: 7 };<br>for (let [key, value] of iterEntries(myObj)) {<br>console.log(key, value);<br>} // foo 3 // bar 7<br>// 可以在任意对象上部署Iterator接口<br>function* makeSimpleGenerator(array) {<br>var nextIndex = 0;<br>while (nextIndex &lt; array.length) {<br>yield array[nextIndex++];<br>}<br>}<br>var gen = makeSimpleGenerator([‘yo’, ‘ya’]);<br>gen.next().value // ‘yo’<br>gen.next().value // ‘ya’<br>gen.next().done // true<br>// 作为数据结构<br>// Generator可以看作是一个数组结构<br>function* doStuff() {<br>yield fs.readFile.bind(null, ‘hello.txt’);<br>yield fs.readFile.bind(null, ‘world.txt’);<br>yield fs.readFile.bind(null, ‘and-such.txt’);<br>}<br>// 可以像处理数组那样，处理这三个返回的函数<br>for (task of doStuff()) {<br>// task是一个函数，可以像回调函数那样使用它<br>}</li></ul><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// Promise对象<br>// 含义<br>// 是异步编程的一种解决方案，比传统的回调函数和事件更合理和更强大<br>// 是一个容器，里面保存着某个未来才会结束的事件（异步操作）的结果<br>// 是一个对象，从它可以获取异步操作的消息<br>// 有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）<br>// 只有两种可能：从Pending变为Resolved和从Pending变为Rejected<br>// Promise新建后就会立即执行</p><p>// 基本用法<br>var promise = new Promise(function (resolve, reject) {<br>// … some code<br>if (/* 异步操作成功 */true){<br>resolve(value);<br>} else {<br>reject(error);<br>}<br>});<br>// Promise对象是一个构造函数<br>// resolve函数将Promise对象的状态从Pending变为Resolved<br>// reject函数将Promise对象的状态从Pending变为Rejected<br>// 它们的参数value和error会被传递给回调函数<br>promise.then(function (value) {<br>// success<br>}, function (error) {<br>// failure<br>});<br>// 用then方法分别指定Resolved状态和Reject状态的回调函数<br>// 第一个回调函数是Promise对象的状态变为Resolved时调用<br>// 第二个回调函数是Promise对象的状态变为Reject时调用(可选)<br>function timeout(ms) {<br>return new Promise((resolve, reject) =&gt; {<br>setTimeout(resolve, ms, ‘done’);<br>});<br>}<br>timeout(100).then((value) =&gt; {<br>console.log(value);<br>});<br>// 一段时间以后才会发生的结果<br>let promise = new Promise(function (resolve, reject) {<br>console.log(‘Promise’); resolve();<br>});<br>promise.then(function () {<br>console.log(‘Resolved.’);<br>});<br>console.log(‘Hi!’);<br>// Promise<br>// Hi!<br>// Resolved<br>// Promise新建后就会立即执行,首先输出的是“Promise”<br>// then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行<br>function loadImageAsync(url) {<br>return new Promise(function (resolve, reject) {<br>var image = new Image();<br>image.onload = function () {<br>resolve(image);<br>};<br>image.onerror = function () {<br>reject(new Error(‘Could not load image at ‘ + url));<br>};<br>image.src = url;<br>});<br>}<br>// 异步加载图片<br>var getJSON = function (url) {<br>var promise = new Promise(function (resolve, reject) {<br>var client = new XMLHttpRequest();<br>client.open(“GET”, url);<br>client.onreadystatechange = handler;<br>client.responseType = “json”;<br>client.setRequestHeader(“Accept”, “application/json”);<br>client.send(); function handler() {<br>if (this.readyState !== 4) { return; }<br>if (this.status === 200) {<br>resolve(this.response);<br>} else {<br>reject(new Error(this.statusText));<br>}<br>};<br>});<br>return promise;<br>};<br>getJSON(“/posts.json”).then(function (json) {<br>console.log(‘Contents: ‘ + json);<br>}, function (error) {<br>console.error(‘出错了’, error);<br>});<br>// Ajax操作<br>// getJSON是对XMLHttpRequest对象的封装， 用于发出一个针对JSON数据的HTTP请求， 并且返回一个Promise对象<br>var p1 = new Promise(function (resolve, reject) {<br>// …<br>});<br>var p2 = new Promise(function (resolve, reject) {<br>// …<br>resolve(p1);<br>})<br>// 一个异步操作的结果是返回另一个异步操作<br>// p1的状态决定了p2的状态<br>var p1 = new Promise(function (resolve, reject) {<br>setTimeout(() =&gt; reject(new Error(‘fail’)), 3000)<br>})<br>var p2 = new Promise(function (resolve, reject) {<br>setTimeout(() =&gt; resolve(p1), 1000)<br>})<br>p2.then(result =&gt; console.log(result))<br>.catch(error =&gt; console.log(error)) // Error: fail<br>// p1在3秒之后变为rejected<br>// p2的状态在1秒之后改变，resolve方法返回的是p1<br>// 又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数</p><p>// then()<br>getJSON(“/posts.json”).then(function (json) {<br>return json.post;<br>}).then(function (post) {<br>// …<br>});<br>// then方法返回的是一个新的Promise实例<br>// 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数<br>getJSON(“/post/1.json”).then(function (post) {<br>return getJSON(post.commentURL);<br>}).then(function funcA(comments) {<br>console.log(“Resolved: “, comments);<br>}, function funcB(err) {<br>console.log(“Rejected: “, err);<br>});<br>// 前一个回调函数，有可能返回的还是一个Promise对象<br>// 后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用<br>getJSON(“/post/1.json”).then(<br>post =&gt; getJSON(post.commentURL)<br>).then(comments =&gt; console.log(“Resolved: “, comments), err =&gt; console.log(“Rejected: “, err));</p><p>// catch()<br>getJSON(“/posts.json”).then(function (posts) {<br>// …<br>}).catch(function (error) {<br>// 处理 getJSON 和 前一个回调函数运行时发生的错误<br>console.log(‘发生错误！’, error);<br>});<br>// 是.then(null, rejection)的别名，用于指定发生错误时的回调函数<br>// getJSON方法变为Rejected或then方法指定的回调函数错误都会被catch捕获<br>// 一般不要在then方法里面定义Reject状态的回调函数，总是使用catch方法<br>p.then((val) =&gt; console.log(“fulfilled:”, val))<br>.catch((err) =&gt; console.log(“rejected:”, err));<br>// 等同于<br>p.then((val) =&gt; console.log(“fulfilled:”, val))<br>.then(null, (err) =&gt; console.log(“rejected:”, err));<br>var promise = new Promise(function (resolve, reject) {<br>throw new Error(‘test’);<br>});<br>promise.catch(function (error) {<br>console.log(error);<br>}); // Error: test<br>// promise抛出一个错误，就被catch方法指定的回调函数捕获<br>var promise = new Promise(function (resolve, reject) {<br>try { throw new Error(‘test’); }<br>catch (e) { reject(e); }<br>});<br>promise.catch(function (error) {<br>console.log(error);<br>});<br>var promise = new Promise(function (resolve, reject) {<br>reject(new Error(‘test’));<br>});<br>promise.catch(function (error) {<br>console.log(error);<br>});<br>var promise = new Promise(function (resolve, reject) {<br>resolve(‘ok’); throw new Error(‘test’);<br>});<br>promise.then(function (value) {<br>console.log(value)<br>}).catch(function (error) {<br>console.log(error)<br>}); // ok<br>// 状态已经变成Resolved，再抛出错误是无效的<br>var someAsyncThing = function () {<br>return new Promise(function (resolve, reject) {<br>// 下面一行会报错，因为x没有声明<br>resolve(x + 2);<br>});<br>};<br>someAsyncThing().catch(function (error) {<br>console.log(‘oh no’, error);<br>}).then(function () {<br>console.log(‘carry on’);<br>});<br>// oh no [ReferenceError: x is not defined]<br>// carry on<br>// catch方法返回的还是一个Promise对象<br>Promise.resolve()<br>.catch(function (error) {<br>console.log(‘oh no’, error);<br>}).then(function () {<br>console.log(‘carry on’);<br>}); // carry on<br>// 没有报错，跳过了catch方法，直接执行后面的then方法<br>// then方法里面报错，就与前面的catch无关了<br>var someAsyncThing = function () {<br>return new Promise(function (resolve, reject) {<br>// 下面一行会报错，因为x没有声明<br>resolve(x + 2);<br>});<br>};<br>someAsyncThing().then(function () {<br>return someOtherAsyncThing();<br>}).catch(function (error) {<br>console.log(‘oh no’, error);<br>// 下面一行会报错，因为y没有声明<br>y + 2;<br>}).then(function () {<br>console.log(‘carry on’);<br>});<br>// oh no [ReferenceError: x is not defined]<br>// catch方法抛出一个错误，因为后面没有别的catch方法了， 导致这个错误不会被捕获，也不会传递到外层</p><p>// Promise.all()<br>var p = Promise.all([p1, p2, p3]);<br>// 将多个Promise实例，包装成一个新的Promise实例<br>// p1、p2、p3都是Promise对象的实例<br>// 如果不是就会先调用Promise.resolve方法转为Promise实例<br>// 状态<br>// 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled<br>// 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected<br>// 第一个被reject的实例的返回值，会传递给p的回调函数<br>// 生成一个Promise对象的数组<br>var promises = [2, 3, 5, 7, 11, 13].map(function (id) {<br>return getJSON(“/post/“ + id + “.json”);<br>});<br>Promise.all(promises).then(function (posts) {<br>// …<br>}).catch(function (reason) {<br>// …<br>});<br>const databasePromise = connectDatabase();<br>const booksPromise = databaseProimse.then(findAllBooks);<br>const userPromise = databasePromise.then(getCurrentUser);<br>Promise.all([booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user));<br>// Promise.race()<br>var p = Promise.race([p1,p2,p3]);<br>// 将多个Promise实例，包装成一个新的Promise实例<br>// 有一个实例率先改变状态，p的状态就跟着改变<br>// 那个率先改变的Promise实例的返回值，就传递给p的回调函数<br>var p = Promise.race([<br>fetch(‘/resource-that-may-take-a-while’),<br>new Promise(function (resolve, reject) {<br>setTimeout(() =&gt; reject(new Error(‘request timeout’)), 5000)<br>})<br>])<br>p.then(response =&gt; console.log(response))<br>p.catch(error =&gt; console.log(error))<br>// 5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected</p><p>// Promise.resolve()<br>var jsPromise = Promise.resolve($.ajax(‘/whatever.json’));<br>// 将现有对象转为Promise对象<br>// 将jQuery生成的deferred对象，转为一个新的Promise对象<br>let thenable = {<br>then: function (resolve, reject) {<br>resolve(42);<br>}<br>};<br>let p1 = Promise.resolve(thenable);<br>p1.then(function (value) {<br>console.log(value); // 42<br>});<br>// 将这个对象转为Promise对象，然后就立即执行then方法<br>var p = Promise.resolve(‘Hello’);<br>p.then(function (s) {<br>console.log(s)<br>}); // Hello</p><p>// Promise.reject()<br>var p = Promise.reject(‘出错了’);<br>// 等同于<br>var p = new Promise((resolve, reject) =&gt; reject(‘出错了’))<br>p.then(null, function (s) {<br>console.log(s)<br>}); // 出错了<br>// 返回一个新的Promise实例，该实例的状态为rejected<br>// 附加方法<br>// done()<br>asyncFunc()<br>.then(f1)<br>.catch(r1)<br>.then(f2)<br>.done();<br>// done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误<br>// finally()<br>server.listen(0)<br>.then(function () {<br>// run test<br>}).finally(server.stop);<br>// 不管Promise对象最后状态如何，都会执行的操作<br>// 接受一个普通的回调函数作为参数<br>// 应用<br>// 加载图片<br>const preloadImage = function (path) {<br>return new Promise(function (resolve, reject) {<br>var image = new Image();<br>image.onload = resolve;<br>image.onerror = reject;<br>image.src = path;<br>});<br>};<br>// Generator函数<br>function getFoo() {<br>return new Promise(function (resolve, reject) {<br>resolve(‘foo’);<br>});<br>}<br>var g = function* () {<br>try {<br>var foo = yield getFoo(); console.log(foo);<br>}<br>catch (e) {<br>console.log(e);<br>}<br>};<br>function run(generator) {<br>var it = generator();<br>function go(result) {<br>if (result.done) return result.value;<br>return result.value.then(function (value) {<br>return go(it.next(value));<br>}, function (error) {<br>return go(it.throw(error));<br>});<br>}<br>go(it.next());<br>}<br>run(g);<br>// 使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象<br>// 函数run用来处理这个Promise对象，并调用下一个next方法</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es解构方法</title>
      <link href="/2020/04/19/web/es/es%E8%A7%A3%E6%9E%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/19/web/es/es%E8%A7%A3%E6%9E%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>// 解构</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 数组<br>var [a, b, c] = [1, 2, 3];</p><p>let [foo, [[bar], baz]] = [1, [[2], 3]];<br>foo // 1<br>bar // 2<br>baz // 3</p><p>let [ , , third] = [“foo”, “bar”, “baz”];<br>third // “baz”</p><p>let [x, , y] = [1, 2, 3];<br>x // 1<br>y // 3</p><p>let [head, …tail] = [1, 2, 3, 4];<br>head // 1<br>tail // [2, 3, 4]</p><p>let [x, y, …z] = [‘a’];<br>x // “a”<br>y // undefined 解构不成功，变量的值就等于undefined<br>z // []</p><p>//不完全解构<br>let [x, y] = [1, 2, 3];<br>x // 1<br>y // 2<br>let [a, [b], d] = [1, [2, 3], 4];<br>a // 1<br>b // 2<br>d // 4<br>let [x, y, z] = new Set([“a”, “b”, “c”]);<br>x // “a”</p><p>function* fibs() {<br>var a = 0;<br>var b = 1;<br>while (true) {<br>yield a;<br>[a, b] = [b, a + b];<br>}<br>}<br>var [first, second, third, fourth, fifth, sixth] = fibs();<br>sixth // 5</p><p>//允许指定默认值<br>var [foo = true] = [];<br>foo // true</p><p>[x, y = ‘b’] = [‘a’]; // x=’a’, y=’b’<br>[x, y = ‘b’] = [‘a’, undefined]; // x=’a’, y=’b’<br>var [x = 1] = [undefined];<br>x // 1<br>var [x = 1] = [null]; //数组成员不严格等于undefined，默认值是不会生效<br>x // null<br>function f() {<br>console.log(‘aaa’);<br>}<br>let [x = f()] = [1];// 默认值是一个表达式，那么这个表达式是惰性求值的<br>// x能取到值，所以函数f根本不会执行</p><p>let [x = 1, y = x] = []; // x=1; y=1<br>let [x = 1, y = x] = [2]; // x=2; y=2<br>let [x = 1, y = x] = [1, 2]; // x=1; y=2<br>let [x = y, y = 1] = []; // ReferenceError<br>// 可以引用解构赋值的其他变量<br>// 变量必须已经声明</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 对象<br>//对象的属性没有次序，变量必须与属性同名<br>var { foo, bar } = { foo: “aaa”, bar: “bbb” };<br>foo // “aaa”<br>bar // “bbb”<br>var { foo: baz } = { foo: ‘aaa’, bar: ‘bbb’ }; //变量名与属性名不一致时的写法, foo是匹配的模式，真正被赋值的是变量baz<br>baz // “aaa”<br>foo // error: foo is not defined</p><p>let obj = { first: ‘hello’, last: ‘world’ };<br>let { first: f, last: l } = obj;<br>f // ‘hello’<br>l // ‘world’</p><p>//对于let和const来说，变量不能重新声明<br>let foo;<br>let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration “foo”<br>let baz;<br>let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration “baz”<br>let foo;<br>({foo} = {foo: 1}); // 成功<br>let baz;<br>({bar: baz} = {bar: 1}); // 成功</p><p>var obj = {<br>p: [<br>‘Hello’,<br>{ y: ‘World’ }<br>]<br>};<br>var { p: [x, { y }] } = obj;<br>x // “Hello”<br>y // “World”</p><p>var node = {<br>loc: {<br>start: {<br>line: 1,<br>column: 5<br>}<br>}<br>};<br>var { loc: { start: { line }} } = node; //loc和start都是模式，不会被赋值<br>line // 1<br>loc // error: loc is undefined<br>start // error: start is undefined<br>let obj = {};<br>let arr = [];<br>({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });<br>obj // {prop:123}<br>arr // [true]</p><p>//指定默认值<br>var {x = 3} = {};<br>x // 3<br>var {x, y = 5} = {x: 1};<br>x // 1<br>y // 5<br>var {x:y = 3} = {};<br>y // 3<br>var {x:y = 3} = {x: 5};<br>y // 5<br>var { message: msg = ‘Something went wrong’ } = {};<br>msg // “Something went wrong”<br>// 默认值生效的条件是，对象的属性值严格等于undefined<br>var {x = 3} = {x: undefined};<br>x // 3<br>var {x = 3} = {x: null};<br>x // null</p><p>// 解构失败，变量的值等于undefined<br>var {foo} = {bar: ‘baz’};<br>foo // undefined</p><p>// 对数组进行对象属性的解构<br>let { log, sin, cos } = Math;//将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上<br>var arr = [1, 2, 3];<br>var {0 : first, [arr.length - 1] : last} = arr;<br>first // 1<br>last // 3</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 字符串<br>// 字符串被转换成了一个类似数组的对象<br>const [a, b, c, d, e] = ‘hello’;<br>a // “h”<br>b // “e”<br>c // “l”<br>d // “l”<br>e // “o”<br>let {length : len} = ‘hello’;<br>len // 5</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 数值布尔<br>// 会先转为对象<br>let {toString: s} = 123;<br>s === Number.prototype.toString // true<br>let {toString: s} = true;<br>s === Boolean.prototype.toString // true<br>// undefined和null无法转为对象，所以对它们进行解构赋值，都会报错<br>let { prop: x } = undefined; // TypeError<br>let { prop: y } = null; // TypeError</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 函数参数<br>function add([x, y]){<br>return x + y;<br>}<br>add([1, 2]); // 3<br>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); // [ 3, 7 ]</p><p>// 为函数参数设置默认值<br>function move({x = 0, y = 0} = {}) {<br>return [x, y];<br>}<br>move({x: 3, y: 8}); // [3, 8]<br>move({x: 3}); // [3, 0]<br>move({}); // [0, 0]<br>move(); // [0, 0]</p><p>// 不是为变量x和y指定默认值<br>function move({x, y} = { x: 0, y: 0 }) {<br>return [x, y];<br>}<br>move({x: 3, y: 8}); // [3, 8]<br>move({x: 3}); // [3, undefined]<br>move({}); // [undefined, undefined]<br>move(); // [0, 0]<br>// undefined就会触发函数参数的默认值<br>[1, undefined, 3].map((x = ‘yes’) =&gt; x); // [ 1, ‘yes’, 3 ]</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////<br>// 圆括号<br>// 不能使用<br>// 变量声明<br>// 全部报错,因为它们都是变量声明<br>var [(a)] = [1];<br>var {x: (c)} = {};<br>var ({x: c}) = {};<br>var {(x: c)} = {};<br>var {(x): c} = {};<br>var { o: ({ p: p }) } = { o: { p: 2 } };<br>// 函数参数<br>// 报错<br>function f([(z)]) { return z; }<br>// 赋值语句<br>// 全部报错<br>({ p: a }) = { p: 42 };<br>([a]) = [5];<br>[({ p: a }), { x: c }] = [{}, {}];<br>// 可以使用<br>// 赋值语句的非模式部分<br>[(b)] = [3]; // 正确<br>({ p: (d) } = {}); // 正确<br>[(parseInt.prop)] = [3]; // 正确</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 用途<br>// 交换变量的值<br>[x, y] = [y, x];<br>// 从函数返回多个值<br>function example() { return [1, 2, 3]; } var [a, b, c] = example();<br>function example() { return { foo: 1, bar: 2 }; } var { foo, bar } = example();<br>// 函数参数的定义<br>// 参数是一组有次序的值<br>function f([x, y, z]) { … }<br>f([1, 2, 3]);<br>// 参数是一组无次序的值<br>function f({x, y, z}) { … }<br>f({z: 3, y: 2, x: 1});<br>// 提取JSON数据<br>var jsonData = {<br>id: 42,<br>status: “OK”,<br>data: [867, 5309]<br>};<br>let { id, status, data: number } = jsonData;<br>console.log(id, status, number); // 42, “OK”, [867, 5309]<br>// 函数参数的默认值<br>jQuery.ajax = function (url, {<br>async = true,<br>beforeSend = function () {},<br>cache = true,<br>complete = function () {},<br>crossDomain = false,<br>global = true, // … more config<br>}) {<br>// … do stuff<br>};<br>// 遍历Map结构<br>var map = new Map();<br>map.set(‘first’, ‘hello’);<br>map.set(‘second’, ‘world’);<br>for (let [key, value] of map) {<br>console.log(key + “ is “ + value);<br>}<br>// first is hello<br>// second is world<br>// 获取键名<br>for (let [key] of map) {<br>// …<br>}<br>// 获取键值<br>for (let [,value] of map) {<br>// …<br>}<br>// 输入模块的指定方法<br>const { SourceMapConsumer, SourceNode } = require(“source-map”);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>es扩展方法</title>
      <link href="/2020/04/19/web/es/es%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/19/web/es/es%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>// 扩展<br>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//   字符串<br>    // Unicode表示法<br>        // 只限于\u0000——\uFFFF之间的字符<br>            “\u0061” // “a”<br>            “\uD842\uDFB7” // “𠮷”<br>            “\u20BB7” // “ 7”<br>        // 将码点放入大括号，就能正确解读该字符<br>            “\u{20BB7}” // “𠮷”<br>            “\u{41}\u{42}\u{43}” // “ABC”<br>            let hello = 123;<br>            hell\u{6F}; // 123<br>            ‘\u{1F680}’ === ‘\uD83D\uDE80’ // true<br>        // JavaScript共有6种方法可以表示一个字符<br>            ‘\z’ === ‘z’  // true<br>            ‘\172’ === ‘z’ // true<br>            ‘\x7A’ === ‘z’ // true<br>            ‘\u007A’ === ‘z’ // true<br>            ‘\u{7A}’ === ‘z’ // true</p><p>/*———————————————————- */<br>    // codePointAt() 返回32位的UTF-16字符的码点<br>        // 对于那些需要4个字节储存的字符,JavaScript会认为它们是两个字符<br>            var s = “𠮷”;<br>            s.length // 2<br>            s.charAt(0) // ‘’<br>            s.charAt(1) // ‘’<br>            s.charCodeAt(0) // 55362<br>            s.charCodeAt(1) // 57271</p><pre><code>    // 𠮷的十进制码点134071（即十六进制的20BB7）        var s = &#39;𠮷a&#39;;          s.codePointAt(0) // 134071         s.codePointAt(1) // 57271          s.charCodeAt(2) // 97        s.codePointAt(0).toString(16) // &quot;20bb7&quot;         s.charCodeAt(2).toString(16) // &quot;61&quot;    // 解决charCodeAt()参数为2的问题        var s = &#39;𠮷a&#39;;         for (let ch of s) {               console.log(ch.codePointAt(0).toString(16));         }         // 20bb7         // 61    // 测试一个字符由两个字节还是由四个字节组成        function is32Bit(c) {               return c.codePointAt(0) &gt; 0xFFFF;         }          is32Bit(&quot;𠮷&quot;) // true         is32Bit(&quot;a&quot;) // false</code></pre><p>/*———————————————————- */<br>    // String.fromCodePoint() 识别大于0xFFFF的码点<br>        // 解决String.fromCharCode不能识别大于0xFFFF的码点<br>            String.fromCharCode(0x20BB7) // “ஷ”<br>            String.fromCodePoint(0x20BB7) // “𠮷”<br>            String.fromCodePoint(0x78, 0x1f680, 0x79) === ‘x\uD83D\uDE80y’ // true</p><p>/*———————————————————- */<br>    // 遍历器接口for…of<br>      for (let codePoint of ‘foo’) {<br>          console.log(codePoint)<br>      }<br>      // “f”<br>      // “o”<br>      // “o”</p><pre><code>  var text = String.fromCodePoint(0x20BB7);    for (let i = 0; i &lt; text.length; i++) {         console.log(text[i]);   }   // &quot; &quot;   // &quot; &quot;    for (let i of text) {         console.log(i);   }   // &quot;𠮷&quot;</code></pre><p>/*———————————————————- */<br>    // at()<br>        // ES5<br>            ‘abc’.charAt(0) // “a”<br>            ‘𠮷’.charAt(0) // “\uD842”<br>        // ES6<br>            ‘abc’.at(0) // “a”<br>            ‘𠮷’.at(0) // “𠮷”</p><p>/*———————————————————- */<br>    // normalize()<br>        // Ǒ:（\u01D1）<br>            // O（\u004F）和ˇ（\u030C）合成（\u004F\u030C），JavaScript不能识别<br>            ‘\u01D1’===’\u004F\u030C’ //false<br>            ‘\u01D1’.length // 1<br>            ‘\u004F\u030C’.length // 2<br>        // 将字符的不同表示方法统一为同样的形式, 不能识别三个或三个以上字符的合成<br>            ‘\u01D1’.normalize() === ‘\u004F\u030C’.normalize() // true</p><p>/*———————————————————- */<br>    // includes(), startsWith(), endsWith()<br>        // JavaScript只有indexOf方法来确定字符包含关系<br>            var s = ‘Hello world!’;<br>            s.startsWith(‘Hello’) // true<br>            s.endsWith(‘!’) // true<br>            s.includes(‘o’) // true<br>        // 第二个参数，表示开始搜索的位置<br>            var s = ‘Hello world!’;<br>            s.startsWith(‘world’, 6) // true<br>            s.endsWith(‘Hello’, 5) // true<br>            s.includes(‘Hello’, 6) // false</p><p>/*———————————————————- */<br>    // repeat()<br>        // 返回一个新字符串，表示将原字符串重复n次<br>            ‘x’.repeat(3) // “xxx”<br>            ‘hello’.repeat(2) // “hellohello”<br>            ‘na’.repeat(0) // “”<br>        // 小数，会被取整<br>            ‘na’.repeat(2.9) // “nana”<br>        // 0到-1之间的小数，则等同于0<br>            ‘na’.repeat(Infinity) // RangeError<br>            ‘na’.repeat(-1) // RangeError<br>            ‘na’.repeat(-0.9) // “”<br>        // 参数NaN等同于0<br>            ‘na’.repeat(NaN) // “”<br>        // 字符串，则会先转换成数字<br>            ‘na’.repeat(‘na’) // “”<br>            ‘na’.repeat(‘3’) // “nanana”</p><p>/*———————————————————- */<br>    // padStart()，padEnd()<br>        // 字符串补全长度的功能<br>            ‘x’.padStart(5, ‘ab’) // ‘ababx’<br>            ‘x’.padStart(4, ‘ab’) // ‘abax’<br>            ‘x’.padEnd(5, ‘ab’) // ‘xabab’<br>            ‘x’.padEnd(4, ‘ab’) // ‘xaba’<br>            ‘xxx’.padStart(2, ‘ab’) // ‘xxx’<br>            ‘xxx’.padEnd(2, ‘ab’) // ‘xxx’<br>        // 截去超出位数的补全字符串<br>            ‘abc’.padStart(10, ‘0123456789’) // ‘0123456abc’<br>        // 默认用空格补全<br>            ‘x’.padStart(4) // ‘   x’<br>            ‘x’.padEnd(4) // ‘x   ‘<br>            ‘1’.padStart(10, ‘0’) // “0000000001”<br>            ‘12’.padStart(10, ‘0’) // “0000000012”<br>            ‘123456’.padStart(10, ‘0’) // “0000123456”<br>            ‘12’.padStart(10, ‘YYYY-MM-DD’) // “YYYY-MM-12”<br>            ‘09-12’.padStart(10, ‘YYYY-MM-DD’) // “YYYY-09-12”</p><p>/*———————————————————- */<br>    // 模板字符串<br>        // 传统写法<br>            $(‘#result’).append(<br>                ‘There are <b>‘ + basket.count + ‘</b> ‘ +<br>                ‘items in your basket, ‘ +<br>                ‘<em>‘ + basket.onSale +<br>                ‘</em> are on sale!’<br>            );<br>        // 用反引号（<code>）标识            $(&#39;#result&#39;).append(</code><br>                There are <b>${basket.count}</b> items in your basket, <em>${basket.onSale}</em>  are on sale!<br>            <code>);        // 普通字符串</code>In JavaScript ‘\n’ is a line-feed.<code>// 多行字符串</code>In JavaScript this is<br>            not legal.<code>console.log(</code>string text line 1<br>            string text line 2<code>);          // 字符串中嵌入变量            var name = &quot;Bob&quot;, time = &quot;today&quot;;</code>Hello ${name}, how are you ${time}?<code>// 空格和换行，都是被保留的，使用trim方法消除换行            $(&#39;#list&#39;).html(</code><br>                <ul><br>                    <li>first</li><br>                    <li>second</li><br>                </ul><br>            <code>.trim());        // ${}中可以进行运算、引用对象属性、调用函数            var x = 1;             var y = 2;</code>${x} + ${y} = ${x + y}<code>// &quot;1 + 2 = 3&quot;</code>${x} + ${y * 2} = ${x + y * 2}<code>// &quot;1 + 4 = 5&quot;              var obj = {x: 1, y: 2};</code>${obj.x + obj.y}<code>// 3              function fn() {                   return &quot;Hello World&quot;;             }</code>foo ${fn()} bar<code>// foo Hello World bar        //   嵌套            const tmpl = addrs =&gt;</code><br>                <table><br>                    ${addrs.map(addr =&gt; <code>&lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;                             &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;</code>).join(‘’)}<br>                </table><br>            <code>;            const data = [                     { first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; },                     { first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; },             ];              console.log(tmpl(data));             // &lt;table&gt;             //             //   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;             //   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;             //             //   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;             //   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;             //             // &lt;/table&gt;        // 引用模板字符串本身            let str = &#39;return &#39; + &#39;</code>Hello ${name}!`’;<br>            let func = new Function(‘name’, str);<br>            func(‘Jack’) // “Hello Jack!”   </p><pre><code>        let str = &#39;(name) =&gt; `Hello ${name}!`&#39;;         let func = eval.call(null, str);         func(&#39;Jack&#39;) // &quot;Hello Jack!&quot;    // 通过jsx函数，将一个DOM字符串转为React对象        jsx`               &lt;div&gt;                     &lt;input                           ref=&#39;input&#39;                           onChange=&#39;${this.handleChange}&#39;                           defaultValue=&#39;${this.state.value}&#39;                 /&gt;                       ${this.state.value}                &lt;/div&gt;         `</code></pre><p>/*———————————————————- */<br>    // String.raw()<br>        // 用来充当模板字符串的处理函数,返回一个斜杠都被转义的字符串<br>            String.raw<code>Hi\n${2+3}!</code>; // “Hi\n5!”<br>            String.raw<code>Hi\u000A!</code>; // ‘Hi\u000A!’<br>        // 斜杠已经转义不会做任何处理<br>            String.raw<code>Hi\\n</code> // “Hi\n”<br>        // raw属性的值应该是一个数组<br>            String.raw({ raw: ‘test’ }, 0, 1, 2); // ‘t0e1s2t’<br>            // 等同于<br>            String.raw({ raw: [‘t’,’e’,’s’,’t’] }, 0, 1, 2);</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//   正则<br>    // RegExp构造函数<br>      new RegExp(/abc/ig, ‘i’).flags // “i”<br>        // ES5不允许此时使用第二个参数<br>        // ES6可以，且会忽略原有的修饰符</p><p>/*———————————————————- */<br>    // 字符串的正则方法<br>      String.prototype.match;   //调用 RegExp.prototype[Symbol.match]<br>      String.prototype.replace; //调用 RegExp.prototype[Symbol.replace]<br>      String.prototype.search;  //调用 RegExp.prototype[Symbol.search]<br>      String.prototype.split;   //调用 RegExp.prototype[Symbol.split]</p><p>/*———————————————————- */<br>    // u修饰符<br>      // Unicode模式<br>        /^\uD83D/u.test(‘\uD83D\uDC2A’); // false<br>        /^\uD83D/.test(‘\uD83D\uDC2A’); // true<br>          // \uD83D\uDC2A是一个四个字节的UTF-16编码，代表一个字符<br>          // 加了u修饰符以后，ES6就会识别其为一个字符<br>      // 点字符<br>        var s = ‘𠮷’;<br>        /^.$/.test(s); // false<br>        /^.$/u.test(s); // true<br>      // Unicode字符表示法<br>        /\u{61}/.test(‘a’); // false<br>        /\u{61}/u.test(‘a’); // true<br>        /\u{20BB7}/u.test(‘𠮷’); // true<br>      // 量词<br>        /a{2}/.test(‘aa’); // true<br>        /a{2}/u.test(‘aa’); // true<br>        /𠮷{2}/.test(‘𠮷𠮷’); // false<br>        /𠮷{2}/u.test(‘𠮷𠮷’); // true<br>        /^\u{3}$/.test(‘uuu’); // true<br>        // 没有u修饰符，所以大括号被解读为量词혀ꑍߐĀ⠰蕶<br>        // 加上u修饰符，就会被解读为Unicode表达式<br>      // 预定义模式<br>        /^\S$/.test(‘𠮷’); // false<br>        /^\S$/u.test(‘𠮷’); // true<br>        // \S是预定义模式，匹配所有不是空格的字符<br>        function codePointLength(text) {<br>          var result = text.match(/[\s\S]/gu);<br>          return result ? result.length : 0;<br>        }<br>        var s = ‘𠮷𠮷’;<br>        s.length // 4<br>        codePointLength(s) // 2 正确返回字符串长度的函数</p><p>/*———————————————————- */<br>      // i修饰符<br>        /[a-z]/i.test(‘\u212A’) // false<br>        /[a-z]/iu.test(‘\u212A’) // true<br>        //   \u004B与\u212A都是大写的K<br>        //   不加u修饰符，就无法识别非规范的K字符</p><p>/*———————————————————- */<br>    // y修饰符<br>      // 粘连修饰符，必须从下一位置开始<br>      // g只要求剩余位置中存在即可<br>      // y修饰符号隐含了头部匹配的标志^<br>        var s = ‘aaa_aa_a’;<br>        var r1 = /a+/g;<br>        var r2 = /a+/y;<br>        r1.exec(s) // [“aaa”]<br>        r2.exec(s) // [“aaa”]<br>        r1.exec(s) // [“aa”]<br>        r2.exec(s) // null</p><pre><code>  //g    const REGEX = /a/g;  // 指定从2号位置（y）开始匹配     REGEX.lastIndex = 2;  // 匹配成功     const match = REGEX.exec(&#39;xaya&#39;);  // 在3号位置匹配成功     match.index // 3  // 下一次匹配从4号位开始     REGEX.lastIndex // 4  // 4号位开始匹配失败     REGEX.exec(&#39;xaxa&#39;) // null  //y    const REGEX = /a/y;  // 指定从2号位置开始匹配     REGEX.lastIndex = 2;  // 不是粘连，匹配失败     REGEX.exec(&#39;xaya&#39;) // null  指定从3号位置开始匹配     REGEX.lastIndex = 3;  // 3号位置是粘连，匹配成功     const match = REGEX.exec(&#39;xaxa&#39;);     match.index // 3     REGEX.lastIndex // 4  // 没有找到匹配     &#39;x##&#39;.split(/#/y) // [ &#39;x##&#39; ]    // 找到两个匹配     &#39;##x&#39;.split(/#/y) // [ &#39;&#39;, &#39;&#39;, &#39;x&#39; ]    &#39;#x#&#39;.split(/#/y) // [ &#39;&#39;, &#39;x#&#39; ]      &#39;##&#39;.split(/#/y) // [ &#39;&#39;, &#39;&#39;, &#39;&#39; ]  const REGEX = /a/gy;   &#39;aaxa&#39;.replace(REGEX, &#39;-&#39;) // &#39;--xa&#39;  &#39;a1a2a3&#39;.match(/a\d/y) // [&quot;a1&quot;]   &#39;a1a2a3&#39;.match(/a\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</code></pre><p>/*———————————————————- */<br>    // sticky属性,表示是否设置了y修饰符<br>      var r = /hello\d/y;<br>      r.sticky // true</p><p>/*———————————————————- */<br>    // flags属性,返回正则表达式的修饰符<br>      /abc/ig.flags // ‘gi’</p><p>/<em>———————————————————- */<br>    // RegExp.escape()<br>      function escapeRegExp(str) {<br>        return str.replace(/[-[]/{}()\</em>+?.\^$|]/g, ‘\$&amp;’);<br>      }<br>      let str = ‘/path/to/resource.html?search=query’;<br>      escapeRegExp(str);<br>      // “/path/to/resource.html?search=query”</p><p>/*———————————————————- */<br>    // 后行断言<br>      /\d+(?=%)/.exec(‘100% of US presidents have been male’);  // [“100”] 先行断言，只匹配百分号之前的数字<br>      /\d+(?!%)/.exec(‘that’s all 44 of them’) ;                // [“44”] 先行否定断言，只匹配不在百分号之前的数字<br>      /(?&lt;=$)\d+/.exec(‘Benjamin Franklin is on the $100 bill’);  // [“100”] 后行断言,只匹配美元符号之后的数字<br>      /(?&lt;!$)\d+/.exec(‘it’s is worth about €90’) ;               // [“90”] 后行断言,只匹配不在美元符号后面的数字<br>      /(?&lt;=(\d+)(\d+))$/.exec(‘1053’); // [“”, “1”, “053”]<br>      /^(\d+)(\d+)$/.exec(‘1053’); // [“1053”, “105”, “3”]<br>      /(?&lt;=(o)d\1)r/.exec(‘hodor’);  // null<br>      /(?&lt;=\1d(o))r/.exec(‘hodor’);  // [“r”, “o”]</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>//   数值<br>    // 二进制和八进制表示法<br>      0b111110111 === 503 // true<br>      0o767 === 503 // true<br>      // 将0b和0o前缀的字符串数值转为十进制<br>        Number(‘0b111’)  // 7<br>        Number(‘0o10’)  // 8</p><p>/*———————————————————- */<br>    // Number.isFinite(), 用来检查一个数值是否为有限的<br>      Number.isFinite(15); // true<br>      Number.isFinite(0.8); // true<br>      Number.isFinite(NaN); // false<br>      Number.isFinite(Infinity); // false<br>      Number.isFinite(-Infinity); // false<br>      Number.isFinite(‘foo’); // false<br>      Number.isFinite(‘15’); // false<br>      Number.isFinite(true); // false</p><p>/*———————————————————- */<br>    // Number.isNaN() , 用来检查一个值是否为NaN<br>      Number.isNaN(NaN) // true<br>      Number.isNaN(15) // false<br>      Number.isNaN(‘15’) // false<br>      Number.isNaN(true) // false<br>      Number.isNaN(9/NaN) // true<br>      Number.isNaN(‘true’/0) // true<br>      Number.isNaN(‘true’/‘true’) // true</p><p>/*———————————————————- */<br>    // Number.parseInt(), Number.parseFloat()<br>      // 全局方法parseInt()和parseFloat()，移植到Number对象上面<br>        Number.parseInt(‘12.34’) // 12<br>        Number.parseFloat(‘123.45#’) // 123.45<br>      // 逐步减少全局性方法，使得语言逐步模块化<br>        Number.parseInt === parseInt // true<br>        Number.parseFloat === parseFloat // true</p><p>/*———————————————————- */<br>    // Number.isInteger() , 判断一个值是否为整数<br>      Number.isInteger(25) // true<br>      Number.isInteger(25.0) // true<br>      Number.isInteger(25.1) // false<br>      Number.isInteger(“15”) // false<br>      Number.isInteger(true) // false</p><p>/*———————————————————- */<br>    // Number.EPSILON<br>      // 一个极小的常量,实质是一个可以接受的误差范围<br>        Number.EPSILON // 2.220446049250313e-16<br>        Number.EPSILON.toFixed(20) // ‘0.00000000000000022204’<br>      // 浮点数计算是不精确的<br>      // 误差能够小于Number.EPSILON，我们就可以认为得到了正确结果<br>        0.1 + 0.2 - 0.3 // 5.551115123125783e-17<br>        5.551115123125783e-17.toFixed(20) // ‘0.00000000000000005551’<br>        5.551115123125783e-17 &lt; Number.EPSILON // true<br>      function withinErrorMargin (left, right) {<br>        return Math.abs(left - right) &lt; Number.EPSILON;<br>      }<br>      withinErrorMargin(0.1 + 0.2, 0.3) // true<br>      withinErrorMargin(0.2 + 0.2, 0.3) // false</p><p>/*———————————————————- */<br>    // Number.isSafeInteger(),安全整数范围<br>      // JS能够准确表示的整数范围在-2^53到2^53之间（不含两个端点）<br>      // Number.isSafeInteger()用来判断一个整数是否落在这个范围之内<br>      // Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER表示这个范围的上下限<br>        Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true<br>        Number.MAX_SAFE_INTEGER === 9007199254740991 // true<br>        Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true<br>        Number.MIN_SAFE_INTEGER === -9007199254740991 // true</p><pre><code>  Number.isSafeInteger(&#39;a&#39;) // false   Number.isSafeInteger(null) // false   Number.isSafeInteger(NaN) // false   Number.isSafeInteger(Infinity) // false   Number.isSafeInteger(-Infinity) // false    Number.isSafeInteger(3) // true   Number.isSafeInteger(1.2) // false   Number.isSafeInteger(9007199254740990) // true   Number.isSafeInteger(9007199254740992) // false    Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false   Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true   Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true   Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false</code></pre><p>/*———————————————————- */<br>    // Math对象的扩展<br>      // Math.trunc() 去除一个数的小数部分，返回整数部分<br>        Math.trunc(4.1) // 4<br>        Math.trunc(4.9) // 4<br>        Math.trunc(-4.1) // -4<br>        Math.trunc(-4.9) // -4<br>        Math.trunc(-0.1234) // -0<br>        Math.trunc(‘123.456’) // 123 将其先转为数值<br>        Math.trunc(NaN);      // NaN<br>        Math.trunc(‘foo’);    // NaN<br>        Math.trunc();         // NaN</p><pre><code>  // Math.sign() 判断一个数到底是正数、负数、还是零    Math.sign(-5) // -1     Math.sign(5) // +1     Math.sign(0) // +0     Math.sign(-0) // -0     Math.sign(NaN) // NaN     Math.sign(&#39;foo&#39;); // NaN     Math.sign();      // NaN  // Math.cbrt() 用于计算一个数的立方根    Math.cbrt(-1) // -1     Math.cbrt(0)  // 0     Math.cbrt(1)  // 1     Math.cbrt(2)  // 1.2599210498948734    Math.cbrt(&#39;8&#39;) // 2     Math.cbrt(&#39;hello&#39;) // NaN  // Math.clz32()  JavaScript的整数使用32位二进制形式表示,返回一个数的32位无符号整数形式有多少个前导0    Math.clz32(0) // 32     Math.clz32(1) // 31     Math.clz32(1000) // 22     Math.clz32(0b01000000000000000000000000000000) // 1     Math.clz32(0b00100000000000000000000000000000) // 2    Math.clz32(0) // 32     //   1的二进制形式是0b1，只占1位，所以32位之中有31个前导0      Math.clz32(1) // 31     //   左移运算符（&lt;&lt;）与Math.clz32方法直接相关      Math.clz32(1 &lt;&lt; 1) // 30       Math.clz32(1 &lt;&lt; 2) // 29       Math.clz32(1 &lt;&lt; 29) // 2    //   对于小数，Math.clz32方法只考虑整数部分      Math.clz32(3.2) // 30       Math.clz32(3.9) // 30    Math.clz32() // 32     Math.clz32(NaN) // 32     Math.clz32(Infinity) // 32     Math.clz32(null) // 32     Math.clz32(&#39;foo&#39;) // 32     Math.clz32([]) // 32     Math.clz32({}) // 32     Math.clz32(true) // 31  // Math.imul()  返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数    Math.imul(2, 4)   // 8     Math.imul(-1, 8)  // -8     Math.imul(-2, -2) // 4    //   对于那些很大的数的乘法，低位数值往往都是不精确的, 它们的乘积超过了2的53次方      (0x7fffffff * 0x7fffffff)|0 // 0    //   Math.imul方法可以返回正确的值1      Math.imul(0x7fffffff, 0x7fffffff) // 1  // Math.fround() 返回一个数的单精度浮点数形式    Math.fround(0)     // 0     Math.fround(1)     // 1     Math.fround(1.337) // 1.3370000123977661     Math.fround(1.5)   // 1.5     Math.fround(NaN)   // NaN  // Math.hypot()返回所有参数的平方和的平方根    Math.hypot(3, 4);        // 5     3的平方加上4的平方，等于5的平方    Math.hypot(3, 4, 5);     // 7.0710678118654755     Math.hypot();            // 0     Math.hypot(NaN);         // NaN     Math.hypot(3, 4, &#39;foo&#39;); // NaN     Math.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755     Math.hypot(-3);          // 3  // Math.expm1() 返回ex-1，即Math.exp(x) - 1    Math.expm1(-1) // -0.6321205588285577     Math.expm1(0)  // 0     Math.expm1(1)  // 1.718281828459045  // Math.log1p() 返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN    Math.log1p(1)  // 0.6931471805599453     Math.log1p(0)  // 0     Math.log1p(-1) // -Infinity     Math.log1p(-2) // NaN  // Math.log10() 返回以10为底的x的对数。如果x小于0，则返回NaN    Math.log10(2)      // 0.3010299956639812     Math.log10(1)      // 0     Math.log10(0)      // -Infinity     Math.log10(-2)     // NaN     Math.log10(100000) // 5  // Math.log2() 返回以2为底的x的对数。如果x小于0，则返回NaN    Math.log2(3)       // 1.584962500721156     Math.log2(2)       // 1     Math.log2(1)       // 0     Math.log2(0)       // -Infinity     Math.log2(-2)      // NaN     Math.log2(1024)    // 10     Math.log2(1 &lt;&lt; 29) // 29  Math.sinh(x) // 返回x的双曲正弦  Math.cosh(x) // 返回x的双曲余弦  Math.tanh(x) // 返回x的双曲正切  Math.asinh(x) // 返回x的反双曲正弦  Math.acosh(x) // 返回x的反双曲余弦  Math.atanh(x) // 返回x的反双曲正切</code></pre><p>/<em>———————————————————- */<br>    // 指数运算符<br>      2 *</em> 2 // 4<br>      2 ** 3 // 8</p><pre><code>  let a = 2;   a **= 2;   // 等同于   a = a * a;   let b = 3;   b **= 3;   // 等同于   b = b * b * b;</code></pre><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 数组<br>    // Array.from()<br>      //用于将两类对象转为真正的数组<br>        let arrayLike = {<br>          ‘0’: ‘a’,<br>          ‘1’: ‘b’,<br>          ‘2’: ‘c’,<br>          length: 3<br>        };<br>        let arr2 = Array.from(arrayLike); // [‘a’, ‘b’, ‘c’] ES6的写法 </p><pre><code>  //querySelectorAll方法返回的是一个类似数组的对象(必须有length属性)    // NodeList对象       let ps = document.querySelectorAll(&#39;p&#39;);       Array.from(ps).forEach(function (p) {           console.log(p);       });      // arguments对象       function foo() {           var args = Array.from(arguments);           // ...       }  //扩展运算符（...）也可以将某些数据结构转为数组    // arguments对象       function foo() {           var args = [...arguments];       }      // NodeList对象       [...document.querySelectorAll(&#39;div&#39;)]   //部署了Iterator接口的数据结构，Array.from都能将其转为数组    Array.from(&#39;hello&#39;) // [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]      let namesSet = new Set([&#39;a&#39;, &#39;b&#39;])     Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]  // from()第二个参数，作用类似于数组的map方法    Array.from(arrayLike, x =&gt; x * x);     // 等同于     Array.from(arrayLike).map(x =&gt; x * x);      Array.from([1, 2, 3], (x) =&gt; x * x) // [1, 4, 9]   //取出一组DOM节点的文本内容    let spans = document.querySelectorAll(&#39;span.name&#39;);      // map()     let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);      // Array.from()     let names2 = Array.from(spans, s =&gt; s.textContent)   //将数组中布尔值为false的成员转为0    Array.from([1, , 2, , 3], (n) =&gt; n || 0) // [1, 0, 2, 0, 3]   //返回各种数据的类型    function typesOf () {         return Array.from(arguments, value =&gt; typeof value)     }     typesOf(null, [], NaN) // [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;]  ////   Array.from({ length: 2 }, () =&gt; &#39;jack&#39;) // [&#39;jack&#39;, &#39;jack&#39;]  function countSymbols(string) {       return Array.from(string).length;   }</code></pre><p>/*———————————————————- */<br>    // Array.of() 将一组值，转换为数组<br>      Array.of(3, 11, 8) // [3,11,8]<br>      Array.of(3) // [3]<br>      Array.of(3).length // 1</p><p>/*———————————————————- */<br>    // fill() 使用给定值，填充一个数组<br>      //数组中已有的元素，会被全部抹去<br>        [‘a’, ‘b’, ‘c’].fill(7) // [7, 7, 7]<br>        new Array(3).fill(7) // [7, 7, 7]</p><pre><code>  // 第二个和第三个参数，用于指定填充的起始位置和结束位置    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2) // [&#39;a&#39;, 7, &#39;c&#39;]</code></pre><p>/*———————————————————- */<br>    // includes() 返回一个布尔值，表示某个数组是否包含给定的值,代替indexOf()<br>      [1, 2, 3].includes(2);     // true<br>      [1, 2, 3].includes(4);     // false<br>      [1, 2, NaN].includes(NaN); // true</p><pre><code>  // 第二个参数表示搜索的起始位置，默认为0    [1, 2, 3].includes(3, 3);  // false     [1, 2, 3].includes(3, -1); // true</code></pre><p>/*———————————————————- */<br>    // copyWithin() 将指定位置的成员复制到其他位置，然后返回当前数组<br>      Array.prototype.copyWithin(target, start = 0, end = this.length)</p><pre><code>  // 从3号位直到数组结束的成员（4和5）， 复制到从0号位开始的位置，结果覆盖了原来的1和2    [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]  // 将3号位复制到0号位     [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]    // -2相当于3号位，-1相当于4号位     [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]    // 将3号位复制到0号位     [].copyWithin.call({length: 5, 3: 1}, 0, 3) // {0: 1, 3: 1, length: 5}    // 将2号位到数组结束，复制到0号位     var i32a = new Int32Array([1, 2, 3, 4, 5]);     i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]    // 对于没有部署TypedArray的copyWithin方法的平台 ,需要采用下面的写法     [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5]</code></pre><p>/*———————————————————- */<br>    // find() 用于找出第一个符合条件的数组成员<br>      [1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5<br>      // find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组<br>      [1, 5, 10, 15].find(function(value, index, arr) {<br>        return value &gt; 9;<br>      }) // 10</p><p>/*———————————————————- */<br>    // findIndex() 返回第一个符合条件的数组成员的位置,所有成员都不符合条件，则返回-1<br>      [1, 5, 10, 15].findIndex(function(value, index, arr) {<br>        return value &gt; 9;<br>      }) // 2<br>      // 都可以发现NaN，弥补了数组的IndexOf方法的不足<br>        [NaN].indexOf(NaN) // -1<br>        [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0</p><p>/*———————————————————- */<br>    // entries()，keys()和values() 用于遍历数组，返回一个遍历器对象<br>      for (let index of [‘a’, ‘b’].keys()) {<br>        console.log(index);<br>      }<br>      // 0<br>      // 1</p><pre><code>  for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {       console.log(elem);   }   // &#39;a&#39;   // &#39;b&#39;    for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {       console.log(index, elem);   }   // 0 &quot;a&quot;   // 1 &quot;b&quot;  // 手动调用遍历器对象的next方法，进行遍历    let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];     let entries = letter.entries();     console.log(entries.next().value); // [0, &#39;a&#39;]     console.log(entries.next().value); // [1, &#39;b&#39;]     console.log(entries.next().value); // [2, &#39;c&#39;]</code></pre><p>/*———————————————————- */<br>    // 空位<br>      // 返回一个具有3个空位的数组，空位不是undefined，一个位置的值等于undefined<br>        Array(3) // [, , ,]<br>      // 将数组的空位，转为undefined<br>        Array.from([‘a’,,’b’]); // [ “a”, undefined, “b” ]<br>        […[‘a’,,’b’]]; // [ “a”, undefined, “b” ]<br>        [,’a’,’b’,,].copyWithin(2,0); // [,”a”,,”a”]<br>        new Array(3).fill(‘a’); // [“a”,”a”,”a”]<br>        let arr = [, ,];<br>        for (let i of arr) {<br>          console.log(1);<br>        }<br>        // 1<br>        // 1</p><pre><code>  // entries()     [...[,&#39;a&#39;].entries()]; // [[0,undefined], [1,&quot;a&quot;]]    // keys()     [...[,&#39;a&#39;].keys()]; // [0,1]    // values()     [...[,&#39;a&#39;].values()]; // [undefined,&quot;a&quot;]    // find()     [,&#39;a&#39;].find(x =&gt; true); // undefined    // findIndex()     [,&#39;a&#39;].findIndex(x =&gt; true); // 0</code></pre><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>// 函数<br>    // 参数默认值<br>      // ES6允许为函数的参数设置默认值, 之前必须这样定义y = y || ‘World’;<br>        function log(x, y = ‘World’) {<br>          console.log(x, y);<br>        }<br>        log(‘Hello’) // Hello World<br>        log(‘Hello’, ‘China’) // Hello China<br>        log(‘Hello’, ‘’) // Hello</p><pre><code>  // 参数变量x是默认声明的, 在函数体中，不能用let或const再次声明    function Point(x = 0, y = 0) {         this.x = x;         this.y = y;     }      var p = new Point();     p // { x: 0, y: 0 }  // 与解构赋值默认值结合使用    function foo({x, y = 5}) {         console.log(x, y);     }      foo({}) // undefined, 5     foo({x: 1}) // 1, 5     foo({x: 1, y: 2}) // 1, 2     foo() // TypeError: Cannot read property &#39;x&#39; of undefined  // 不能省略第二个参数    function fetch(url, { body = &#39;&#39;, method = &#39;GET&#39;, headers = {} }) {         console.log(method);     }      fetch(&#39;http://example.com&#39;, {}) // &quot;GET&quot;      fetch(&#39;http://example.com&#39;) // 报错  // 双重默认值    function fetch(url, { method = &#39;GET&#39; } = {}) {         console.log(method);     }      fetch(&#39;http://example.com&#39;) // &quot;GET&quot;  // 不同的默认值定义方式    // 写法一       function m1({x = 0, y = 0} = {}) {           return [x, y];       }      // 写法二       function m2({x, y} = { x: 0, y: 0 }) {           return [x, y];       }    // 函数没有参数的情况       m1() // [0, 0]       m2() // [0, 0]      // x和y都有值的情况       m1({x: 3, y: 8}) // [3, 8]       m2({x: 3, y: 8}) // [3, 8]      // x有值，y无值的情况       m1({x: 3}) // [3, 0]       m2({x: 3}) // [3, undefined]      // x和y都无值的情况       m1({}) // [0, 0];       m2({}) // [undefined, undefined]        m1({z: 3}) // [0, 0]       m2({z: 3}) // [undefined, undefined]  // 定义了默认值的参数，应该是函数的尾参数, 无法只省略该参数，而不省略它后面的参数    // 例一       function f(x = 1, y) {           return [x, y];       }        f() // [1, undefined]       f(2) // [2, undefined])       f(, 1) // 报错       f(undefined, 1) // [1, 1]      // 例二       function f(x, y = 5, z) {           return [x, y, z];       }        f() // [undefined, 5, undefined]       f(1) // [1, 5, undefined]       f(1, ,2) // 报错       f(1, undefined, 2) // [1, 5, 2]  // length属性，将返回没有指定默认值的参数个数    (function (a) {}).length // 1     (function (a = 5) {}).length // 0     (function (a, b, c = 5) {}).length // 2  // 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了    (function (a = 0, b, c) {}).length // 0     (function (a, b = 1, c) {}).length // 1</code></pre><p>/*———————————————————- */<br>    // rest参数<br>      // ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数<br>      // rest参数之后不能再有其他参数<br>      // 函数的length属性，不包括rest参数<br>        function add(…values) {<br>          let sum = 0;<br>          for (var val of values) {<br>            sum += val;<br>          }<br>          return sum;<br>        }<br>        add(2, 5, 3) // 10<br>      // 代替arguments变量<br>        // arguments变量的写法<br>          function sortNumbers() {<br>            return Array.prototype.slice.call(arguments).sort();<br>          }<br>        // rest参数的写法<br>          const sortNumbers = (…numbers) =&gt; numbers.sort();</p><p>/*———————————————————- */<br>    // 扩展运算符（…）<br>      // 将一个数组转为用逗号分隔的参数序列<br>        console.log(…[1, 2, 3]); // 1 2 3<br>        console.log(1, …[2, 3, 4], 5); // 1 2 3 4 5<br>        […document.querySelectorAll(‘div’)] // [<div>, <div>, <div>]</p><pre><code>    function push(array, ...items) {         array.push(...items);     }      function add(x, y) {         return x + y;     }      var numbers = [4, 38];     add(...numbers) // 42  // 替代数组的apply方法    // ES5的写法       function f(x, y, z) {           // ...       }       var args = [0, 1, 2];       f.apply(null, args);      // ES6的写法       function f(x, y, z) {           // ...       }       var args = [0, 1, 2];       f(...args);    // ES5的写法       Math.max.apply(null, [14, 3, 77])      // ES6的写法       Math.max(...[14, 3, 77])        Math.max(14, 3, 77);    // ES5的写法       var arr1 = [0, 1, 2];       var arr2 = [3, 4, 5];       Array.prototype.push.apply(arr1, arr2);      // ES6的写法       var arr1 = [0, 1, 2];       var arr2 = [3, 4, 5];       arr1.push(...arr2);    // ES5       new (Date.bind.apply(Date, [null, 2015, 1, 1]))     // ES6       new Date(...[2015, 1, 1]);  // 合并数组    // ES5       [1, 2].concat(more);     // ES6       [1, 2, ...more];        var arr1 = [&#39;a&#39;, &#39;b&#39;];       var arr2 = [&#39;c&#39;];       var arr3 = [&#39;d&#39;, &#39;e&#39;];      // ES5的合并数组       arr1.concat(arr2, arr3); // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]      // ES6的合并数组       [...arr1, ...arr2, ...arr3] // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]  // 与解构赋值结合, 用于数组赋值时只能放在参数的最后一位    // ES5       a = list[0], rest = list.slice(1)     // ES6       [a, ...rest] = list    const [first, ...rest] = [1, 2, 3, 4, 5];     first // 1     rest  // [2, 3, 4, 5]      const [first, ...rest] = [];     first // undefined     rest  // []:      const [first, ...rest] = [&quot;foo&quot;];     first  // &quot;foo&quot;     rest   // []  // 函数的返回值    var dateFields = readDateFields(database);     var d = new Date(...dateFields);  // 将字符串转为真正的数组    [...&#39;hello&#39;] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]    &#39;x\uD83D\uDE80y&#39;.length; // 4     [...&#39;x\uD83D\uDE80y&#39;].length; // 3    let str = &#39;x\uD83D\uDE80y&#39;;      str.split(&#39;&#39;).reverse().join(&#39;&#39;) // &#39;y\uDE80\uD83Dx&#39;      [...str].reverse().join(&#39;&#39;) // &#39;y\uD83D\uDE80x&#39;  // Iterator接口的对象，都可以用扩展运算符转为真正的数组    var nodeList = document.querySelectorAll(&#39;div&#39;);     var array = [...nodeList];    let arrayLike = {         &#39;0&#39;: &#39;a&#39;,         &#39;1&#39;: &#39;b&#39;,         &#39;2&#39;: &#39;c&#39;,         length: 3     };      // TypeError: Cannot spread non-iterable object.     let arr = [...arrayLike];  // 变量go是一个Generator函数    var go = function*(){         yield 1;         yield 2;         yield 3;     };      [...go()] // [1, 2, 3]    let map = new Map([         [1, &#39;one&#39;],         [2, &#39;two&#39;],         [3, &#39;three&#39;],     ]);      let arr = [...map.keys()]; // [1, 2, 3]</code></pre><p>/*———————————————————- */<br>    // 严格模式<br>      // 函数参数使用了默认值、解构赋值、或者扩展运算符， 那么函数内部就不能显式设定为严格模式’use strict’;</p><p>/*———————————————————- */<br>    // name属性<br>      // 返回该函数的函数名<br>        function foo() {}<br>        foo.name // “foo”<br>      // 匿名函数<br>        var func1 = function () {};<br>        // ES5<br>        func1.name // “”<br>        // ES6<br>        func1.name // “func1”<br>      // 具名函数<br>        const bar = function baz() {};<br>        // ES5<br>        bar.name // “baz”<br>        // ES6<br>        bar.name // “baz”<br>      // 构造函数实例<br>        (new Function).name // “anonymous”<br>      // bind返回的函数, 加上“bound ”前缀<br>        function foo() {};<br>        foo.bind({}).name // “bound foo”<br>        (function(){}).bind({}).name // “bound “</p><p>/*———————————————————- */<br>    // 箭头函数 =&gt;<br>      // 箭头左边为参数，右边为返回值或代码块<br>        var f = v =&gt; v;<br>        //等同于<br>        var f = function(v) {<br>          return v;<br>        };</p><pre><code>  // 不需要参数或需要多个参数用()表示    var f = () =&gt; 5;     // 等同于     var f = function () { return 5 };      var sum = (num1, num2) =&gt; num1 + num2;     // 等同于     var sum = (num1, num2) =&gt; { return num1 + num2; }    var sum = function(num1, num2) {   return num1 + num2; };  // 直接返回一个对象，必须在对象外面加上括号    var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });  // 与变量解构结合使用    const full = ({ first, last }) =&gt; first + &#39; &#39; + last;      // 等同于     function full(person) {         return person.first + &#39; &#39; + person.last;     }  // rest参数与箭头函数结合    const numbers = (...nums) =&gt; nums;      numbers(1, 2, 3, 4, 5) // [1,2,3,4,5]      const headAndTail = (head, ...tail) =&gt; [head, tail];      headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]]    const isEven = n =&gt; n % 2 == 0;     const square = n =&gt; n * n;  // 简化回调函数    // 正常函数写法       [1,2,3].map(function (x) {           return x * x;       });      // 箭头函数写法       [1,2,3].map(x =&gt; x * x);    // 正常函数写法       var result = values.sort(function (a, b) {           return a - b;       });      // 箭头函数写法       var result = values.sort((a, b) =&gt; a - b);</code></pre><p>/*———————————————————- */<br>    // 绑定 this<br>      // 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数，取代call、apply、bind调用<br>        foo::bar;<br>        // 等同于<br>        bar.bind(foo);  </p><pre><code>    foo::bar(...arguments);     // 等同于     bar.apply(foo, arguments);      const hasOwnProperty = Object.prototype.hasOwnProperty;     function hasOwn(obj, key) {         return obj::hasOwnProperty(key);     }  // 左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面    var method = obj::obj.foo;     // 等同于     var method = ::obj.foo;      let log = ::console.log;     // 等同于     var log = console.log.bind(console);  // 采用链式写法    // 例一       import { map, takeWhile, forEach } from &quot;iterlib&quot;;        getPlayers()       ::map(x =&gt; x.character())       ::takeWhile(x =&gt; x.strength &gt; 100)       ::forEach(x =&gt; console.log(x));      // 例二       let { find, html } = jake;        document.querySelectorAll(&quot;div.myClass&quot;)       ::find(&quot;p&quot;)       ::html(&quot;hahaha&quot;);</code></pre><p>/*———————————————————- */<br>    // 尾调用优化<br>      // 最后一步是调用另一个函数，只保留内层函数的调用帧才叫优化<br>        function f(x){<br>          return g(x);<br>        }<br>      // 函数调用自身，称为递归。如果尾调用自身，就称为尾递归<br>        function factorial(n) {<br>          if (n === 1) return 1;<br>          return n * factorial(n - 1);<br>        }<br>        factorial(5) // 120</p><p>/<em>———————————————————- */<br>    // 参数尾逗号<br>      // 允许函数的最后一个参数有尾逗号<br>        function clownsEverywhere(<br>          param1,<br>          param2,<br>        ) { /</em> … */ }<br>        clownsEverywhere(<br>          ‘foo’,<br>          ‘bar’,<br>          );</p><p>///////////////////////////////////////////////////////////////////////////////////////////////////////</p><p>  // 对象<br>    // 属性的简洁表示法<br>      // 属性名为变量名, 属性值为变量的值<br>        var foo = ‘bar’;<br>        var baz = {foo};<br>        baz // {foo: “bar”}<br>        // 等同于<br>        var baz = {foo: foo};</p><pre><code>    function f(x, y) {         return {x, y};     }      // 等同于      function f(x, y) {         return {x: x, y: y};     }     f(1, 2) // Object {x: 1, y: 2}  // 方法也可以简写    var o = {         method() {             return &quot;Hello!&quot;;         }     };      // 等同于      var o = {         method: function() {             return &quot;Hello!&quot;;         }     };    var birth = &#39;2000/01/01&#39;;      var Person = {          name: &#39;张三&#39;,         birth,    //等同于 birth: birth       hello() { console.log(&#39;我的名字是&#39;, this.name); }  // 等同于hello: function ()...       };  // 用于函数的返回值    function getPoint() {         var x = 1;         var y = 10;         return {x, y};     }      getPoint() // {x:1, y:10}  // CommonJS模块输出变量    var ms = {};      function getItem (key) {         return key in ms ? ms[key] : null;     }      function setItem (key, value) {         ms[key] = value;     }      function clear () {         ms = {};     }      module.exports = { getItem, setItem, clear };     // 等同于     module.exports = {         getItem: getItem,         setItem: setItem,         clear: clear     };  // 属性的赋值器（setter）和取值器（getter）    var cart = {         _wheels: 4,          get wheels () {             return this._wheels;         },          set wheels (value) {             if (value &lt; this._wheels) {                 throw new Error(&#39;数值太小了！&#39;);             }             this._wheels = value;         }     }  // 属性名总是字符串    var obj = {         class () {}     };      // 等同于      var obj = {         &#39;class&#39;: function() {}     };  // 某个方法的值是一个Generator函数，前面需要加上星号    var obj = {         * m(){             yield &#39;hello world&#39;;         }     };</code></pre><p>/*———————————————————- */<br>    // 属性名表达式 []<br>      // 定义对象的属性<br>        // 方法一<br>          obj.foo = true;<br>        // 方法二<br>          obj[‘a’ + ‘bc’] = 123;</p><pre><code>  // 把表达式放在方括号内    var lastWord = &#39;last word&#39;;      var a = {         &#39;first word&#39;: &#39;hello&#39;,         [lastWord]: &#39;world&#39;     };      a[&#39;first word&#39;] // &quot;hello&quot;     a[lastWord]  // &quot;world&quot;     a[&#39;last word&#39;]  // &quot;world&quot;  // 表达式还可以用于定义方法名    let obj = {         [&#39;h&#39;+&#39;ello&#39;]() {             return &#39;hi&#39;;         }     };      obj.hello() // hi  // 属性名表达式与简洁表示法，不能同时使用    // 报错       var foo = &#39;bar&#39;;       var bar = &#39;abc&#39;;       var baz = { [foo] };      // 正确       var foo = &#39;bar&#39;;       var baz = { [foo]: &#39;abc&#39;};</code></pre><p>/*———————————————————- */<br>    // 方法的name属性<br>      // 对象方法也是函数，因此也有name属性<br>        var person = {<br>          sayName() {<br>            console.log(this.name);<br>          },<br>          get firstName() {<br>            return “Nicholas”;<br>          }<br>        };<br>        person.sayName.name   // “sayName”<br>        person.firstName.name // “get firstName”</p><pre><code>  // bind方法创造的函数，name属性返回加上前缀“bound”  // Function构造函数创造的函数，name属性返回“anonymous”    (new Function()).name // &quot;anonymous&quot;    var doSomething = function() {         // ...     };     doSomething.bind().name // &quot;bound doSomething&quot;    const key1 = Symbol(&#39;description&#39;);     const key2 = Symbol();     let obj = {      [key1]() {},         [key2]() {},     };     obj[key1].name // &quot;[description]&quot;     obj[key2].name // &quot;&quot;</code></pre><p>/*———————————————————- */<br>    // Object.is()<br>      // 用于解决相等运算符（==）和严格相等运算符（===）缺点<br>        Object.is(‘foo’, ‘foo’) // true<br>        Object.is({}, {}) // false<br>        +0 === -0 //true<br>        NaN === NaN // false<br>        Object.is(+0, -0) // false<br>        Object.is(NaN, NaN) // true</p><p>/*———————————————————- */<br>    // Object.assign()<br>      // 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）<br>        var target = { a: 1 };<br>        var source1 = { b: 2 };<br>        var source2 = { c: 3 };<br>        Object.assign(target, source1, source2);<br>        target // {a:1, b:2, c:3}</p><pre><code>  // 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性    var target = { a: 1, b: 1 };      var source1 = { b: 2, c: 2 };     var source2 = { c: 3 };      Object.assign(target, source1, source2);     target // {a:1, b:2, c:3}  // 参数不是对象，则会先转成对象    typeof Object.assign(2) // &quot;object&quot;  // undefined和null无法转成对象    Object.assign(undefined) // 报错     Object.assign(null) // 报错  // 只有一个参数，Object.assign会直接返回该参数  // 如果undefined和null不在首参数，就不会报错    let obj = {a: 1};     Object.assign(obj) === obj // true     Object.assign(obj, undefined) === obj // true     Object.assign(obj, null) === obj // true  // 数值、字符串和布尔值 不在首参数，不会产生效果，也不会报错  // 字符串会以数组形式，拷贝入目标对象    var v1 = &#39;abc&#39;;     var v2 = true;     var v3 = 10;      var obj = Object.assign({}, v1, v2, v3);     console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }  // 布尔值、数值、字符串分别转成对应的包装对象  // 内部属性[[PrimitiveValue]]不会被Object.assign拷贝    Object(true) // {[[PrimitiveValue]]: true}     Object(10)  //  {[[PrimitiveValue]]: 10}     Object(&#39;abc&#39;) // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}  //合并数组    Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3]  // 常见用途    // 为对象添加属性      class Point {           constructor(x, y) {               Object.assign(this, {x, y});           }       }    // 为对象添加方法      Object.assign(SomeClass.prototype, {           someMethod(arg1, arg2) {               ···           },           anotherMethod() {              ···           }       });        // 等同于下面的写法       SomeClass.prototype.someMethod = function (arg1, arg2) {           ···       };       SomeClass.prototype.anotherMethod = function () {           ···       };    // 克隆对象      // 只能克隆原始对象自身的值，不能克隆它继承的值        function clone(origin) {             return Object.assign({}, origin);         }      // 保持继承链        function clone(origin) {             let originProto = Object.getPrototypeOf(origin);             return Object.assign(Object.create(originProto), origin);         }    // 合并多个对象，合并后返回一个新对象      const merge =   (target, ...sources) =&gt; Object.assign(target, ...sources);      const merge =   (...sources) =&gt; Object.assign({}, ...sources);    // 为属性指定默认值      // 如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值      const DEFAULTS = {           logLevel: 0,           outputFormat: &#39;html&#39;       };        function processContent(options) {           options = Object.assign({}, DEFAULTS, options);       }</code></pre><p>/*———————————————————- */<br>    // 属性的可枚举性<br>      // 获取该属性的描述对象<br>      // Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性<br>        let obj = { foo: 123 };<br>        Object.getOwnPropertyDescriptor(obj, ‘foo’)<br>        //  {<br>        //    value: 123,<br>        //    writable: true,<br>        //    enumerable: true,  // enumerable属性，称为”可枚举性“<br>        //    configurable: true<br>        //  }</p><pre><code>  // toString和length属性的enumerable都是false， 因此for...in不会遍历到这两个继承自原型的属性  // 所有Class的原型的方法都是不可枚举的    Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable // false      Object.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable // false</code></pre><p>/*———————————————————- */<br>    // 属性的遍历<br>      // 遍历对象自身的和继承的可枚举属性（不含Symbol属性）<br>        for…in<br>      // 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）<br>        Object.keys(obj)<br>      // 返回一个数组，包含对象自身的所有属性,不含Symbol属性<br>        Object.getOwnPropertyNames(obj)<br>      // 返回一个数组，包含对象自身的所有Symbol属性<br>        Object.getOwnPropertySymbols(obj)<br>      // 返回一个数组，包含对象自身的所有属性<br>        Reflect.ownKeys(obj)<br>      // 遍历的次序规则<br>        // 首先遍历所有属性名为数值的属性，按照数字排序。<br>        // 其次遍历所有属性名为字符串的属性，按照生成时间排序。<br>        // 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。<br>        Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // [‘2’, ‘10’, ‘b’, ‘a’, Symbol()]</p><p>/*———————————————————- */<br>    // <strong>proto</strong><br>      // <strong>proto</strong>属性用来读取或设置当前对象的prototype对象<br>      // 无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<br>        // es6的写法<br>          var obj = {<br>            method: function() { … }<br>          };<br>          obj.<strong>proto</strong> = someOtherObj;<br>        // es5的写法<br>          var obj = Object.create(someOtherObj);<br>          obj.method = function() { … };</p><pre><code>  // Object.setPrototypeOf() 设置原型对象    // 格式       Object.setPrototypeOf(object, prototype)      // 用法       var o = Object.setPrototypeOf({}, null);    // 将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性      let proto = {};       let obj = { x: 10 };       Object.setPrototypeOf(obj, proto);        proto.y = 20;       proto.z = 40;        obj.x // 10       obj.y // 20       obj.z // 40  // Object.getPrototypeOf() 读取一个对象的prototype对象    function Rectangle() { }      var rec = new Rectangle();      Object.getPrototypeOf(rec) === Rectangle.prototype // true      Object.setPrototypeOf(rec, Object.prototype);     Object.getPrototypeOf(rec) === Rectangle.prototype // false</code></pre><p>/*———————————————————- */<br>    // Object.values()<br>      // ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的所有可遍历属性的键名<br>        var obj = { foo: “bar”, baz: 42 };<br>        Object.keys(obj) // [“foo”, “baz”]<br>      // Object.values方法返回一个数组，成员是参数对象自身的所有可遍历属性的键值<br>        let {keys, values, entries} = Object;<br>        let obj = { a: 1, b: 2, c: 3 };<br>        for (let key of keys(obj)) {<br>          console.log(key); // ‘a’, ‘b’, ‘c’<br>        }<br>        for (let value of values(obj)) {<br>          console.log(value); // 1, 2, 3<br>        }<br>        for (let [key, value] of entries(obj)) {<br>          console.log([key, value]); // [‘a’, 1], [‘b’, 2], [‘c’, 3]<br>        }<br>      // 过滤属性名为Symbol值的属性<br>        var obj = { foo: “bar”, baz: 42 };<br>        Object.values(obj) // [“bar”, 42]<br>        Object.values({ [Symbol()]: 123, foo: ‘abc’ }); // [‘abc’]<br>        Object.values(‘foo’) // [‘f’, ‘o’, ‘o’]<br>        Object.values(42) // []<br>        Object.values(true) // []</p><p>/*———————————————————- */<br>    // Object.entries()<br>      // 返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组, Symbol值会被省略<br>        var obj = { foo: ‘bar’, baz: 42 };<br>        Object.entries(obj) // [ [“foo”, “bar”], [“baz”, 42] ]<br>      // 遍历对象的属性<br>        let obj = { one: 1, two: 2 };<br>        for (let [k, v] of Object.entries(obj)) {<br>          console.log(<code>${JSON.stringify(k)}: ${JSON.stringify(v)}</code>);<br>        }<br>        // “one”: 1<br>        // “two”: 2<br>      // 将对象转为真正的Map结构<br>        var obj = { foo: ‘bar’, baz: 42 };<br>        var map = new Map(Object.entries(obj));<br>        map // Map { foo: “bar”, baz: 42 }</p><p>/*———————————————————- */<br>    // 对象的扩展运算符<br>      // 解构赋值<br>        // 解构赋值必须是最后一个参数<br>          let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };<br>          x // 1<br>          y // 2<br>          z // { a: 3, b: 4 }<br>          let { x, y, …z } = null; // 运行时错误<br>          let { x, y, …z } = undefined; // 运行时错误<br>          let { …x, y, z } = obj; // 句法错误<br>          let { x, …y, …z } = obj; // 句法错误</p><pre><code>    // 解构赋值的拷贝是浅拷贝    // 复合类型的值拷贝的是这个值的引用      let obj = { a: { b: 1 } };       let { ...x } = obj;       obj.a.b = 2;       x.a.b // 2    // 解构赋值不会拷贝继承自原型对象的属性      let o1 = { a: 1 };       let o2 = { b: 2 };       o2.__proto__ = o1;       let o3 = { ...o2 };       o3 // { b: 2 }    // 解构赋值产生的变量y和z，只能读取对象自身的属性，所以只有变量z可以赋值成功      var o = Object.create({ x: 1, y: 2 });       o.z = 3;        let { x, ...{ y, z } } = o;       x // 1       y // undefined       z // 3    // 扩展某个函数的参数      function baseFunction({ a, b }) {           // ...       }       function wrapperFunction({ x, y, ...restConfig }) {           // 使用x和y参数进行操作           // 其余参数传给原始函数           return baseFunction(restConfig);       }  // 扩展运算符    // 取出参数对象的所有可遍历属性，拷贝到当前对象之中      let z = { a: 3, b: 4 };       let n = { ...z };       n // { a: 3, b: 4 }      let aClone = { ...a };       // 等同于       let aClone = Object.assign({}, a);    // 合并两个对象      let ab = { ...a, ...b };       // 等同于       let ab = Object.assign({}, a, b);    // a对象的x属性和y属性，拷贝到新对象后会被覆盖掉      let aWithOverrides = { ...a, x: 1, y: 2 };       // 等同于       let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };       // 等同于       let x = 1, y = 2, aWithOverrides = { ...a, x, y };       // 等同于       let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });    // newVersion对象自定义了name属性， 其他属性全部复制自previousVersion对象      let newVersion = {           ...previousVersion,           name: &#39;New Name&#39; // Override the name property       };    // 自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值      let aWithDefaults = { x: 1, y: 2, ...a };       // 等同于       let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);       // 等同于       let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);    // 这个两个值会被忽略      let emptyObject = { ...null, ...undefined }; // 不报错</code></pre><p>/*———————————————————- */<br>    // Object.getOwnPropertyDescriptors()<br>      // 返回指定对象所有自身属性（非继承属性）的描述对象<br>        const obj = {<br>          foo: 123,<br>          get bar() { return ‘abc’ }<br>        };<br>        Object.getOwnPropertyDescriptors(obj)<br>        // { foo:<br>        //    { value: 123,<br>        //      writable: true,<br>        //      enumerable: true,<br>        //      configurable: true<br>        //    },<br>        //   bar:<br>        //    { get: [Function: bar],<br>        //      set: undefined,<br>        //      enumerable: true,<br>        //      configurable: true<br>        //   }<br>        // }  </p><pre><code>  // 为了解决Object.assign()无法正确拷贝get属性和set属性的问题  // 因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法    const source = {         set foo(value) {             console.log(value);         }     };      const target1 = {};     Object.assign(target1, source);      Object.getOwnPropertyDescriptor(target1, &#39;foo&#39;)     // { value: undefined,     //   writable: true,     //   enumerable: true,     //   configurable: true }  // 可以实现正确拷贝    const source = {         set foo(value) {             console.log(value);         }     };      const target2 = {};     Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));     Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)     // { get: undefined,     //   set: [Function: foo],     //   enumerable: true,     //   configurable: true }  // 简写    const shallowMerge = (target, source) =&gt; Object.defineProperties(         target,         Object.getOwnPropertyDescriptors(source)     );  // 将对象属性克隆到一个新对象。这属于浅拷贝。    const clone = Object.create(      Object.getPrototypeOf(obj),         Object.getOwnPropertyDescriptors(obj));      // 或者      const shallowClone = (obj) =&gt; Object.create(         Object.getPrototypeOf(obj),         Object.getOwnPropertyDescriptors(obj)     );  // 一个对象继承另一个对象    const obj = Object.create(prot);     obj.foo = 123;      // 或者      const obj = Object.assign(         Object.create(prot),         {foo: 123,}     );      //现在     const obj = Object.create(         prot,         Object.getOwnPropertyDescriptors({foo: 123,})     );  // 用来实现Mixin（混入）模式  // 对象a和b被混入了对象c    let mix = (object) =&gt; ({         with: (...mixins) =&gt; mixins.reduce(             (c, mixin) =&gt; Object.create(                 c, Object.getOwnPropertyDescriptors(mixin)             ), object)       });      // multiple mixins example       let a = {a: &#39;a&#39;};       let b = {b: &#39;b&#39;};       let c = {c: &#39;c&#39;};       let d = mix(c).with(a, b);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>es数据结构</title>
      <link href="/2020/04/19/web/es/es%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/04/19/web/es/es%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>ES数据结构 Map Set Symbol</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>// 基本用法<br>// 解决Object的键只能是字符串的限制<br>// 将一个DOM节点作为data对象的键<br>// element被自动转为字符串[object HTMLDivElement]<br>// Map的键实际上是跟内存地址绑定的<br>var data = {};<br>var element = document.getElementById(‘myDiv’);<br>data[element] = ‘metadata’;<br>data[‘[object HTMLDivElement]’] // “metadata”</p><p>var m = new Map();<br>var o = {p: ‘Hello World’};<br>m.set(o, ‘content’)<br>m.get(o) // “content”<br>m.has(o) // true<br>m.delete(o) // true<br>m.has(o) // false</p><p>// 可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组<br>var map = new Map([<br>[‘name’, ‘张三’],<br>[‘title’, ‘Author’]<br>]);<br>map.size // 2<br>map.has(‘name’) // true<br>map.get(‘name’) // “张三”<br>map.has(‘title’) // true<br>map.get(‘title’) // “Author”</p><p>// 接受数组作为参数时，实际上执行的是下面的算法<br>var items = [<br>[‘name’, ‘张三’],<br>[‘title’, ‘Author’]<br>];<br>var map = new Map();<br>items.forEach(([key, value]) =&gt; map.set(key, value));<br>////<br>var m = new Map([<br>[true, ‘foo’],<br>[‘true’, ‘bar’]<br>]);<br>m.get(true) // ‘foo’<br>m.get(‘true’) // ‘bar’</p><p>// 后面的值将覆盖前面的值<br>let map = new Map();<br>map<br>.set(1, ‘aaa’)<br>.set(1, ‘bbb’);<br>map.get(1) // “bbb”</p><p>// 未知的键，则返回undefined<br>new Map().get(‘asfddfsasadf’) // undefined</p><p>// 表面是针对同一个键，但实际上这是两个值<br>var map = new Map();<br>map.set([‘a’], 555);<br>map.get([‘a’]) // undefined</p><p>// 同样的值的两个实例，在Map结构中被视为两个键<br>var map = new Map();<br>var k1 = [‘a’];<br>var k2 = [‘a’];<br>map<br>.set(k1, 111)<br>.set(k2, 222);<br>map.get(k1) // 111<br>map.get(k2) // 222<br>// 简单类型的值（数字、字符串、布尔值）严格相等时其视为一个键<br>let map = new Map();<br>map.set(NaN, 123);<br>map.get(NaN) // 123<br>map.set(-0, 123);<br>map.get(+0) // 123<br>/**—————————————————————————————————- */<br>// 属性和方法<br>// 更多高级用法参考 ImmuTable.jsx<br>size // 相当于数组的length<br>set(key, value) // 返回整个Map结构，可以采用链式写法<br>let map = new Map()<br>.set(1, ‘a’)<br>.set(2, ‘b’)<br>.set(3, ‘c’);<br>get(key) // 找不到key，返回undefined<br>has(key) // 返回一个布尔值<br>delete(key) // 返回一个布尔值<br>clear() // 清除所有成员，没有返回值</p><p>/**—————————————————————————————————- */<br>// 遍历方法<br>// 可参考扩展方法里的对象方法<br>keys() // 返回键名的遍历器。<br>let map = new Map([<br>[‘F’, ‘no’],<br>[‘T’, ‘yes’],<br>]);<br>for (let key of map.keys()) {<br>console.log(key);<br>}<br>// “F”<br>// “T”</p><p>values() // 返回键值的遍历器。<br>for (let value of map.values()) {<br>console.log(value);<br>}<br>// “no”<br>// “yes”</p><p>entries() // 返回所有成员的遍历器。<br>for (let item of map.entries()) {<br>console.log(item[0], item[1]);<br>}<br>// “F” “no”<br>// “T” “yes”<br>// 或者<br>for (let [key, value] of map.entries()) {<br>console.log(key, value);<br>}<br>// 等同于使用map.entries()<br>for (let [key, value] of map) {<br>console.log(key, value);<br>}<br>// 默认遍历器接口（Symbol.iterator属性），就是entries方法<br>map[Symbol.iterator] === map.entries // true</p><p>forEach() // 遍历Map的所有成员。<br>map.forEach(function(value, key, map) {<br>console.log(“Key: %s, Value: %s”, key, value);<br>});<br>// forEach方法还可以接受第二个参数，用来绑定this<br>// forEach方法的回调函数的this，就指向reporter<br>var reporter = {<br>report: function(key, value) {<br>console.log(“Key: %s, Value: %s”, key, value);<br>}<br>};<br>map.forEach(function(value, key, map) {<br>this.report(key, value);<br>}, reporter);</p><p>/**—————————————————————————————————- */<br>// 实例<br>// 结合数组的map方法、filter方法，可以实现Map的遍历和过滤<br>let map0 = new Map()<br>.set(1, ‘a’)<br>.set(2, ‘b’)<br>.set(3, ‘c’);<br>let map1 = new Map(<br>[…map0].filter(([k, v]) =&gt; k &lt; 3)<br>); // 产生Map结构 {1 =&gt; ‘a’, 2 =&gt; ‘b’}<br>let map2 = new Map(<br>[…map0].map(([k, v]) =&gt; [k * 2, ‘_’ + v])<br>); // 产生Map结构 {2 =&gt; ‘_a’, 4 =&gt; ‘_b’, 6 =&gt; ‘_c’}</p><p>/**—————————————————————————————————- */<br>// 结构转换<br>// Map转为数组<br>let myMap = new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>[…myMap]; // [ [ true, 7 ], [ { foo: 3 }, [ ‘abc’ ] ] ]</p><p>let map = new Map([<br>[1, ‘one’],<br>[2, ‘two’],<br>[3, ‘three’],<br>]);<br>[…map.keys()]; // [1, 2, 3]<br>[…map.values()]; // [‘one’, ‘two’, ‘three’]<br>[…map.entries()]; // [[1,’one’], [2, ‘two’], [3, ‘three’]]<br>[…map]; // [[1,’one’], [2, ‘two’], [3, ‘three’]]</p><p>// 数组转为Map<br>new Map([[true, 7], [{foo: 3}, [‘abc’]]])<br>// Map {true =&gt; 7, Object {foo: 3} =&gt; [‘abc’]}</p><p>// Map转为对象<br>// 所有Map的键都是字符串时<br>function strMapToObj(strMap) {<br>let obj = Object.create(null);<br>for (let [k,v] of strMap) {<br>obj[k] = v;<br>}<br>return obj;<br>}<br>let myMap = new Map().set(‘yes’, true).set(‘no’, false);<br>strMapToObj(myMap) // { yes: true, no: false }</p><p>// Map转为JSON<br>// Map的键名都是字符串，这时可以选择转为对象JSON。<br>function strMapToJson(strMap) {<br>return JSON.stringify(strMapToObj(strMap));<br>}<br>let myMap = new Map().set(‘yes’, true).set(‘no’, false);<br>strMapToJson(myMap) // ‘{“yes”:true,”no”:false}’</p><p>// Map的键名有非字符串，这时可以选择转为数组JSON<br>function mapToArrayJson(map) {<br>return JSON.stringify([…map]);<br>}<br>let myMap = new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>mapToArrayJson(myMap) // ‘[[true,7],[{“foo”:3},[“abc”]]]’</p><p>// JSON转为Map<br>// 整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组<br>function jsonToStrMap(jsonStr) {<br>return objToStrMap(JSON.parse(jsonStr));<br>}<br>jsonToStrMap(‘{“yes”:true,”no”:false}’) // Map {‘yes’ =&gt; true, ‘no’ =&gt; false}</p><p>function jsonToMap(jsonStr) {<br>return new Map(JSON.parse(jsonStr));<br>}<br>jsonToMap(‘[[true,7],[{“foo”:3},[“abc”]]]’) // Map {true =&gt; 7, Object {foo: 3} =&gt; [‘abc’]}</p><p>//////////////////////////////////////////////////////////////////////////////////////////////////</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>// 基本用法<br>// 类似于数组，但是成员的值都是唯一的<br>var s = new Set();<br>[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));<br>for (let i of s) {<br>console.log(i);<br>} // 2 3 5 4</p><p>// 可以接受一个数组（或类似数组的对象）作为参数，用来初始化<br>var set = new Set([1, 2, 3, 4, 4]);<br>[…set] // [1, 2, 3, 4]<br>var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);<br>items.size // 5<br>function divs () {<br>return […document.querySelectorAll(‘div’)];<br>}<br>var set = new Set(divs());<br>set.size; // 56<br>// 类似于<br>divs().forEach(div =&gt; set.add(div));<br>set.size; // 56</p><p>// 去除数组的重复成员<br>[…new Set(array)];</p><p>function dedupe(array) {<br>return Array.from(new Set(array));<br>}<br>dedupe([1, 1, 2, 3]) // [1, 2, 3]</p><p>// 在Set内部，两个NaN相等, 而精确相等运算符（===）认为NaN不等于自身<br>let set = new Set();<br>let a = NaN;<br>let b = NaN;<br>set.add(a);<br>set.add(b);<br>set // Set {NaN}</p><p>// 两个空对象不相等<br>let set = new Set();<br>set.add({});<br>set.size // 1<br>set.add({});<br>set.size // 2</p><p>/**—————————————————————————————————- */<br>// 属性和方法<br>Set.prototype.constructor // 构造函数，默认就是Set函数<br>Set.prototype.size // 返回Set实例的成员总数<br>add(value) // 添加某个值，返回Set结构本身<br>delete(value) // 删除某个值，返回一个布尔值，表示删除是否成功<br>has(value) // 返回一个布尔值，表示该值是否为Set的成员<br>clear() // 清除所有成员，没有返回值</p><p>// 基本示例<br>s.add(1).add(2).add(2); // 注意2被加入了两次<br>s.size // 2<br>s.has(1) // true<br>s.has(2) // true<br>s.has(3) // false<br>s.delete(2);<br>s.has(2) // false</p><p>// 对象的写法<br>var properties = {<br>‘width’: 1,<br>‘height’: 1<br>};<br>if (properties[someName]) {<br>// do something<br>}<br>// Set的写法<br>var properties = new Set();<br>properties.add(‘width’);<br>properties.add(‘height’);<br>if (properties.has(someName)) {<br>// do something<br>}</p><p>// 将Set结构转为数组<br>var items = new Set([1, 2, 3, 4, 5]);<br>var array = Array.from(items);</p><p>/**—————————————————————————————————- */<br>// 遍历操作<br>// 遍历顺序就是插入顺序<br>// 前三个方法返回的都是遍历器对象，键名和键值是同一个值<br>keys() // 返回键名的遍历器<br>let set = new Set([‘red’, ‘green’, ‘blue’]);<br>for (let item of set.keys()) {<br>console.log(item);<br>}<br>// red<br>// green<br>// blue</p><p>values() // 返回键值的遍历器<br>for (let item of set.values()) {<br>console.log(item);<br>}<br>// red<br>// green<br>// blue</p><p>// 可以省略values方法<br>for (let x of set) {<br>console.log(x);<br>}<br>// red<br>// green<br>// blue</p><p>entries() // 返回键值对的遍历器<br>for (let item of set.entries()) {<br>console.log(item);<br>}<br>// [“red”, “red”]<br>// [“green”, “green”]<br>// [“blue”, “blue”]</p><p>forEach() // 使用回调函数遍历每个成员，没有返回值；参数依次为键值、键名、集合本身<br>let set = new Set([1, 2, 3]);<br>set.forEach((value, key) =&gt; console.log(value * 2) )<br>// 2<br>// 4<br>// 6</p><p>// 默认遍历器生成函数就是它的values方法<br>Set.prototype[Symbol.iterator] === Set.prototype.values // true</p><p>// 扩展运算符<br>let set = new Set([‘red’, ‘green’, ‘blue’]);<br>let arr = […set]; // [‘red’, ‘green’, ‘blue’]</p><p>// 去除数组的重复成员<br>let arr = [3, 5, 2, 2, 5, 5];<br>let unique = […new Set(arr)]; // [3, 5, 2]</p><p>// 数组的map和filter方法也可以用于Set<br>let set = new Set([1, 2, 3]);<br>set = new Set([…set].map(x =&gt; x * 2)); // {2, 4, 6}<br>let set = new Set([1, 2, 3, 4, 5]);<br>set = new Set([…set].filter(x =&gt; (x % 2) == 0)); // {2, 4}</p><p>// 实现并集（Union）、交集（Intersect）和差集（Difference）<br>let a = new Set([1, 2, 3]);<br>let b = new Set([4, 3, 2]);<br>// 并集<br>let union = new Set([…a, …b]); // Set {1, 2, 3, 4}<br>// 交集<br>let intersect = new Set([…a].filter(x =&gt; b.has(x))); // set {2, 3}<br>// 差集<br>let difference = new Set([…a].filter(x =&gt; !b.has(x))); // Set {1}</p><p>// 改变原来的Set结构<br>let set = new Set([1, 2, 3]);<br>set = new Set([…set].map(val =&gt; val * 2)); // 2, 4, 6<br>set = new Set(Array.from(set, val =&gt; val * 2)); // 2, 4, 6</p><p>//////////////////////////////////////////////////////////////////////////////////////////////////</p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>// 引用他人对象时，防止属性名冲突<br>// ES6引入了一种新的原始数据类型Symbol，表示独一无二的值<br>// Symbol值通过Symbol函数生成<br>// 对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型<br>// Symbol函数前不能使用new命令<br>let s = Symbol();<br>typeof s // “symbol”</p><p>// 可以接受一个字符串作为参数，表示对Symbol实例的描述<br>var s1 = Symbol(‘foo’);<br>var s2 = Symbol(‘bar’);<br>s1 // Symbol(foo)<br>s2 // Symbol(bar)<br>s1.toString() // “Symbol(foo)”<br>s2.toString() // “Symbol(bar)”</p><p>// 相同参数的Symbol函数的返回值是不相等的<br>// 没有参数的情况<br>var s1 = Symbol();<br>var s2 = Symbol();<br>s1 === s2 // false<br>// 有参数的情况<br>var s1 = Symbol(“foo”);<br>var s2 = Symbol(“foo”);<br>s1 === s2 // false</p><p>// Symbol值不能与其他类型的值进行运算<br>var sym = Symbol(‘My symbol’);<br>“your symbol is “ + sym // TypeError: can’t convert symbol to string<br><code>your symbol is ${sym}</code> // TypeError: can’t convert symbol to string</p><p>// Symbol值可以显式转为字符串<br>var sym = Symbol(‘My symbol’);<br>String(sym) // ‘Symbol(My symbol)’<br>sym.toString() // ‘Symbol(My symbol)’</p><p>// 可以转为布尔值，但是不能转为数值<br>var sym = Symbol();<br>Boolean(sym) // true<br>!sym // false<br>if (sym) {<br>// …<br>}<br>Number(sym) // TypeError<br>sym + 2 // TypeError</p><p>/**—————————————————————————————————- */</p><h2 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h2><p>// 保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖<br>// 在对象的内部，Symbol值必须放在方括号之中<br>var mySymbol = Symbol();<br>// 第一种写法<br>var a = {};<br>a[mySymbol] = ‘Hello!’;<br>// 第二种写法<br>var a = {<br>[mySymbol]: ‘Hello!’<br>};<br>// 第三种写法<br>var a = {};<br>Object.defineProperty(a, mySymbol, { value: ‘Hello!’ });</p><p>a[mySymbol] // “Hello!”</p><p>// 不能用点运算符，因为点运算符后面总是字符串<br>var mySymbol = Symbol();<br>var a = {};<br>a.mySymbol = ‘Hello!’;<br>a[mySymbol] // undefined<br>a[‘mySymbol’] // “Hello!”</p><p>// 任何值都不可能有相同的值了，因此可以保证switch语句会按设计的方式工作<br>const COLOR_RED = Symbol();<br>const COLOR_GREEN = Symbol();<br>function getComplement(color) {<br>switch (color) {<br>case COLOR_RED:<br>return COLOR_GREEN;<br>case COLOR_GREEN:<br>return COLOR_RED;<br>default:<br>throw new Error(‘Undefined color’);<br>}<br>}</p><p>/**—————————————————————————————————- */</p><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>// Symbol作为属性名，该属性不会出现在for…in、for…of循环中， 也不会被Object.keys()、Object.getOwnPropertyNames()返回<br>// Object.getOwnPropertySymbols可以当前对象的所有用作属性名的Symbol值<br>var obj = {};<br>var a = Symbol(‘a’);<br>var b = Symbol(‘b’);<br>obj[a] = ‘Hello’;<br>obj[b] = ‘World’;<br>var objectSymbols = Object.getOwnPropertySymbols(obj);<br>objectSymbols // [Symbol(a), Symbol(b)]</p><p>// Reflect.ownKeys方法可以返回所有类型的键名<br>let obj = {<br>[Symbol(‘my_key’)]: 1,<br>enum: 2,<br>nonEnum: 3<br>};<br>Reflect.ownKeys(obj) // [Symbol(my_key), ‘enum’, ‘nonEnum’]</p><p>/**—————————————————————————————————- */</p><h2 id="for-和keyFor"><a href="#for-和keyFor" class="headerlink" title="for()和keyFor()"></a>for()和keyFor()</h2><p>// 接受一个字符串作为参数<br>// 有以该参数作为名称的Symbol值，就返回这个Symbol值<br>var s1 = Symbol.for(‘foo’);<br>var s2 = Symbol.for(‘foo’);<br>s1 === s2 // true</p><p>// 返回一个已登记的Symbol类型值的key<br>var s1 = Symbol.for(“foo”);<br>Symbol.keyFor(s1) // “foo”<br>var s2 = Symbol(“foo”);<br>Symbol.keyFor(s2) // undefined</p><p>/**—————————————————————————————————- */</p><h2 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h2><p>Symbol.hasInstance<br>// 当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法<br>class MyClass {<br><a href="foo">Symbol.hasInstance</a> {<br>return foo instanceof Array;<br>}<br>}<br>[1, 2, 3] instanceof new MyClass() // true<br>class Even {<br>static <a href="obj">Symbol.hasInstance</a> {<br>return Number(obj) % 2 === 0;<br>}<br>}<br>1 instanceof Even // false<br>2 instanceof Even // true<br>12345 instanceof Even // false</p><p>Symbol.isConcatSpreadable<br>// 一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开<br>// 数组的默认行为是可以展开,true或undefined，都有这个效果<br>let arr1 = [‘c’, ‘d’];<br>[‘a’, ‘b’].concat(arr1, ‘e’) // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]<br>arr1[Symbol.isConcatSpreadable] // undefined</p><p>let arr2 = [‘c’, ‘d’];<br>arr2[Symbol.isConcatSpreadable] = false;<br>[‘a’, ‘b’].concat(arr2, ‘e’) // [‘a’, ‘b’, [‘c’,’d’], ‘e’]</p><p>// 类似数组的对象也可以展开（带length属性的对象）,必须手动打开<br>let obj = {length: 2, 0: ‘c’, 1: ‘d’};<br>[‘a’, ‘b’].concat(obj, ‘e’) // [‘a’, ‘b’, obj, ‘e’]<br>obj[Symbol.isConcatSpreadable] = true;<br>[‘a’, ‘b’].concat(obj, ‘e’) // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</p><p>// 类A1是可展开的，类A2是不可展开的<br>class A1 extends Array {<br>constructor(args) {<br>super(args);<br>this[Symbol.isConcatSpreadable] = true;<br>}<br>}<br>class A2 extends Array {<br>constructor(args) {<br>super(args);<br>this[Symbol.isConcatSpreadable] = false;<br>}<br>}</p><p>let a1 = new A1();<br>a1[0] = 3;<br>a1[1] = 4;<br>let a2 = new A2();<br>a2[0] = 5;<br>a2[1] = 6;<br>[1, 2].concat(a1).concat(a2) // [1, 2, 3, 4, [5, 6]]<br>Symbol.species<br>// Symbol.species属性默认的读取器<br>// 如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象<br>static <a href="">Symbol.species</a> {<br>return this;<br>}<br>Symbol.match<br>String.prototype.match(regexp)<br>// 等同于<br>regexp<a href="this">Symbol.match</a><br>class MyMatcher {<br><a href="string">Symbol.match</a> {<br>return ‘hello world’.indexOf(string);<br>}<br>}<br>‘e’.match(new MyMatcher()) // 1<br>Symbol.replace<br>String.prototype.replace(searchValue, replaceValue)<br>// 等同于<br>searchValue[Symbol.replace](this, replaceValue)<br>Symbol.search<br>String.prototype.search(regexp)<br>// 等同于<br>regexp<a href="this">Symbol.search</a><br>class MySearch {<br>constructor(value) {<br>this.value = value;<br>}<br><a href="string">Symbol.search</a> {<br>return string.indexOf(this.value);<br>}<br>}<br>‘foobar’.search(new MySearch(‘foo’)) // 0<br>Symbol.split<br>String.prototype.split(separator, limit)<br>// 等同于<br>separator[Symbol.split](this, limit)<br>Symbol.iterator<br>// 指向该对象的默认遍历器方法<br>var myIterable = {};<br>myIterable[Symbol.iterator] = function* () {<br>yield 1;<br>yield 2;<br>yield 3;<br>};<br>[…myIterable] // [1, 2, 3]<br>class Collection {<br>*<a href="">Symbol.iterator</a> {<br>let i = 0;<br>while(this[i] !== undefined) {<br>yield this[i];<br>++i;<br>}<br>}<br>}<br>let myCollection = new Collection();<br>myCollection[0] = 1;<br>myCollection[1] = 2;<br>for(let value of myCollection) {<br>console.log(value);<br>}<br>// 1<br>// 2<br>Symbol.toPrimitive<br>// 接受一个字符串参数，表示当前运算的模式<br>// Number：该场合需要转成数值<br>// String：该场合需要转成字符串<br>// Default：该场合可以转成数值，也可以转成字符串<br>let obj = { <a href="hint">Symbol.toPrimitive</a> {<br>switch (hint) {<br>case ‘number’:<br>return 123;<br>case ‘string’:<br>return ‘str’;<br>case ‘default’:<br>return ‘default’;<br>default:<br>throw new Error();<br>}<br>}<br>};<br>2 * obj // 246<br>3 + obj // ‘3default’<br>obj == ‘default’ // true<br>String(obj) // ‘str’</p><p>Symbol.toStringTag<br>// 用来定制[object Object]或[object Array]中object后面的那个字符串<br>({[Symbol.toStringTag]: ‘Foo’}.toString()) // “[object Foo]”<br>class Collection {<br>get <a href="">Symbol.toStringTag</a> {<br>return ‘xxx’;<br>}<br>}<br>var x = new Collection();<br>Object.prototype.toString.call(x) // “[object xxx]”<br>// JSON[Symbol.toStringTag]：’JSON’<br>// Math[Symbol.toStringTag]：’Math’<br>// M[Symbol.toStringTag]：’Module’ // Module对象<br>// ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’<br>// DataView.prototype[Symbol.toStringTag]：’DataView’<br>// Map.prototype[Symbol.toStringTag]：’Map’<br>// Promise.prototype[Symbol.toStringTag]：’Promise’<br>// Set.prototype[Symbol.toStringTag]：’Set’<br>// %TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’<br>// WeakMap.prototype[Symbol.toStringTag]：’WeakMap’<br>// WeakSet.prototype[Symbol.toStringTag]：’WeakSet’<br>// %MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’<br>// %SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’<br>// %StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’<br>// Symbol.prototype[Symbol.toStringTag]：’Symbol’<br>// Generator.prototype[Symbol.toStringTag]：’Generator’<br>// GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’</p><p>Symbol.unscopables<br>// 指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除<br>// 数组有6个属性，会被with命令排除<br>Array.prototype[Symbol.unscopables]<br>// {<br>// copyWithin: true,<br>// entries: true,<br>// fill: true,<br>// find: true,<br>// findIndex: true,<br>// keys: true<br>// }<br>Object.keys(Array.prototype[Symbol.unscopables])<br>// [‘copyWithin’, ‘entries’, ‘fill’, ‘find’, ‘findIndex’, ‘keys’]</p><p>// 没有unscopables时<br>class MyClass {<br>foo() { return 1; }<br>}<br>var foo = function () { return 2; };<br>with (MyClass.prototype) {<br>foo(); // 1<br>}</p><p>// 有unscopables时<br>class MyClass {<br>foo() { return 1; }<br>get <a href="">Symbol.unscopables</a> {<br>return { foo: true };<br>}<br>}<br>var foo = function () { return 2; };<br>with (MyClass.prototype) {<br>foo(); // 2<br>}<br>/<em>*—————————————————————————————————- */<br>// 实例<br>// 消除魔术字符串<br>function getArea(shape, options) {<br>var area = 0;<br>switch (shape) {<br>case ‘Triangle’: // 魔术字符串<br>area = .5 * options.width * options.height;<br>break;<br>/</em> … more code … */<br>}<br>return area;<br>}<br>getArea(‘Triangle’, { width: 100, height: 100 }); // 魔术字符串</p><p>// 常用的消除魔术字符串的方法，就是把它写成一个变量。<br>var shapeType = {<br>triangle: ‘Triangle’ // 改成变量解决 triangle: Symbol()<br>};<br>function getArea(shape, options) {<br>var area = 0;<br>switch (shape) {<br>case shapeType.triangle:<br>area = .5 * options.width * options.height;<br>break;<br>}<br>return area;<br>}<br>getArea(shapeType.triangle, { width: 100, height: 100 });</p><p>// 模块的 Singleton 模式：指的是调用一个类，任何时候返回的都是同一个实例<br>// mod.js<br>function A() {<br>this.foo = ‘hello’;<br>}<br>if (!global._foo) {<br>global._foo = new A();<br>}<br>module.exports = global._foo;</p><p>// 变量a任何时候加载的都是A的同一个实例<br>// 但全局变量global._foo是可写的，会使其失真<br>var a = require(‘./mod.js’);<br>console.log(a.foo);</p><p>// mod.js<br>const FOO_KEY = Symbol.for(‘foo’);<br>function A() {<br>this.foo = ‘hello’;<br>}<br>if (!global[FOO_KEY]) {<br>global[FOO_KEY] = new A();<br>}<br>module.exports = global[FOO_KEY];</p><p>// 可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写<br>// 如果使用Symbol方法，外部将无法引用这个值，当然也就无法改写<br>var a = require(‘./mod.js’); ·</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器通讯协议</title>
      <link href="/2020/04/19/web/browser/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/04/19/web/browser/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Http"><a href="#一、Http" class="headerlink" title="一、Http"></a>一、Http</h1><h2 id="1、http协议"><a href="#1、http协议" class="headerlink" title="1、http协议"></a>1、http协议</h2><h3 id="1-1、特点"><a href="#1-1、特点" class="headerlink" title="1.1、特点"></a>1.1、特点</h3><p>简单快速<br>灵活<br>不同的数据类型<br>无连接<br>请求完就断开<br>无状态</p><h3 id="1-2、请求报文与响应报文格式"><a href="#1-2、请求报文与响应报文格式" class="headerlink" title="1.2、请求报文与响应报文格式"></a>1.2、请求报文与响应报文格式</h3><p>请求报文</p><p>请求行：包含请求方法、URI、HTTP版本信息<br>请求首部字段<br>请求内容实体<br>响应报文</p><p>状态行：包含HTTP版本、状态码、状态码的原因短语<br>响应首部字段<br>响应内容实体</p><h3 id="1-3、常见HTTP首部字段"><a href="#1-3、常见HTTP首部字段" class="headerlink" title="1.3、常见HTTP首部字段"></a>1.3、常见HTTP首部字段</h3><p>a、通用首部字段（请求报文与响应报文都会使用的首部字段）</p><p>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式<br>b、请求首部字段（请求报文会使用的首部字段）</p><p>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言<br>c、响应首部字段（响应报文会使用的首部字段）</p><p>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的URI<br>Server：HTTP服务器的安装信息<br>d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</p><p>Allow：资源可支持的HTTP方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p><h3 id="1-4、HTTP1-1版本新特性"><a href="#1-4、HTTP1-1版本新特性" class="headerlink" title="1.4、HTTP1.1版本新特性"></a>1.4、HTTP1.1版本新特性</h3><p>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求<br>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应<br>断点续传原理</p><h2 id="2、请求方法"><a href="#2、请求方法" class="headerlink" title="2、请求方法"></a>2、请求方法</h2><h3 id="2-1、GET"><a href="#2-1、GET" class="headerlink" title="2.1、GET"></a>2.1、GET</h3><p>用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器<br>GET /books/?sex=man&amp;name=Professional HTTP/1.1<br>Host: <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Connection: Keep-Alive</p><h3 id="2-2、POST"><a href="#2-2、POST" class="headerlink" title="2.2、POST"></a>2.2、POST</h3><p>用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。<br>默认使用浏览器原生form表单编码格式 application/x-www-form-urlencoded<br>：<br>POST / HTTP/1.1<br>Host: <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 40<br>Connection: Keep-Alive<br>sex=man&amp;name=Professional<br>使用表单上传文件时使用 multipart/form-data 编码格式：<br>POST <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> HTTP/1.1<br>Content-Type:multipart/form-data; boundary=—-WebKitFormBoundaryrGKCBY7qhFd3TrwA<br>——WebKitFormBoundaryrGKCBY7qhFd3TrwA<br>Content-Disposition: form-data; name=”text”<br>title<br>——WebKitFormBoundaryrGKCBY7qhFd3TrwA<br>Content-Disposition: form-data; name=”file”; filename=”chrome.png”<br>Content-Type: image/png<br>PNG … content of chrome.png …<br>——WebKitFormBoundaryrGKCBY7qhFd3TrwA–</p><p>其他编码格式：</p><p>application/json<br>text/xml<br>application/x-protobuf<br>二进制格式</p><h3 id="2-3、PUT"><a href="#2-3、PUT" class="headerlink" title="2.3、PUT"></a>2.3、PUT</h3><p>传输文件，报文主体中包含文件内容，保存到对应URI位置。</p><h3 id="2-4、PATCH"><a href="#2-4、PATCH" class="headerlink" title="2.4、PATCH"></a>2.4、PATCH</h3><p>同PUT,传输部份数据进行局部修改</p><h3 id="2-5、DELETE"><a href="#2-5、DELETE" class="headerlink" title="2.5、DELETE"></a>2.5、DELETE</h3><p>删除文件，与PUT方法相反，删除对应URI位置的文件。</p><h3 id="2-6、HEAD"><a href="#2-6、HEAD" class="headerlink" title="2.6、HEAD"></a>2.6、HEAD</h3><p>获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</p><h3 id="2-7、OPTION"><a href="#2-7、OPTION" class="headerlink" title="2.7、OPTION"></a>2.7、OPTION</h3><p>查询相应URI支持的HTTP方法。</p><h3 id="2-8-GET方法与POST方法的区别"><a href="#2-8-GET方法与POST方法的区别" class="headerlink" title="2.8 GET方法与POST方法的区别"></a>2.8 GET方法与POST方法的区别</h3><p>get浏览器回退时无害,可以被收藏,会被主动缓存,只能url编码，参数会保留历史记录里,参数有长度限制2kb</p><p>get重点在从服务器上获取资源，post重点在向服务器发送数据；<br>get传输数据是通过URL请求，参数是暴露的；post传输数据封存在请求实体中发送给服务器，更加安全<br>Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；<br>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。<br>post支持标准字符集，可以正确传递中文字符。</p><h2 id="3、响应状态"><a href="#3、响应状态" class="headerlink" title="3、响应状态"></a>3、响应状态</h2><p>HTTP/1.1 200 OK<br>Server:Apache Tomcat/5.0.12<br>Date:Mon,6Oct2003 13:23:42 GMT<br>Content-Length:112</p><html>...<h3 id="3-1、1xx-消息"><a href="#3-1、1xx-消息" class="headerlink" title="3.1、1xx 消息"></a>3.1、1xx 消息</h3><p>100<br>Continue</p><h3 id="3-2、2xx-成功"><a href="#3-2、2xx-成功" class="headerlink" title="3.2、2xx 成功"></a>3.2、2xx 成功</h3><p>200<br>OK<br>请求成功<br>201<br>Created<br>创建成功<br>202<br>Accepted<br>供处理的请求已被接受，但是处理未完成。<br>204<br>No Content<br>删除成功</p><h3 id="3-3、3xx-重定向"><a href="#3-3、3xx-重定向" class="headerlink" title="3.3、3xx 重定向"></a>3.3、3xx 重定向</h3><p>301<br>Moved Permanently<br>永久重定向<br>302<br>Found<br>临时重定向<br>304<br>从缓存中取</p><h3 id="3-4、4xx-客户端错误"><a href="#3-4、4xx-客户端错误" class="headerlink" title="3.4、4xx 客户端错误"></a>3.4、4xx 客户端错误</h3><p>400<br>Bad Request<br>401<br>Unauthorized<br>403<br>Forbidden<br>404<br>Not Found</p><h3 id="3-5、5xx-服务器错误"><a href="#3-5、5xx-服务器错误" class="headerlink" title="3.5、5xx 服务器错误"></a>3.5、5xx 服务器错误</h3><p>500<br>Internal Server Error<br>502<br>Bad Gateway</p><h2 id="4、过程"><a href="#4、过程" class="headerlink" title="4、过程"></a>4、过程</h2><p>1、浏览器会开启一个线程来处理这个请求，对URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>4、进行HTTP协议会话，客户端发送报头(请求报头);<br>5、进入到web服务器上的 WebServer，如 Apache、Tomcat、Node.js 等服务器;<br>6、进入部署好的后端应用，如PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。<br><a href="http://www.cnblogs.com/rollenholt/archive/2012/03/23/2414345.html" target="_blank" rel="noopener">参考：浏览器访问过程</a></p><h1 id="二、Https"><a href="#二、Https" class="headerlink" title="二、Https"></a>二、Https</h1><h2 id="1、HTTP的缺点"><a href="#1、HTTP的缺点" class="headerlink" title="1、HTTP的缺点"></a>1、HTTP的缺点</h2><p>a、通信使用明文不加密，内容可能被窃听<br>b、不验证通信方身份，可能遭到伪装<br>c、无法验证报文完整性，可能被篡改</p><h2 id="2、https"><a href="#2、https" class="headerlink" title="2、https"></a>2、https</h2><p>HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p><h1 id="三、Http2"><a href="#三、Http2" class="headerlink" title="三、Http2"></a>三、Http2</h1><h1 id="四、WebSocket"><a href="#四、WebSocket" class="headerlink" title="四、WebSocket"></a>四、WebSocket</h1><h1 id="五、TCP-IP"><a href="#五、TCP-IP" class="headerlink" title="五、TCP/IP"></a>五、TCP/IP</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器性能忧化</title>
      <link href="/2020/04/19/web/browser/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/04/19/web/browser/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一、性能优化"><a href="#一、性能优化" class="headerlink" title="一、性能优化"></a>一、性能优化</h1><h2 id="1、css"><a href="#1、css" class="headerlink" title="1、css"></a>1、css</h2><p>把多个 CSS 文件合成一个<br>合并css，如margin-top,margin-left写成一行margin:<br>把 CSS 放到代码页上端</p><p>css压缩</p><h2 id="2、图片"><a href="#2、图片" class="headerlink" title="2、图片"></a>2、图片</h2><p>多个图片文件合并成一张，进行定位来展示某区域的图<br>给图片设好宽高，避免加载时计算大小造成的重排<br>图片压缩</p><h2 id="3、js"><a href="#3、js" class="headerlink" title="3、js"></a>3、js</h2><p>减少对DOM的操作，减少页面的重绘。<br>预载入组件或延迟载入组件<br>脚本放到 HTML 代码页底部,减少对页面的阻塞。</p><h2 id="4、DNS"><a href="#4、DNS" class="headerlink" title="4、DNS"></a>4、DNS</h2><p>对域名进行预解析</p><pre><code class="javascript">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot; /&gt;</code></pre><h2 id="5、CDN"><a href="#5、CDN" class="headerlink" title="5、CDN"></a>5、CDN</h2><p>采用CDN来加速资源加载</p><h2 id="6、缓存"><a href="#6、缓存" class="headerlink" title="6、缓存"></a>6、缓存</h2><p>服务器缓存<br>HTTP服务器的文件缓存<br>浏览器缓存<br>强缓存<br>expires 绝对时间<br>cache-control 相对时间<br>max-age=3600 秒<br>协商缓存<br>last-modified if-modified-since<br>etag if-none-match</p><h2 id="7、请求"><a href="#7、请求" class="headerlink" title="7、请求"></a>7、请求</h2><p>资源压缩合并，减少http请求</p><h2 id="8、异步加载"><a href="#8、异步加载" class="headerlink" title="8、异步加载"></a>8、异步加载</h2><p>动态脚本加载<br>defer</p><script src="./defer1.js" charset="utf-8" defer></script><p>html解析完成之后才会执行<br>执行顺序按照加载顺序依次执行<br>async</p><script src="./async1.js" charset="utf-8" async></script><p>加载完成后执行<br>执行顺序和加载顺序无关</p><h1 id="二、性能测试工具"><a href="#二、性能测试工具" class="headerlink" title="二、性能测试工具"></a>二、性能测试工具</h1><p>Profiler<br>JSPerf</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器安全性</title>
      <link href="/2020/04/19/web/browser/%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2020/04/19/web/browser/%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、跨站攻击"><a href="#一、跨站攻击" class="headerlink" title="一、跨站攻击"></a>一、跨站攻击</h1><h2 id="1、CSRF（Cross-site-request-forgery，跨站请求伪造）"><a href="#1、CSRF（Cross-site-request-forgery，跨站请求伪造）" class="headerlink" title="1、CSRF（Cross-site request forgery，跨站请求伪造）"></a>1、CSRF（Cross-site request forgery，跨站请求伪造）</h2><p>伪造请求，冒充用户在站内的正常操作。</p><p>防御措施：<br>关键操作只接受POST请求</p><p>验证码<br>检测 Referer<br>服务器不是任何时候都能接受到Referer的值，一般用于监控 CSRF 攻击的发生<br>Token<br>主流的做法</p><h2 id="2、XSS（Cross-Site-Scripting，跨站脚本攻击）"><a href="#2、XSS（Cross-Site-Scripting，跨站脚本攻击）" class="headerlink" title="2、XSS（Cross Site Scripting，跨站脚本攻击）"></a>2、XSS（Cross Site Scripting，跨站脚本攻击）</h2><p>是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p><p>防御<br>过滤用户的输入，对用户的输入进行 HTML escape</p><p><code>&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt;</code><br>经过 escape 之后就成了：<br><code>&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;</code><br>像普通文本一样显示出来，变得无毒无害，不能执行了。</p><h2 id="3、sql注入"><a href="#3、sql注入" class="headerlink" title="3、sql注入"></a>3、sql注入</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器兼容性</title>
      <link href="/2020/04/19/web/browser/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
      <url>/2020/04/19/web/browser/%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是O(n2) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。通俗来说就是你们中间谁最小谁就出列，站到队列的最后边，然后继续对着剩余的无序数组说你们中间谁最小谁就出列，站到队列的最后边，一直到最后一个，继续站到最后边，这样数组就有了顺序，从小到大。</p><h1 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h1><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><h1 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h1><pre><code class="javascript">function selectionSort(arr) {var len = arr.length;var minIndex, temp;for (var i = 0; i &lt; len - 1; i++) {minIndex = i;for (var j = i + 1; j &lt; len; j++) {if (arr[j] &lt; arr[minIndex]) { // 寻找最小的数minIndex = j; // 将最小数的索引保存}}temp = arr[i];arr[i] = arr[minIndex];arr[minIndex] = temp;}return arr;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器内核及兼容性</title>
      <link href="/2020/04/19/web/browser/%E5%86%85%E6%A0%B8/"/>
      <url>/2020/04/19/web/browser/%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器核心"><a href="#浏览器核心" class="headerlink" title="浏览器核心"></a>浏览器核心</h1><p>主要是指“渲染引擎” Rendering Engine ，习惯称为“浏览器内核”。</p><h1 id="一、渲染引擎"><a href="#一、渲染引擎" class="headerlink" title="一、渲染引擎"></a>一、渲染引擎</h1><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><h3 id="1-1、渲染过程"><a href="#1-1、渲染过程" class="headerlink" title="1.1、渲染过程"></a>1.1、渲染过程</h3><p>解析 HTML Source，构建 DOM Tree<br>解析 CSS Style，构建 CSSOM Tree<br>组合 DOM Tree 与 CSSOM Tree，去除不可见元素，构建 Render Tree<br>执行 Reflow，根据 Render Tree 计算每个可见元素的布局<br>执行 Repaint，通过绘制流程，将每个像素渲染到屏幕上</p><h3 id="1-2、reflow-重排"><a href="#1-2、reflow-重排" class="headerlink" title="1.2、reflow 重排"></a>1.2、reflow 重排</h3><p>发生在 Render Tree 阶段<br>确定每个元素在屏幕上的几何属性，需要大量计算每个元素的位置<br>每改变一个元素的几何属性，均会发生一次回流过程</p><h3 id="1-3、repaint-重绘"><a href="#1-3、repaint-重绘" class="headerlink" title="1.3、repaint 重绘"></a>1.3、repaint 重绘</h3><p>发生在 reflow 过程之后<br>将元素的颜色、背景等属性绘制出来<br>改变一次元素的颜色等属性时均会对相关元素执行一次重绘。</p><h3 id="1-4、减少reflow和repaint"><a href="#1-4、减少reflow和repaint" class="headerlink" title="1.4、减少reflow和repaint"></a>1.4、减少reflow和repaint</h3><p>减少 JS 逐行修改元素样式</p><pre><code>let body = document.getElementsByTagName(&#39;body&#39;)[0];body.className += &#39; class-name&#39;;</code></pre><p>离线处理 DOM 操作</p><p>通过 documentFragment 集中处理临时操作；<br>克隆节点进行操作，然后进行原节点替换；<br>使用 display:none; 进行批量操作。<br>减少样式的重新计算</p><p>减少 offset、scroll、client*、getComputedStyle、currentStyle 的使用，<br>因为每次调用都会刷新操作缓冲区，执行 reflow &amp; repaint。</p><h2 id="2、渲染引擎分类"><a href="#2、渲染引擎分类" class="headerlink" title="2、渲染引擎分类"></a>2、渲染引擎分类</h2><h3 id="2-1、Trident-–-IE内核"><a href="#2-1、Trident-–-IE内核" class="headerlink" title="2.1、Trident – IE内核"></a>2.1、Trident – IE内核</h3><p>1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11<br>IE11开始支持WebGL技术<br>IE8的JavaScript引擎是Jscript<br>IE9开始用Chakra，速度和标准化方面都很出色</p><p>IE6、IE7、IE8（Trident 4.0）<br>IE9（Trident 5.0）<br>IE10（Trident 6.0）<br>360安全浏览器（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink）<br>猎豹极轻浏览器<br>360极速浏览器（7.5之前为Trident+Webkit，7.5为Trident+Blink）<br>猎豹安全浏览器（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink）<br>猎豹极轻浏览器，傲游浏览器（傲游1.x、2.x为IE内核，3.x为IE与Webkit双核）<br>百度浏览器（早期版本）<br>世界之窗浏览器 [2] （最初为IE内核，2013年采用Chrome+IE内核）<br>腾讯TT<br>淘宝浏览器<br>搜狗高速浏览器（1.x为Trident，2.0及以后版本为Trident+Webkit）<br>阿云浏览器（早期版本）<br>瑞星安全浏览器<br>UC浏览器（Webkit内核+Trident内核）<br>Windows Phone 8</p><h3 id="2-2、Gecko-–-Firefox内核"><a href="#2-2、Gecko-–-Firefox内核" class="headerlink" title="2.2、Gecko – Firefox内核"></a>2.2、Gecko – Firefox内核</h3><p>Netscape6开始采用的内核，代码完全公开<br>JavaScript引擎是：SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）</p><p>Firefox内核浏览器<br>Mozilla Firefox</p><h3 id="2-3、Presto-–-Opera前内核-已废弃"><a href="#2-3、Presto-–-Opera前内核-已废弃" class="headerlink" title="2.3、Presto – Opera前内核 (已废弃)"></a>2.3、Presto – Opera前内核 (已废弃)</h3><p>Opera12.17及更早版本曾经采用的内核<br>特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。<br>Opera现已改用Google Chrome的Blink内核。</p><h3 id="2-4、Webkit-–-Safari内核-Chrome内核原型"><a href="#2-4、Webkit-–-Safari内核-Chrome内核原型" class="headerlink" title="2.4、Webkit – Safari内核 Chrome内核原型"></a>2.4、Webkit – Safari内核 Chrome内核原型</h3><p>苹果公司自己的内核<br>包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来<br>Safari 3终于推出了Windows版<br>Mac下还有OmniWeb、Shiira等人气很高的浏览器。</p><p>WebKit内核浏览器：<br>Chrome<br>360极速浏览器 高速模式<br>搜狗高速浏览器 高速模式<br>Safari (Win/Mac/iPhone/iPad)<br>傲游浏览器3<br>Symbian手机浏览器<br>Android 4.4 之前版本</p><h3 id="2-5、Blink-–-Chrome内核"><a href="#2-5、Blink-–-Chrome内核" class="headerlink" title="2.5、Blink – Chrome内核"></a>2.5、Blink – Chrome内核</h3><p>由Google和Opera Software开发的浏览器渲染引擎<br>是开源引擎WebKit中WebCore组件的一个分支</p><p>Blink内核浏览器：<br>Chrome（28及往后版本）<br>Opera（15及往后版本）<br>Yandex浏览器<br>Android4.4 及之后版本<br>国产浏览器 360、UC、QQ、2345 等等 转投 blink</p><h3 id="2-6、“双核”-“多核”"><a href="#2-6、“双核”-“多核”" class="headerlink" title="2.6、“双核” “多核”"></a>2.6、“双核” “多核”</h3><p>现代国产浏览器大多是双核，甚至是多核模式，<br>其中Trident是“兼容浏览模式”<br>其他内核叫做“高速浏览模式”</p><h1 id="二、JS引擎"><a href="#二、JS引擎" class="headerlink" title="二、JS引擎"></a>二、JS引擎</h1><h3 id="1、Chakra-–-IE"><a href="#1、Chakra-–-IE" class="headerlink" title="1、Chakra – IE"></a>1、Chakra – IE</h3><p>IE9启用的新的JavaScript引擎</p><h3 id="2、V8-–-Chrome-傲游3"><a href="#2、V8-–-Chrome-傲游3" class="headerlink" title="2、V8 – Chrome 傲游3"></a>2、V8 – Chrome 傲游3</h3><h3 id="3、Nitro-–-Safari-4"><a href="#3、Nitro-–-Safari-4" class="headerlink" title="3、Nitro – Safari 4"></a>3、Nitro – Safari 4</h3><h3 id="4、SpiderMonkey-TraceMonkey-JaegerMonkey-–-Firefox"><a href="#4、SpiderMonkey-TraceMonkey-JaegerMonkey-–-Firefox" class="headerlink" title="4、SpiderMonkey / TraceMonkey / JaegerMonkey – Firefox"></a>4、SpiderMonkey / TraceMonkey / JaegerMonkey – Firefox</h3><p>SpiderMonkey应用在Mozilla Firefox 1.0-3.0<br>TraceMonkey应用在Mozilla Firefox 3.5-3.6版本<br>JaegerMonkey应用在Mozilla Firefox 4.0及后续的版本。</p><h3 id="5、Linear-A-Linear-B-Futhark-Carakan"><a href="#5、Linear-A-Linear-B-Futhark-Carakan" class="headerlink" title="5、Linear A/Linear B/Futhark/Carakan"></a>5、Linear A/Linear B/Futhark/Carakan</h3><p>Linear A应用于Opera 4.0-6.1版本<br>Linear B应用于Opera 7.0～9.2版本<br>Futhark应用于Opera 9.5-10.2版本<br>Carakan应用于Opera 10.5及后续的版本</p><h3 id="6、KJS"><a href="#6、KJS" class="headerlink" title="6、KJS"></a>6、KJS</h3><p>KHTML对应的JavaScript引擎。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://baike.baidu.com/item/浏览器内核/10602413?fr=aladdin" target="_blank" rel="noopener">浏览器内核</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器存储</title>
      <link href="/2020/04/19/web/browser/%E5%AD%98%E5%82%A8/"/>
      <url>/2020/04/19/web/browser/%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、浏览器端存储"><a href="#一、浏览器端存储" class="headerlink" title="一、浏览器端存储"></a>一、浏览器端存储</h1><h2 id="1-1、Cookie"><a href="#1-1、Cookie" class="headerlink" title="1.1、Cookie"></a>1.1、Cookie</h2><p>Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。</p><p>客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在客户端内存中，称为临时Cookie，浏览器关闭后这个Cookie对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。</p><p>Cookie是可以被禁止的。</p><h2 id="1-2、session"><a href="#1-2、session" class="headerlink" title="1.2、session"></a>1.2、session</h2><p>每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。</p><p>在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。</p><p>Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。</p><h2 id="1-3、indexedDB"><a href="#1-3、indexedDB" class="headerlink" title="1.3、indexedDB"></a>1.3、indexedDB</h2><p>浏览器数据库存储<br>可存大量数据</p><h1 id="二、存储的区别"><a href="#二、存储的区别" class="headerlink" title="二、存储的区别"></a>二、存储的区别</h1><h2 id="2-1、LocalStorage"><a href="#2-1、LocalStorage" class="headerlink" title="2.1、LocalStorage"></a>2.1、LocalStorage</h2><p>不会自动把数据发给服务器，仅在本地保存<br>5M或更大<br>在所有同源窗口中都是共享的<br>可以长期存储数据，没有时间限制<br>setItem,getItem,removeItem,clear等方法</p><h2 id="2-2、SessionStorage"><a href="#2-2、SessionStorage" class="headerlink" title="2.2、SessionStorage"></a>2.2、SessionStorage</h2><p>不会自动把数据发给服务器，仅在本地保存<br>5M或更大<br>不在不同的浏览器窗口中共享<br>只有在浏览器被关闭之前使用<br>setItem,getItem,removeItem,clear等方法</p><h2 id="2-3、cookie"><a href="#2-3、cookie" class="headerlink" title="2.3、cookie"></a>2.3、cookie</h2><p>cookie数据始终在同源的http请求中携带<br>在浏览器和服务器间来回传递<br>有路径（path）的概念，可以限制cookie只属于某个路径下。<br>不能超过4k<br>在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>在所有同源窗口中都是共享的<br>自己封装setCookie，getCookie</p><h1 id="三、如何使用cookie"><a href="#三、如何使用cookie" class="headerlink" title="三、如何使用cookie"></a>三、如何使用cookie</h1><h2 id="1、设置"><a href="#1、设置" class="headerlink" title="1、设置"></a>1、设置</h2><pre><code>var name = &quot;jack&quot;;var pwd = &quot;123&quot;;var now = new Date();now.setTime(now.getTime() +1 * 24 * 60 * 60 * 1000);//转毫秒var path = &quot;/&quot;;//可以是具体的网页document.cookie = &quot;name=&quot; + name + &quot;;expires=&quot; + now.toUTCString() + &quot;;path=&quot; + path;//姓名document.cookie= &quot;pwd=&quot; + pwd + &quot;;expires=&quot; + now.toUTCString()+ &quot;;path=&quot; + path; //密码</code></pre><p>做清除cookie时重新设置为null或空值</p><h2 id="2、读取"><a href="#2、读取" class="headerlink" title="2、读取"></a>2、读取</h2><pre><code>function getKey(key) {var data = document.cookie;var findStr = key + &quot;=&quot;;//找到key的位置var index = data.indexOf(findStr);if (index == -1)return null;var subStr = data.substring(index +findStr.length);var lastIndex = subStr.indexOf(&quot;;&quot;);if (lastIndex == -1) {return subStr;} else {return subStr.substring(0,lastIndex);}}</code></pre><pre><code>function getKey(key) {return JSON.parse(&quot;{\&quot;&quot; +document.cookie.replace(/;\s+/gim, &quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;}&quot;)[key];}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2020/04/19/style/flex/"/>
      <url>/2020/04/19/style/flex/</url>
      
        <content type="html"><![CDATA[<h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display-flex"><a href="#display-flex" class="headerlink" title="display: flex;"></a>display: flex;</h3><h3 id="flex-direction-row"><a href="#flex-direction-row" class="headerlink" title="flex-direction: row;"></a>flex-direction: row;</h3><p>​    //决定主轴的方向<br>​    // row默认 主轴为水平方向，起点在左端。<br>​    // row-reverse 主轴为水平方向，起点在右端<br>​    // column 主轴为垂直方向，起点在上沿<br>​    // column-reverse 主轴为垂直方向，起点在下沿</p><h3 id="flex-wrap-wrap"><a href="#flex-wrap-wrap" class="headerlink" title="flex-wrap: wrap;"></a>flex-wrap: wrap;</h3><p>​    // 如果一条轴线排不下，如何换行<br>​    // nowrap默认 不换行<br>​    // wrap 换行，第一行在上方<br>​    // wrap-reverse 换行，第一行在下方</p><h3 id="flex-flow-column-nowrap"><a href="#flex-flow-column-nowrap" class="headerlink" title="flex-flow: column nowrap;"></a>flex-flow: column nowrap;</h3><p>​     // 是flex-direction属性和flex-wrap属性的简写形式<br>​    // row nowrap 默认</p><h3 id="justify-content-flex-start"><a href="#justify-content-flex-start" class="headerlink" title="justify-content: flex-start;"></a>justify-content: flex-start;</h3><p>​    // 具体对齐方式与轴的方向有关<br>​    // flex-start 默认,左对齐<br>​    // flex-end 右对齐<br>​    // center  居中<br>​    // space-between 两端对齐，项目之间的间隔都相等<br>​    // space-around 每个项目两侧的间隔相等;项目之间的间隔比项目与边框的间隔大一倍</p><h3 id="align-items-stretch"><a href="#align-items-stretch" class="headerlink" title="align-items: stretch;"></a>align-items: stretch;</h3><p>​    // 定义项目在交叉轴上如何对齐<br>​    // stretch 默认,如果项目未设置高度或设为auto，将占满整个容器的高度<br>​    // flex-start 交叉轴的起点对齐<br>​    // flex-end 交叉轴的终点对齐<br>​    // center 交叉轴的中点对齐<br>​    // baseline 项目的第一行文字的基线对齐</p><h3 id="align-content-flex-end"><a href="#align-content-flex-end" class="headerlink" title="align-content: flex-end;"></a>align-content: flex-end;</h3><p>​     // 定义了多根轴线的对齐方式,如果项目只有一根轴线，该属性不起作用<br>​    // flex-start 与交叉轴的起点对齐<br>​    // flex-end 与交叉轴的终点对齐<br>​    // center 与交叉轴的中点对齐<br>​    // stretch默认 轴线占满整个交叉轴<br>​    // space-between 与交叉轴两端对齐，轴线之间的间隔平均分布<br>​    // space-around 每根轴线两侧的间隔都相等,轴线之间的间隔比轴线与边框的间隔大一倍</p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="order-1"><a href="#order-1" class="headerlink" title="order: 1;"></a>order: 1;</h3><p>​    // 定义项目的排列顺序<br>​    // 数值越小，排列越靠前，默认为0</p><h3 id="flex-grow-0"><a href="#flex-grow-0" class="headerlink" title="flex-grow: 0;"></a>flex-grow: 0;</h3><p>​    // 定义项目的放大比例<br>​    // 默认为0，即如果存在剩余空间，也不放大</p><h3 id="flex-shrink-1"><a href="#flex-shrink-1" class="headerlink" title="flex-shrink: 1;"></a>flex-shrink: 1;</h3><p>​    // 定义了项目的缩小比例<br>​    // 默认为1，即如果空间不足，该项目将缩小<br>​    // 设为0表示空间不足时该项目不缩小</p><h3 id="flex-basis-auto"><a href="#flex-basis-auto" class="headerlink" title="flex-basis: auto;"></a>flex-basis: auto;</h3><p>​    // 定义了在分配多余空间之前，项目占据的主轴空间<br>​    // <length> | auto</p><h3 id="flex-0-1-auto"><a href="#flex-0-1-auto" class="headerlink" title="flex: 0 1 auto;"></a>flex: 0 1 auto;</h3><p>​    // flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto<br>​    // 快捷值：auto (1 1 auto) || none (0 0 auto)</p><h3 id="align-self-flex-end"><a href="#align-self-flex-end" class="headerlink" title="align-self: flex-end;"></a>align-self: flex-end;</h3><p>​    // 允许单个项目有与其他项目不一样的对齐方式，覆盖align-items<br>​    // auto默认<br>​    // flex-start<br>​    // flex-end<br>​    // center<br>​    // baseline<br>​    // stretch</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="css">.box {    display: flex;}</code></pre><p>行内元素 </p><pre><code class="css">.box {    display: inline-flex;}</code></pre><p>三点色子</p><pre><code>.box {    display: flex;}</code></pre><pre><code>.item:nth-child(2) {    align-self: center;}</code></pre><pre><code>.item:nth-child(3) {    align-self: flex-end;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Style </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html 属性</title>
      <link href="/2020/04/19/html/%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/04/19/html/%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="html-全局属性"><a href="#html-全局属性" class="headerlink" title="html 全局属性"></a>html 全局属性</h1><pre><code>idclass    样式类style    内联样式title    鼠标覆盖时提示内容lang    内容的语言    一般写在&lt;html&gt;    en-US    en    zhtabindex    tab 键次序</code></pre><h1 id="html5-全局属性"><a href="#html5-全局属性" class="headerlink" title="html5 全局属性"></a>html5 全局属性</h1><pre><code>contenteditable    内容是否可编辑contextmenu    上下文菜单    点击元素时显示data-*    存储私有定制数据draggable    是否可拖动dropzone    在拖动被拖动数据时是否进行复制、移动或链接hiddentranslate    是否应该翻译元素内容</code></pre>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html 事件</title>
      <link href="/2020/04/19/html/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/04/19/html/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="html-事件属性"><a href="#html-事件属性" class="headerlink" title="html 事件属性"></a>html 事件属性</h1><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><pre><code>    应用到 &lt;body&gt; 标签    onload        页面结束加载之后</code></pre><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><pre><code>    onblur        失去焦点时    onchange        值被改变时    onfocus        获得焦点时    onselect        文本被选中后    onsubmit        提交表单时</code></pre><h2 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h2><pre><code>    onkeypress        敲击按钮时    onkeydown        按下按键时    onkeyup        释放按键时</code></pre><h2 id="Mouse"><a href="#Mouse" class="headerlink" title="Mouse"></a>Mouse</h2><pre><code>    onclick        鼠标点击时    ondblclick        鼠标双击时    onmousedown        元素上按下鼠标按钮时    onmousemove        鼠标指针移动到元素上时    onmouseover        鼠标指针移动到元素上时    onmouseout        鼠标指针移出元素时    onmouseup        在元素上释放鼠标按钮时</code></pre><h1 id="html5-事件属性"><a href="#html5-事件属性" class="headerlink" title="html5 事件属性"></a>html5 事件属性</h1><h2 id="window-1"><a href="#window-1" class="headerlink" title="window"></a>window</h2><pre><code>    应用到 &lt;body&gt; 标签    onresize        浏览器窗口被调整大小时</code></pre><h2 id="form-1"><a href="#form-1" class="headerlink" title="form"></a>form</h2><pre><code>    onformchange        表单改变时    onforminput        表单获得用户输入时    oninput        元素获得用户输入时    oninvalid        元素无效时</code></pre><h2 id="Mouse-1"><a href="#Mouse-1" class="headerlink" title="Mouse"></a>Mouse</h2><pre><code>    ondrag        被拖动时    ondragstart        在拖动操作开端    ondragend        在拖动操作末端    ondragenter        已被拖动到有效拖放区域时    ondragleave        离开有效拖放目标时    ondragover        在有效拖放目标上正在被拖动时    ondrop        被拖元素正在被拖放时    onmousewheel        鼠标滚轮正在被滚动时    onscroll        元素滚动条被滚动时</code></pre>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html5 标签</title>
      <link href="/2020/04/19/html/html5/"/>
      <url>/2020/04/19/html/html5/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.w3school.com.cn/html5/index.asp" target="_blank" rel="noopener">w3school</a></p><h1 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h1><pre><code>&lt;header&gt;    页眉&lt;footer&gt;    页脚&lt;section&gt;    文档中的节&lt;article&gt;    独立的自包含文章&lt;nav&gt;    导航链接的容器&lt;aside&gt;    侧栏&lt;details&gt;    可查看或隐藏的额外细节    &lt;summary&gt;         details 元素的标题</code></pre><h1 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h1><pre><code>&lt;bdi&gt;    文本方向&lt;figure&gt;    自包含内容，比如图示、图表、照片、代码清单等    &lt;figcaption&gt;        &lt;figure&gt; 元素的标题&lt;mark&gt;    重要或强调的内容&lt;main&gt;    文档的主内容&lt;menuitem&gt;    从弹出菜单调用的命令/菜单项目&lt;meter&gt;    已知范围（尺度）内的标量测量&lt;progress&gt;    进度&lt;time&gt;    日期/时间&lt;wbr&gt;    折行</code></pre><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id=""><a href="#" class="headerlink" title=""></a><datalist></h2><pre><code>    为 &lt;input&gt; 元素规定预定义选项列表        &lt;input list=&quot;browsers&quot;&gt;        &lt;datalist id=&quot;browsers&quot;&gt;            &lt;option value=&quot;Internet Explorer&quot;&gt;            &lt;option value=&quot;Firefox&quot;&gt;            &lt;option value=&quot;Chrome&quot;&gt;            &lt;option value=&quot;Opera&quot;&gt;            &lt;option value=&quot;Safari&quot;&gt;        &lt;/datalist&gt; </code></pre><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><keygen></h2><pre><code>    键对生成器字段</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><output></h2><pre><code>    计算结果</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><input></h2><pre><code>     type属性        color            IE不支持        email            IE9 及更早版本不支持        date            Firefox 或者 Internet Explorer 11 以及更早版本不支持        time            Firefox 或者 Internet Explorer 11 以及更早版本不支持        datetime            Chrome、Firefox 或 Internet Explorer 不支持        datetime-local            Firefox 或者 Internet Explorer 不支持        week            IE不支持        month            Firefox 或者 Internet Explorer 11 以及更早版本不支持        number             IE9及更早版本不支持        range            IE9 及早期版本不支持        search            与text相似        tel            只有 Safari 8 支持        url            IE9 及其更早版本不支持    输入限制        disabled        min        max        maxlength            最大字符数        pattern            输入值的正则表达式        readonly        required        size            宽度（以字符计）        step            合法数字间隔        value            默认值</code></pre><h1 id="图象"><a href="#图象" class="headerlink" title="图象"></a>图象</h1><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><canvas></h2><pre><code>    使用 JavaScript 的图像绘制    矩形        &lt;script type=&quot;text/javascript&quot;&gt;</code></pre><p>var c=document.getElementById(“myCanvas”);<br>var cxt=c.getContext(“2d”);<br>cxt.fillStyle=”#FF0000”;<br>cxt.fillRect(0,0,150,75);<br></script><br>        圆形<br>            cxt.beginPath();<br>cxt.arc(70,18,15,0,Math.PI*2,true);<br>cxt.closePath();<br>cxt.fill();<br>        渐变<br>            var grd=cxt.createLinearGradient(0,0,175,50);<br>grd.addColorStop(0,”#FF0000”);<br>grd.addColorStop(1,”#00FF00”);<br>cxt.fillStyle=grd;<br>cxt.fillRect(0,0,175,50);<br>        图像<br>            var img=new Image()<br>img.src=”flower.png”<br>cxt.drawImage(img,0,0);</p><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><svg></h2><pre><code>    介绍        可伸缩矢量图形        使用 XML 格式定义图形        改变尺寸质量不会有损失    示例        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt;</code></pre><p>  <polygon points="100,10 40,180 190,60 10,60 160,180"  style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" /><br></svg><br>    对比<br>        Canvas<br>            依赖分辨率<br>            不支持事件处理器<br>            弱的文本渲染能力<br>            能够以 .png 或 .jpg 格式保存结果图像<br>            最适合图像密集型的游戏，其中的许多对象会被频繁重绘<br>        SVG<br>            不依赖分辨率<br>            支持事件处理器<br>            最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>            复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>            不适合游戏应用</p><h1 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h1><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><video></h2><h3 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h3><pre><code>        Ogg            IE saifar 不支持        MPEG4            Firefox 不支持        WebM            IE saifar 不支持</code></pre><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><pre><code>        autoplay            就绪后马上播放        controls            显示控件        height        width        src        preload            页面加载时进行加载，并预备播放        loop            是否循环播放        currentTime</code></pre><h3 id="document-getElementById-“video1”"><a href="#document-getElementById-“video1”" class="headerlink" title="document.getElementById(“video1”)"></a>document.getElementById(“video1”)</h3><pre><code>        属性            currentTime                当前播放时间            ended                是否结束            paused                是否暂停            muted                是否静音            seeking            volume            height            width            videoWidth            videoHeight        方法            play()                播放            pause()                暂停            load()                加载        监听            videoEl.addEventListener(&quot;timeupdate&quot;, function(){})</code></pre><h3 id="最优方案"><a href="#最优方案" class="headerlink" title="最优方案"></a>最优方案</h3><pre><code>        &lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;            &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot; /&gt;            &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; /&gt;            &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; /&gt;            &lt;object data=&quot;movie.mp4&quot; width=&quot;320&quot; height=&quot;240&quot;&gt;                &lt;embed src=&quot;movie.swf&quot; width=&quot;320&quot; height=&quot;240&quot; /&gt;            &lt;/object&gt;            您的浏览器不支持 video 标签。        &lt;/video&gt;</code></pre><h2 id="-7"><a href="#-7" class="headerlink" title=""></a><audio></h2><pre><code>    音频    最优方案        &lt;audio controls=&quot;controls&quot; height=&quot;100&quot; width=&quot;100&quot;&gt;            &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mp3&quot; /&gt;            &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt;            &lt;embed height=&quot;100&quot; width=&quot;100&quot; src=&quot;song.mp3&quot; /&gt;        &lt;/audio&gt;</code></pre><h2 id="-8"><a href="#-8" class="headerlink" title=""></a><source></h2><pre><code>    &lt;video&gt; 和 &lt;audio&gt; 的来源</code></pre><h2 id="-9"><a href="#-9" class="headerlink" title=""></a><track></h2><pre><code>    &lt;video&gt; 和 &lt;audio&gt; 的轨道</code></pre><h2 id="-10"><a href="#-10" class="headerlink" title=""></a><embed></h2><pre><code>    外部应用程序的容器（比如插件）</code></pre><h2 id="-11"><a href="#-11" class="headerlink" title=""></a><object></h2><pre><code>    支持 HTML 助手（插件）    比如使用 Flash 来播放 SWF 视频</code></pre><p>#API</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><pre><code>    Internet Explorer 9、Firefox、Chrome、Safari 以及 Opera 支持地理定位    示例        &lt;script&gt;            var x=document.getElementById(&quot;demo&quot;);            function getLocation()            {            if (navigator.geolocation)                {                navigator.geolocation.getCurrentPosition(showPosition);                }            else{x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;}            }            function showPosition(position)            {            x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude +            &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;            }        &lt;/script&gt;</code></pre><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><pre><code>    IE9以下不支持    被放区域元素事件        ondrop        ondragover    拖动对象        draggable        ondragstart</code></pre><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><pre><code>    Local Storage 本地存储        介绍            IE8以下不支持                if (typeof(Storage) !== &quot;undefined&quot;)             限制5MB            同源可用            永远保存在客户端        localStorage            setItem()            getItem()            removeItem()    Session Storage 会话存储        介绍            关闭浏览器时清空        sessionStorage            setItem()            getItem()            removeItem()</code></pre><h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><pre><code>    介绍        IE10以下不支持        离线浏览        已缓存资源加载得更快        减少服务器负载     manifest 属性        &lt;html manifest=&quot;demo.appcache&quot;&gt;    Manifest 文件        MIME-type            &quot;text/cache-manifest&quot;            在 web 服务器上进行配置        示例            CACHE MANIFEST            # 2012-02-21 v1.0.0            /theme.css            /logo.gif            /main.js            NETWORK:            login.asp            FALLBACK:            /html/ /offline.html                CACHE MANIFEST                     首次下载后进行缓存                NETWORK                    需要与服务器的连接，且不会被缓存                FALLBACK                    当页面无法访问时的回退页面（比如 404 页面）</code></pre><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><pre><code>    介绍        IE10以下不支持            if (typeof(Worker) !== &quot;undefined&quot;)         运行在后台的 JavaScript，不会影响页面的性能。    示例        w = new Worker(&quot;demo_workers.js&quot;);        w.onmessage = function(event){            document.getElementById(&quot;result&quot;).innerHTML = event.data;        };</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html 标签</title>
      <link href="/2020/04/19/html/html/"/>
      <url>/2020/04/19/html/html/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">w3school</a></p><h1 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h1><h2 id=""><a href="#" class="headerlink" title=""></a><html></h2><pre><code>    描述整个网页</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><head></h2><pre><code>    头部信息    &lt;style&gt;        内部样式表    &lt;link&gt;        外部样式表        rel            与链接文档之间的关系            stylesheet        type            文档的 MIME 类型。            text/css        href            mystyle.css    &lt;meta&gt;        元数据        charset            utf-8        name            viewport            把 content 属性连接到某个名称        content            width=device-width, initial-scale=1        http-equiv             把 content 属性连接到一个 HTTP 头部    &lt;title&gt;        标题    &lt;base&gt;        为页面上的所有链接规定默认地址或默认目标        href        target</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><script></h2><pre><code>    js脚本</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><noscript></h2><pre><code>    浏览器不支持 JavaScript 时显示内容</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><body></h2><pre><code>    主体，可见区域</code></pre><h1 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h1><h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><pre><code>    &lt;pre&gt;        代码格式化</code></pre><h2 id="引用相关"><a href="#引用相关" class="headerlink" title="引用相关"></a>引用相关</h2><pre><code>    &lt;address&gt;        地址信息</code></pre><h2 id="列表相关"><a href="#列表相关" class="headerlink" title="列表相关"></a>列表相关</h2><pre><code>    &lt;ul&gt;        无序列表        type            disc                黑圆点            circle                白圆点            square                黑方块    &lt;ol&gt;        有序列表        type            默认123顺序            a            A            I            i    &lt;li&gt;        列表项    &lt;dl&gt;        定义列表    &lt;dt&gt;        定义项目    &lt;dd&gt;        定义的描述</code></pre><h2 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h2><pre><code>    &lt;form&gt;        子元素            &lt;label&gt;            &lt;input&gt;                type                    text                    password                    checkbox                    radio                    reset                    submit                    hidden            &lt;select&gt;                &lt;option&gt;            &lt;textarea&gt;                rows                cols            &lt;fieldset&gt;                组合表单中的相关数据                &lt;legend&gt;                    框上的说明文字            &lt;button&gt;                type                    button                    submit        属性            action            method            accept-charset                字符集            autocomplete                是否自动完成表单            enctype                数据的编码                application/x-www-form-urlencoded            novalidate                不验证表单            target</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>    &lt;h1&gt; ~ &lt;h6&gt;        标题    &lt;p&gt;        段落    &lt;table&gt;        表格        &lt;caption&gt;            标题        &lt;thead&gt;            页尾            valign                垂直对齐            align                水平对齐        &lt;tbody&gt;            主体            valign                垂直对齐            align                水平对齐        &lt;tfoot&gt;            页脚            valign                垂直对齐            align                水平对齐        &lt;col&gt;            为表格中一个或多个列定义属性值            align                水平对齐            char                根据哪个字符来对齐与 col 元素相关的内容            charoff                第一个对齐字符的偏移量            span                横跨的列数            valign                垂直对齐            width        &lt;colgroup&gt;            用于对表格中的列进行组合，以便对其进行格式化        &lt;tr&gt;            行            每行不同数量的单元格可以实现单元格合并            &lt;th&gt;                表头，加粗                子主题 2                rowspan                    跨列            &lt;td&gt;                单元格                rowspan                    跨列        属性            frame                box                    四周带线                above                    上边带线                below                    下边带线                hsides                    上下两边带线                vsides                    左右两边带线            cellpadding                单元格内边距            border    &lt;hr /&gt;        水平线    &lt;div&gt;    &lt;iframe&gt;        在网页内显示网页        指定name，可在&lt;a&gt;中跳转iframe</code></pre><h1 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h1><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><pre><code>    &lt;b&gt;        加粗    &lt;strong&gt;        加粗    &lt;em&gt;        强调    &lt;i&gt;        斜体    &lt;big&gt;        大号字    &lt;small&gt;        小号字    &lt;sup&gt;        上标    &lt;sub&gt;        下标    &lt;ins&gt;        下划线    &lt;del&gt;        删除线</code></pre><h2 id="代码相关-1"><a href="#代码相关-1" class="headerlink" title="代码相关"></a>代码相关</h2><pre><code>    &lt;code&gt;        显示单行代码    &lt;kbd&gt;        键盘输入字    &lt;tt&gt;        打字机字    &lt;samp&gt;        样本字    &lt;var&gt;        变量字        与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用</code></pre><h2 id="引用相关-1"><a href="#引用相关-1" class="headerlink" title="引用相关"></a>引用相关</h2><pre><code>    &lt;abbr&gt;        缩写    &lt;acronym&gt;        首字母缩写        HTML5 中不支持 &lt;acronym&gt; 标签。请使用 &lt;abbr&gt; 标签    &lt;bdo&gt;        文字方向        dir            ltr                从左向右            rtl                从右向左    &lt;blockquote&gt;        长引用        前后添加了换行，并增加了外边距。    &lt;q&gt;        短引用        自动加双引号    &lt;cite&gt;        引用、引证        如书籍或杂志的标题    &lt;dfn&gt;        项目</code></pre><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><span></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a><a></h3><pre><code>        href            http://domain.com                跳转外链            /index.html                跳转到本地域名页面            #someid                跳转到锚点，id属性或name属性            mailto:someone@microsoft.com?cc=someoneelse@microsoft.com&amp;bcc=andsomeoneelse2@microsoft.com            &amp;subject=Summer%20Party&amp;body=party!&quot;                邮件        target            _blank                新窗口打开            _top            _parent            _self</code></pre><h3 id="-7"><a href="#-7" class="headerlink" title=""></a><img></h3><pre><code>        src            本地路径或网络路径        alt            最好加上，显示不出图片时显示的内容        width            最好加上，图片加载前就会先预留位置        height            最好加上，图片加载前就会先预留位置</code></pre><h3 id="-8"><a href="#-8" class="headerlink" title=""></a><map></h3><pre><code>        &lt;area&gt;            带有可点击区域的图像映射            shape                rect                    矩形                circle                    圆形                poly            coords                可点击区域坐标                &quot;129,161,10&quot;                    圆形                &quot;0,0,110,260&quot;                    矩形            href            target</code></pre><h3 id="-9"><a href="#-9" class="headerlink" title=""></a><td></h3><pre><code>        表格单元格</code></pre><p>#空元素</p><h2 id="-10"><a href="#-10" class="headerlink" title=""></a><br /></h2><pre><code>    换行</code></pre>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html 文档类型定义</title>
      <link href="/2020/04/19/html/dtd/"/>
      <url>/2020/04/19/html/dtd/</url>
      
        <content type="html"><![CDATA[<h1 id="doc-type-define"><a href="#doc-type-define" class="headerlink" title="doc type define"></a>doc type define</h1><pre><code>文档类型定义</code></pre><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><pre><code>1991</code></pre><h1 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML+"></a>HTML+</h1><pre><code>1993</code></pre><h1 id="HTML-2-0"><a href="#HTML-2-0" class="headerlink" title="HTML 2.0"></a>HTML 2.0</h1><pre><code>1995</code></pre><h1 id="HTML-3-2"><a href="#HTML-3-2" class="headerlink" title="HTML 3.2"></a>HTML 3.2</h1><pre><code>1997</code></pre><h1 id="HTML-4-01"><a href="#HTML-4-01" class="headerlink" title="HTML 4.01"></a>HTML 4.01</h1><pre><code>1999&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;     &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></pre><h1 id="XHTML-1-0"><a href="#XHTML-1-0" class="headerlink" title="XHTML 1.0"></a>XHTML 1.0</h1><pre><code>2000</code></pre><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><pre><code>2012&lt;!DOCTYPE html&gt;</code></pre><h1 id="XHTML5"><a href="#XHTML5" class="headerlink" title="XHTML5"></a>XHTML5</h1><pre><code>2013</code></pre>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Svg 基础语法</title>
      <link href="/2020/04/19/style/svg/"/>
      <url>/2020/04/19/style/svg/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SVG基础"><a href="#一、SVG基础" class="headerlink" title="一、SVG基础"></a>一、SVG基础</h1><h2 id="1、基本图形"><a href="#1、基本图形" class="headerlink" title="1、基本图形"></a>1、基本图形</h2><h3 id="lt-rect-gt-矩形"><a href="#lt-rect-gt-矩形" class="headerlink" title="&lt;rect&gt;   矩形"></a><code>&lt;rect&gt;</code>   矩形</h3><p>x,y,width,height,rx,ry 起点位置和宽高，以及圆角半径</p><h3 id="lt-circle-gt-圆形"><a href="#lt-circle-gt-圆形" class="headerlink" title="&lt;circle&gt; 圆形"></a><code>&lt;circle&gt;</code> 圆形</h3><p>cx, cy, r 圆心的坐标和半径</p><h3 id="lt-ellipse-gt-椭圆"><a href="#lt-ellipse-gt-椭圆" class="headerlink" title="&lt;ellipse&gt; 椭圆"></a><code>&lt;ellipse&gt;</code> 椭圆</h3><p>cx, cy, rx ry</p><h3 id="lt-line-gt-直线"><a href="#lt-line-gt-直线" class="headerlink" title="&lt;line&gt; 直线"></a><code>&lt;line&gt;</code> 直线</h3><p>x1,y1,x2,y2</p><h3 id="lt-polyline-gt-折线"><a href="#lt-polyline-gt-折线" class="headerlink" title="&lt;polyline&gt; 折线"></a><code>&lt;polyline&gt;</code> 折线</h3><p>points=”x1 y1 x2 y2 x3 y3”</p><h3 id="lt-polygon-gt-多边形"><a href="#lt-polygon-gt-多边形" class="headerlink" title="&lt;polygon&gt;多边形"></a><code>&lt;polygon&gt;</code>多边形</h3><p>points=”x1 y1 x2 y2 x3 y3”</p><h2 id="2、基本属性"><a href="#2、基本属性" class="headerlink" title="2、基本属性"></a>2、基本属性</h2><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>fill=”#FFB3AE”</p><h3 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h3><p>stroke=”#971817”</p><h3 id="描边宽度"><a href="#描边宽度" class="headerlink" title="描边宽度"></a>描边宽度</h3><p>stroke-width=”10”</p><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><p>transform=”rotate(30)”</p><h2 id="3、svg使用方式"><a href="#3、svg使用方式" class="headerlink" title="3、svg使用方式"></a>3、svg使用方式</h2><p>img标签<br>svg标签<br>css背景</p><h2 id="4、基本操作API"><a href="#4、基本操作API" class="headerlink" title="4、基本操作API"></a>4、基本操作API</h2><h3 id="创建图形"><a href="#创建图形" class="headerlink" title="创建图形"></a>创建图形</h3><p>documentcreateElementNS(ns, tagName)</p><h3 id="添加图形"><a href="#添加图形" class="headerlink" title="添加图形"></a>添加图形</h3><p>element.appendChild(childElement)</p><h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><p>element.setAttribute(name, value)<br>element.getAttribute(name)</p><h1 id="二、坐标"><a href="#二、坐标" class="headerlink" title="二、坐标"></a>二、坐标</h1><h2 id="1、世界、视野、视窗"><a href="#1、世界、视野、视窗" class="headerlink" title="1、世界、视野、视窗"></a>1、世界、视野、视窗</h2><p>世界是无穷大的<br>视野：观察图形的大小<br>viewbox＝”0 0 400 300”<br>preserveAspectRatio=”xMidYMid meet”<br>对齐方式和包含方式<br>视窗：svg的大小，浏览器中的大小<br>width=”800”<br>height=”600”</p><h2 id="2、图形分组"><a href="#2、图形分组" class="headerlink" title="2、图形分组"></a>2、图形分组</h2><p><code>&lt;g&gt;</code>创建分组<br>可以设置属性进行继承<br>可以嵌套使用</p><h2 id="2、坐标系统"><a href="#2、坐标系统" class="headerlink" title="2、坐标系统"></a>2、坐标系统</h2><p>坐标：x轴从左到右，y轴从上到下，角度顺时针方向，<br>原点(0,0)在左上角<br>坐标系：<br>用户坐标系<br>自身坐标系<br>前驱坐标系<br>参考坐标系</p><h2 id="3、tansform属性"><a href="#3、tansform属性" class="headerlink" title="3、tansform属性"></a>3、tansform属性</h2><p>rotate(deg) 旋转<br>translate(x, y) 移动<br>scale(sx, sy) 放大缩小<br>matrix(a,b,c,d,e,f)</p><h1 id="三、颜色"><a href="#三、颜色" class="headerlink" title="三、颜色"></a>三、颜色</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>RGB(red[0-255], green[0-255], bule[0-255])</p><p>HSL(h[0,359], s%, l%)<br>三个分量分别表示颜色、饱和度和亮度<br><a href="http://paletton.com" target="_blank" rel="noopener">http://paletton.com</a></p><h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p>rgba<br>hsla<br>opacity</p><pre><code class="html">&lt;rect fill=&quot;rgba(255,0,0)&quot; opacity=&quot;0.5&quot;/&gt;&lt;rect stroke=&quot;hsla(0, 50%, 60%)&quot; /&gt;</code></pre><h1 id="四、-渐变"><a href="#四、-渐变" class="headerlink" title="四、 渐变"></a>四、 渐变</h1><h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>使用linearGradient和stop标签，定义方向和关键点位置及颜色<br>gradientUnits属性设置盒子类型，默认objectBoundingBox，userSpaceOnUse表示世界坐标系<br>默认从左上角(0%)到右下角(100%)</p><pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/200/svg&quot;&gt;  &lt;defs&gt;    &lt;linearGradient      id=&quot;grad1&quot;       gradientUnits=&quot;objectBoundingBox&quot;      x1=&quot;0&quot;      y1=&quot;0&quot;      x2=&quot;1&quot;      y2=&quot;1&quot;    &lt;/&gt;      &lt;stop offset=&quot;0&quot; stop-color=&quot;#1497FC&quot; /&gt;      &lt;stop offset=&quot;0&quot; stop-color=&quot;#1497FC&quot; /&gt;      &lt;stop offset=&quot;0&quot; stop-color=&quot;#1497FC&quot; /&gt;    &lt;/linearGradient&gt;  &lt;/defs&gt;  &lt;rect x=&quot;100&quot; y=&quot;100&quot; fill=&quot;url(#grad1)&quot; width=&quot;200&quot; height=&quot;150&quot; /&gt;&lt;/svg&gt;</code></pre><p>画一个宽200高150的矩形<br>linearGradient定义渐变色，xy的值0表示最左和最上，1表示最右和最下，使用userSpaceOnUse可以使用具体数值表示<br>stop定义关键点位置，offset=[0-1] 0 表示最左上角，0.5表示中间位置，1表示最右下角位置</p><h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;defs&gt;    &lt;radialGradient id=&quot;grad3&quot; cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.7&quot; fx=&quot;0.5&quot; fy=&quot;0.5&quot;&gt;      &lt;stop offset=&quot;0&quot; stop-color=&quot;rgb(20,151,252)&quot; /&gt;      &lt;stop offset=&quot;0.5&quot; stop-color=&quot;rgb(164,105,190)&quot; /&gt;      &lt;stop offset=&quot;1&quot; stop-color=&quot;rgb(255,140,0)&quot; /&gt;    &lt;/radialGradient&gt;  &lt;/defs&gt;  &lt;rect x=&quot;100&quot; y=&quot;100&quot; fill=&quot;url(#grad3)&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;  &lt;circle cx=&quot;500&quot; cy=&quot;200&quot; r=&quot;100&quot; fill=&quot;url(#grad3)&quot; /&gt;&lt;/svg&gt;</code></pre><h2 id="笔刷"><a href="#笔刷" class="headerlink" title="笔刷"></a>笔刷</h2><pre><code>&lt;pattern&gt;  &lt;circle&gt;  &lt;polygon&gt;&lt;/polygon&gt;</code></pre><h1 id="五、Path"><a href="#五、Path" class="headerlink" title="五、Path"></a>五、Path</h1><p><a href="http://www.w3.org/TR/SVG11/paths.html" target="_blank" rel="noopener">http://www.w3.org/TR/SVG11/paths.html</a></p><pre><code class="html">&lt;path d=&quot;M0,0 L10,20 C30 -10,40,20,100,100&quot; stoke=&quot;red&quot;/&gt;</code></pre><p>命令 含义</p><ul><li>M/m (x,y)+  移动到当前位置</li><li>L/l (x,y)+  画线段到指定位置</li><li>Hh (x)+ 画水平线到指定的x坐标</li><li>V/v(x)+ 画垂直线到指定的y坐标</li><li>Z/Z 闭合当前路径（结尾）</li><li>C/c (x1,y1,x2,y2,x,y)+  画三次贝赛尔曲线到指定位置</li><li>S/s (x2,y2,x,y)+光滑地画三次贝赛尔曲线到指定位置</li><li>Q/q (x1,y1,x,y)+画二次贝赛尔曲线到指定位置</li><li>T/t(x,y)+   光滑地画二次贝赛尔曲线到指定位置</li><li>A/a (rx,ry,xr,laf,sf,x,y)   画弧线到指定位置</li></ul><blockquote><p>注意：<br>大写表示绝对位置，小写为相对位置<br>上一命令结束位置就是下一命令开始的位置<br>命令可以重复参数表示重复执行同一命令</p></blockquote><h3 id="弧线-A-a-rx-ry-xr-laf-sf-x-y"><a href="#弧线-A-a-rx-ry-xr-laf-sf-x-y" class="headerlink" title="弧线 A/a (rx,ry,xr,laf,sf,x,y)"></a>弧线 A/a (rx,ry,xr,laf,sf,x,y)</h3><p>rx 弧线所在椭圆的x半轴长<br>ry 弧线所在椭圆的y半轴长<br>xr 长轴角度<br>laf 是否选择弧长较长的那一段弧<br>sf  是否选择逆时针方向的那一段弧<br>x,y 终点位置</p><h1 id="六、鼠标事件"><a href="#六、鼠标事件" class="headerlink" title="六、鼠标事件"></a>六、鼠标事件</h1><h2 id="1、SMIL方式"><a href="#1、SMIL方式" class="headerlink" title="1、SMIL方式"></a>1、SMIL方式</h2><p>单击后触发一个动画效果，此例中被改变的是“fill”属性，由红变蓝，中间没有渐变的过程，一次到位。</p><pre><code class="html">&lt;svg&gt;  &lt;rect x=&quot;15&quot; y=&quot;15&quot; width=&quot;40&quot; height=&quot;40&quot; fill=&quot;red&quot;&gt;      &lt;set attributeName=&quot;fill&quot; to=&quot;blue&quot; begin=&quot;click&quot;/&gt;  &lt;/rect&gt;&lt;/svg&gt;</code></pre><h2 id="2、Attributes方式"><a href="#2、Attributes方式" class="headerlink" title="2、Attributes方式"></a>2、Attributes方式</h2><p>事件属性在u处，“onclick”事件调用的是“changeColor”函数，参数是“evt”</p><pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;xmlns:xlink=http://www.w3.org/1999/xlinkxmlns:a3=&quot;http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/&quot;a3:scriptImplementation=&quot;Adobe&quot;&gt;  &lt;script type=&quot;text/ecmascript&quot; a3:scriptImplementation=&quot;Adobe&quot;&gt;    &lt;![CDATA[    function changeColor(evt) {      var rect = evt.target;        rect.setAttributeNS(null, &quot;fill&quot;, &quot;blue&quot;)      }  ]]&gt;  &lt;/script&gt;  &lt;rect x=&quot;5&quot; y=&quot;5&quot; width=&quot;40&quot; height=&quot;40&quot; fill=&quot;red&quot;  οnclick= &quot;changeColor(evt)&quot;/&gt; u&lt;/svg&gt;</code></pre><pre><code class="html">&lt;svg&gt;  &lt;use xlink:href=&quot;#Longmendiao&quot; transform=&quot;translate(30,60)  scale(0.5)&quot; onclick=&quot;btnClickA()&quot;&gt;&lt;/use&gt;  &lt;script&gt;  function btnClickA() {      alert(&quot;Hello&quot;);  }  &lt;/script&gt;&lt;/svg&gt;</code></pre><h2 id="3、JavaScript-SMIL方式"><a href="#3、JavaScript-SMIL方式" class="headerlink" title="3、JavaScript+SMIL方式"></a>3、JavaScript+SMIL方式</h2><pre><code class="html">&lt;svg οnlοad=&quot;makeShape(evt)&quot;&gt;&lt;script&gt;&lt;![CDATA[  var svgns = &quot;http://www.w3.org/2000/svg&quot;;u  function makeShape(evt) {    svgDoc = evt.target.ownerDocument;    var rect = svgDoc.createElementNS(svgns, &quot;rect&quot;);    rect.setAttributeNS(null, &quot;x&quot;, &quot;5&quot;);    rect.setAttributeNS(null, &quot;y&quot;, &quot;5&quot;);    rect.setAttributeNS(null, &quot;width&quot;, &quot;40&quot;);    rect.setAttributeNS(null, &quot;height&quot;, &quot;40&quot;);    rect.setAttributeNS(null, &quot;fill&quot;, &quot;red&quot;);    var set = svgDoc.createElementNS(svgns, &quot;set&quot;);    set.setAttributeNS(null, &quot;attributeName&quot;, &quot;fill&quot;);    set.setAttributeNS(null, &quot;to&quot;, &quot;blue&quot;);    set.setAttributeNS(null, &quot;begin&quot;, &quot;click&quot;);    rect.appendChild(set);    svgDoc.rootElement.appendChild(rect);  }]]&gt;&lt;/script&gt;&lt;/svg&gt;</code></pre><h2 id="4、EventListener方式"><a href="#4、EventListener方式" class="headerlink" title="4、EventListener方式"></a>4、EventListener方式</h2><pre><code class="html">&lt;svg οnlοad=&quot;makeShape(evt)&quot;&gt;&lt;script&gt;&lt;![CDATA[  var svgns = &quot;http://www.w3.org/2000/svg&quot;;  function makeShape(evt) {    if ( window.svgDocument == null )    svgDoc = evt.target.ownerDocument;    var rect = svgDoc.createElementNS(svgns, &quot;rect&quot;);    rect.setAttributeNS(null, &quot;x&quot;, 15);    rect.setAttributeNS(null, &quot;y&quot;, 15);    rect.setAttributeNS(null, &quot;width&quot;, 40);    rect.setAttributeNS(null, &quot;height&quot;, 40);    rect.setAttributeNS(null, &quot;fill&quot;, &quot;red&quot;);    rect.addEventListener(&quot;click&quot;, changeColor, false); u    svgDoc.documentElement.appendChild(rect);  }  function changeColor(evt) {      var target = evt.target;      target.setAttributeNS(null, &quot;fill&quot;, &quot;blue&quot;);  }]]&gt;&lt;/script&gt;&lt;/svg&gt;</code></pre><h1 id="七、动态添加元素和事件"><a href="#七、动态添加元素和事件" class="headerlink" title="七、动态添加元素和事件"></a>七、动态添加元素和事件</h1><p><a href="https://www.cnblogs.com/lovellll/p/10208207.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovellll/p/10208207.html</a></p><pre><code class="js">var svg = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);svg.setAttribute(&quot;width&quot;, &quot;800&quot;);svg.setAttribute(&quot;height&quot;, &quot;500&quot;);svg.addEventListener(&quot;load&quot;, function() {    alert(&quot;loaded&quot;);});document.body.appendChild(svg);var r = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;rect&quot;);r.setAttribute(&quot;fill&quot;, &quot;#120045&quot;);r.setAttribute(&quot;x&quot;, &quot;1&quot;);r.setAttribute(&quot;y&quot;, &quot;1&quot;);r.setAttribute(&quot;width&quot;, &quot;50%&quot;);r.setAttribute(&quot;height&quot;, &quot;50%&quot;);r.addEventListener(&quot;click&quot;, function() {    alert(&quot;clicked&quot;);});svg.appendChild(r);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Style </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 生命周期</title>
      <link href="/2020/04/19/web/vue/lifecycle/"/>
      <url>/2020/04/19/web/vue/lifecycle/</url>
      
        <content type="html"><![CDATA[<p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p><a id="more"></a><p><img src="../../../images/vue_life.png" alt=""></p><h2 id="beforeCreate："><a href="#beforeCreate：" class="headerlink" title="beforeCreate："></a>beforeCreate：</h2><p>​    在实例初始化之后，*<em>数据观测(data observer) *</em> 和 event/watcher事件配置 之前被调用，<br>​    注意是 之前，此时data、watcher、methods统统滴没有。<br>​    这个时候的vue实例还什么都没有，<br>​    但是<code>$route</code>对象是存在的，可以根据路由信息进行重定向之类的操作。</p><h2 id="created："><a href="#created：" class="headerlink" title="created："></a>created：</h2><p>​    在实例已经创建完成之后被调用。<br>​    在这一步，实例已完成以下配置：<br>​        数据观测(data observer) ，<br>​        属性和方法的运算，<br>​        watch/event 事件回调。<br>​    然而，挂载阶段还没开始，$el属性目前不可见。<br>​    此时 this.$data 可以访问，<br>​    watcher、events、methods也出现了，<br>​    若根据后台接口动态改变data和methods的场景下，可以使用。</p><h2 id="beforeMount："><a href="#beforeMount：" class="headerlink" title="beforeMount："></a>beforeMount：</h2><p>​    在挂载开始之前被调用，相关的 render 函数 首次被调用。<br>​    但是render正在执行中，此时DOM还是无法操作的。<br>​    我打印了此时的vue实例对象，相比于created生命周期，<br>​    此时只是多了一个$el的属性，然而其值为undefined。<br>​    使用场景我上文已经提到了，页面渲染时所需要的数据，应尽量在这之前完成赋值。</p><h2 id="mounted："><a href="#mounted：" class="headerlink" title="mounted："></a>mounted：</h2><p>​    在挂载之后被调用。<br>​    在这一步 创建<code>vm.$el</code>并替换el，并挂载到实例上。</p><blockquote><p>（官方文档中的 “如果root实例挂载了一个文档内元素，当mounted被调用时<code>vm.$el</code>也在文档内” 这句话存疑）</p></blockquote><p>​     此时元素已经渲染完成了，依赖于DOM的代码就放在这里吧~比如监听DOM事件。</p><h2 id="beforeUpdate："><a href="#beforeUpdate：" class="headerlink" title="beforeUpdate："></a>beforeUpdate：</h2><p>   <code>$vm.data</code>更新之后，虚拟DOM重新渲染 和打补丁之前被调用。<br>    你可以在这个钩子中进一步地修改<code>$vm.data</code>，这不会触发附加的重渲染过程。</p><h2 id="updated："><a href="#updated：" class="headerlink" title="updated："></a>updated：</h2><p>​    虚拟DOM重新渲染 和打补丁之后被调用。<br>​    当这个钩子被调用时，组件DOM的data已经更新，<br>​    所以你现在可以执行依赖于DOM的操作。<br>​    但是不要在此时修改data，否则会继续触发<code>beforeUpdate</code>、<code>updated</code>这两个生命周期，进入死循环！</p><h2 id="beforeDestroy："><a href="#beforeDestroy：" class="headerlink" title="beforeDestroy："></a>beforeDestroy：</h2><p>​    实例被销毁之前调用。在这一步，实例仍然完全可用。<br>​    实例要被销毁了，赶在被销毁之前搞点事情吧哈哈~</p><h2 id="destroyed："><a href="#destroyed：" class="headerlink" title="destroyed："></a>destroyed：</h2><p>​    Vue实例销毁后调用。<br>​    此时，Vue实例指示的所有东西已经解绑定，<br>​    所有的事件监听器都已经被移除，<br>​    所有的子实例也已经被销毁。<br>​    这时候能做的事情已经不多了，<br>​    只能加点儿提示toast之类的东西吧。</p><blockquote><p>注：beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed这几个钩子函数，<br>在服务器端渲染期间不被调用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Template 标签指令及属性</title>
      <link href="/2020/04/19/web/vue/template/"/>
      <url>/2020/04/19/web/vue/template/</url>
      
        <content type="html"><![CDATA[<h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>更新元素的 textContent。</p><pre><code class="vue">    &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;    &lt;span&gt;{{msg}}&lt;/span&gt;</code></pre><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>更新元素的 innerHTML 。<br>在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击</p><pre><code class="vue">&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;</code></pre><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>切换元素的 display CSS 属性<br>当条件变化时该指令触发过渡效果。</p><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>根据表达式的值的真假条件渲染元素。<br>当条件变化时该指令触发过渡效果。</p><pre><code class="vue">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;    Now you see me&lt;/div&gt;&lt;div v-else&gt;    Now you don&#39;t&lt;/div&gt;</code></pre><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>基于源数据多次渲染元素或模板块。<br>作用在<code>&lt;template&gt;</code>标签上时，key属性只能写在子标签上</p><pre><code class="vue">&lt;div v-for=&quot;(item, index) in items&quot;  :key=&quot;item.id&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key, index) in object&quot;&gt;&lt;/div&gt;</code></pre><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>缩写：@<br>绑定事件监听器。</p><ul><li>.stop - 调用 event.stopPropagation()。</li><li>.prevent - 调用 event.preventDefault()。</li><li>.capture - 添加事件侦听器时使用 capture 模式。</li><li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li><li>.native - 监听组件根元素的原生事件。</li><li>.once - 只触发一次回调。</li><li>.left - (2.2.0) 只当点击鼠标左键时触发。</li><li>.right - (2.2.0) 只当点击鼠标右键时触发。</li><li>.middle - (2.2.0) 只当点击鼠标中键时触发。</li><li>.passive - (2.3.0) 以 { passive: true } 模式添加侦听器</li></ul><p>在监听原生 DOM 事件时，方法以事件为唯一的参数。</p><pre><code class="vue">    &lt;!-- 方法处理器 --&gt;    &lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 内联语句 --&gt;    &lt;button v-on:click=&quot;doThat(&#39;hello&#39;, $event)&quot;&gt;&lt;/button&gt;    &lt;!-- 缩写 --&gt;    &lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 停止冒泡 --&gt;    &lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 阻止默认行为 --&gt;    &lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 阻止默认行为，没有表达式 --&gt;    &lt;form @submit.prevent&gt;&lt;/form&gt;    &lt;!--  串联修饰符 --&gt;    &lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 键修饰符，键别名 --&gt;    &lt;input @keyup.enter=&quot;onEnter&quot;&gt;    &lt;!-- 键修饰符，键代码 --&gt;    &lt;input @keyup.13=&quot;onEnter&quot;&gt;    &lt;!-- 点击回调只会触发一次 --&gt;    &lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 对象语法 (2.4.0+) --&gt;    &lt;button v-on=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&gt;&lt;/button&gt;在子组件上监听自定义事件    &lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;    &lt;!-- 内联语句 --&gt;    &lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;    &lt;!-- 组件中的原生事件 --&gt;    &lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;</code></pre><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>缩写：:<br>动态地绑定一个或多个特性</p><ul><li><p>.prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？)</p></li><li><p>.camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)</p></li><li><p>.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</p><pre><code class="vue">      &lt;!-- 绑定一个属性 --&gt;      &lt;img v-bind:src=&quot;imageSrc&quot;&gt;      &lt;!-- 内联字符串拼接 --&gt;      &lt;img :src=&quot;&#39;/path/to/images/&#39; + fileName&quot;&gt;      &lt;!-- class 绑定 --&gt;      &lt;div :class=&quot;{ red: isRed }&quot;&gt;&lt;/div&gt;      &lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;      &lt;div :class=&quot;[classA, { classB: isB, classC: isC }]&quot;&gt;      &lt;!-- style 绑定 --&gt;      &lt;div :style=&quot;{ fontSize: size + &#39;px&#39; }&quot;&gt;&lt;/div&gt;      &lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;      &lt;!-- 绑定一个有属性的对象 --&gt;      &lt;div v-bind=&quot;{ id: someProp, &#39;other-attr&#39;: otherProp }&quot;&gt;&lt;/div&gt;      &lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;      &lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;      &lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;      &lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;      &lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;      &lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;      &lt;!-- XLink --&gt;      &lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;      &lt;svg :view-box.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;</code></pre></li></ul><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>在表单控件或者组件上创建双向绑定。<br>限制<code>&lt;input&gt;&lt;select&gt;&lt;textarea&gt;</code>components</p><ul><li>.lazy - 取代 input 监听 change 事件, 即在输入框失焦时change值</li><li>.number - 输入字符串转为有效的数字</li><li>.trim - 输入首尾空格过滤</li></ul><p>使用model自定义value和input，</p><pre><code class="js">        const component = {            model: {                prop: &#39;value1&#39;,                event:&#39;change&#39;            },            props:[&#39;value1&#39;]            methods:{                handleInput(e){                    this.$emit(&#39;change&#39;, e.target.value)                }            }        }</code></pre><h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><p>跳过这个元素和它的子元素的编译过程。<br>跳过大量没有指令的节点会加快编译。</p><pre><code class="vue">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;</code></pre><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p>这个指令保持在元素上直到关联实例结束编译。<br>基本用不到。</p><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>只渲染元素和组件一次。<br>适用于静态组件，不会再去对比dom是否需要更新它。</p><pre><code class="vue">    &lt;!-- 单个元素 --&gt;    &lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;    &lt;!-- 有子元素 --&gt;    &lt;div v-once&gt;        &lt;h1&gt;comment&lt;/h1&gt;        &lt;p&gt;{{msg}}&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 组件 --&gt;    &lt;my-component v-once :comment=&quot;msg&quot;&gt;&lt;/my-component&gt;    &lt;!-- `v-for` 指令--&gt;    &lt;ul&gt;        &lt;li v-for=&quot;i in list&quot; v-once&gt;{{i}}&lt;/li&gt;    &lt;/ul&gt;</code></pre><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。</p><pre><code class="vue">    &lt;ul&gt;        &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>可以用于强制替换元素/组件而不是重复使用它。</p><pre><code class="vue">    &lt;transition&gt;        &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;    &lt;/transition&gt;</code></pre><p>当 text 发生改变时，<code>&lt;span&gt;</code> 会随时被更新，因此会触发过渡。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>给元素或子组件注册引用信息。<br>注册在父组件的 $refs 对象上。</p><pre><code class="vue">    &lt;!-- `vm.$refs.p` will be the DOM node --&gt;    &lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;        &lt;!-- `vm.$refs.child` will be the child component instance --&gt;        &lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;</code></pre><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>用于标记往哪个具名插槽中插入子组件内容。</p><h2 id="slot-scope"><a href="#slot-scope" class="headerlink" title="slot-scope"></a>slot-scope</h2><p>用于将元素或组件表示为作用域插槽。<br>不支持动态绑定。</p><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><p>用于动态组件且基于 DOM 内模板的限制来工作。</p><pre><code class="vue">    &lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;    &lt;component v-bind:is=&quot;currentView&quot;&gt;&lt;/component&gt;        &lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;        &lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;        &lt;table&gt;            &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;        &lt;/table&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 选项</title>
      <link href="/2020/04/19/web/vue/options/"/>
      <url>/2020/04/19/web/vue/options/</url>
      
        <content type="html"><![CDATA[<h1 id="选项-数据"><a href="#选项-数据" class="headerlink" title="选项 数据"></a>选项 数据</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>​        实例接受 object<br>​        组件的定义只接受 function<br>​        可以通过 <code>vm.$data</code>访问原始数据对象<br>​        访问 <code>vm.a</code>等价于访问 <code>vm.$data.a</code>， 不能是_a或$开头的</p><pre><code class="js">        var data = { a: 1 }                // 直接创建一个实例        var vm = new Vue({            data: data        })        vm.a // =&gt; 1        vm.$data === data // =&gt; true        // Vue.extend() 中 data 必须是函数        var Component = Vue.extend({            data: function () {                return { a: 1 }            }        })</code></pre><h2 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h2><p>数组或对象，用于接收来自父组件的数据。</p><pre><code class="js">            // 简单语法            Vue.component(&#39;props-demo-simple&#39;, {                props: [&#39;size&#39;, &#39;myMessage&#39;]            })            // 对象语法，提供校验            Vue.component(&#39;props-demo-advanced&#39;, {                props: {                    // 检测类型                    height: Number,                    // 检测类型 + 其他验证                    age: {                        type: Number,                        default: 0,                        required: true,                        validator: function (value) {                            return value &gt;= 0                        }                    }                }            })</code></pre><h2 id="propsData属性"><a href="#propsData属性" class="headerlink" title="propsData属性"></a>propsData属性</h2><ul><li><p>创建实例时传递 props。主要作用是方便测试。</p></li><li><p>只用于 new 创建的实例中</p><pre><code class="js">          var Comp = Vue.extend({              props: [&#39;msg&#39;],              template: &#39;&lt;div&gt;{{ msg }}&lt;/div&gt;&#39;          })          var vm = new Comp({              propsData: {                  msg: &#39;hello&#39;              }          })</code></pre></li></ul><h2 id="computed计算"><a href="#computed计算" class="headerlink" title="computed计算"></a>computed计算</h2><p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p><pre><code class="js">            var vm = new Vue({                data: { a: 1 },                computed: {                    // 仅读取                    aDouble: function () {                        return this.a * 2                    },                    // 读取和设置                    aPlus: {                        get: function () {                            return this.a + 1                        },                        set: function (v) {                            this.a = v - 1                        }                    }                }            })            vm.aPlus   // =&gt; 2            vm.aPlus = 3            vm.a       // =&gt; 2            vm.aDouble // =&gt; 4</code></pre><h2 id="methods方法"><a href="#methods方法" class="headerlink" title="methods方法"></a>methods方法</h2><ul><li>可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。</li><li>不应该使用箭头函数来定义 method 函数<pre><code class="js">          var vm = new Vue({              data: { a: 1 },              methods: {                  plus: function () {                      this.a++                  }              }          })          vm.plus()          vm.a // 2</code></pre></li></ul><h2 id="watch监听"><a href="#watch监听" class="headerlink" title="watch监听"></a>watch监听</h2><ul><li>一个对象，键是需要观察的表达式，值是对应回调函数。</li><li>值也可以是方法名，或者包含选项的对象。</li><li>不应该使用箭头函数来定义 watcher 函数<pre><code class="js">          var vm = new Vue({              data: {                  a: 1,                  b: 2,                  c: 3,                  d: 4,                  e: {                      f: {                          g: 5                      }                  }              },              watch: {                  a: function (val, oldVal) {                      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)                  },                  // 方法名                  b: &#39;someMethod&#39;,                  // 深度 watcher                  c: {                      handler: function (val, oldVal) { /* ... */ },                      deep: true                  },                  // 该回调将会在侦听开始之后被立即调用                  d: {                      handler: function (val, oldVal) { /* ... */ },                      immediate: true                  },                  e: [                      function handle1 (val, oldVal) { /* ... */ },                      function handle2 (val, oldVal) { /* ... */ }                  ],                  // watch vm.e.f&#39;s value: {g: 5}                  &#39;e.f&#39;: function (val, oldVal) { /* ... */ }              }          })          vm.a = 2 // =&gt; new: 2, old: 1</code></pre></li></ul><h1 id="DOM元素"><a href="#DOM元素" class="headerlink" title="DOM元素"></a>DOM元素</h1><h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。<br>只在由 new 创建的实例中遵守。<br>元素可以用 vm.$el 访问。</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>字符串模板的代替方案<br>该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。<br>templateu将失效</p><pre><code class="js">            template =  `                &lt;comp-one ref=&#39;comp&#39;&gt;                    &lt;span ref=&#39;span&#39;&gt;{{value}}&lt;/span&gt;                &lt;/comp-one&gt;            `</code></pre><p>相当于</p><pre><code class="js">            render(createElement){                return createElement( //根节点                    &#39;comp-one&#39;,                      {                        ref: &#39;comp&#39;,                        // props: {                        //     props1: this.value                        // },                        // on: {                        //     click: this.handleClick                        // }                    },                     [                        //多个子节点                        createElement(&#39;span&#39;,{                            ref:&#39;span&#39;，                            // slot: &#39;header&#39;,                            // domProps:{                            //     innerHTML: &#39;&lt;span&gt;aaa&lt;/span&gt;&#39;                            // },                            // attrs:{                            //     id:&#39;test-id&#39;                            // }                        }),                        this.value                    ]                )            }</code></pre><h2 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a>renderError</h2><p>当 render 函数遭遇错误时，提供另外一种渲染输出。</p><pre><code class="js">            new Vue({                render (h) {                    throw new Error(&#39;oops&#39;)                },                renderError (h, err) {                    return h(&#39;pre&#39;, { style: { color: &#39;red&#39; }}, err.stack)                }            }).$mount(&#39;#app&#39;)</code></pre><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>不能使用箭头函数来定义一个生命周期方法</p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p>在实例创建完成后被立即调用。<br>完成了 数据观测，属性和方法的运算，watch/event 事件回调。<br>但未挂载到$el上</p><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p>在挂载开始之前被调用，render首次调用<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。<br>该钩子在服务器端渲染期间不被调用。<br>你希望等到整个视图都渲染完毕, 可以用 vm.$nextTick</p><pre><code class="js">            mounted: function () {                this.$nextTick(function () {                    // Code that will run only after the                    // entire view has been rendered                })            }</code></pre><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><p>数据更新时调用<br>该钩子在服务器端渲染期间不被调用</p><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>该钩子在服务器端渲染期间不被调用。<br>你希望等到整个视图都渲染完毕, 可以用 vm.$nextTick</p><pre><code class="js">            updated: function () {                this.$nextTick(function () {                    // Code that will run only after the                    // entire view has been re-rendered                })            }</code></pre><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><p>keep-alive 组件激活时调用。<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><p>keep-alive 组件停用时调用。<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><p>实例销毁之前调用。在这一步，实例仍然完全可用。<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><p>Vue 实例销毁后调用。<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h2><p>(err: Error, vm: Component, info: string) =&gt; ?boolean<br>当捕获一个来自子孙组件的错误时被调用。<br>返回 false 以阻止该错误继续向上传播。</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h2><p>自定义指令表</p><h2 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h2><p>过滤器表</p><h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><p>可用组件表</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h2><p>指定父实例，建立父子关系。<br>子实例可以用 this.$parent 访问父实例，<br>子实例被推入父实例的 $children 数组中。<br>更推荐用 props 和 events 实现父子组件通信</p><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>混入对象的数组。</p><pre><code class="js">            var mixin = {                created: function () { console.log(1) }            }            var vm = new Vue({                created: function () { console.log(2) },                mixins: [mixin]            })            // =&gt; 1            // =&gt; 2</code></pre><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>扩展另一个组件</p><pre><code class="js">            var CompA = { ... }            // 在没有调用 `Vue.extend` 时候继承 CompA            var CompB = {                extends: CompA,                ...            }</code></pre><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h2><p>上下文关系，类似于context<br>不推荐直接用于应用程序代码中。</p><pre><code class="js">            // 父级组件提供 &#39;foo&#39;            var Provider = {                provide: {                    foo: &#39;bar&#39;                },                // ...            }            // 子组件注入 &#39;foo&#39;, 但不是响应式的            var Child = {                inject: [&#39;foo&#39;],                created () {                    console.log(this.foo) // =&gt; &quot;bar&quot;                }                // ...            }</code></pre><p>使用get()方法使用provide传递的值会响应到子孙后代</p><pre><code class="js">            new Vue=({                provide(){                    const data = {}                    Object.defineProperty(data, &#39;value&#39;, {                        get:()=&gt;this.value,                        enumerable: true                    })                    return data                }            })</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue options </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueConfig全局配置</title>
      <link href="/2020/04/19/web/vue/config/"/>
      <url>/2020/04/19/web/vue/config/</url>
      
        <content type="html"><![CDATA[<h2 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h2><p>​        boolean<br>​        日志与警告</p><a id="more"></a><h2 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h2><p>​        { [key: string]: Function }<br>​        自定义合并策略的选项</p><h2 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h2><p>​        boolean<br>​        是否允许 vue-devtools 检查代码</p><h2 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h2><p>​        Function (err, vm, info)<br>​        指定组件的渲染和观察期间未捕获错误的处理函数</p><pre><code class="js">import Vue from &#39;vue&#39;Vue.config.errorHandler = function(err, vm, info) {  Vue.nextTick(() =&gt; {    if (process.env.NODE_ENV === &#39;development&#39;) {      console.group(&#39;&gt;&gt;&gt;&gt;&gt;&gt; 错误信息 &gt;&gt;&gt;&gt;&gt;&gt;&#39;)      console.log(info)      console.groupEnd()      console.group(&#39;&gt;&gt;&gt;&gt;&gt;&gt; Vue 实例 &gt;&gt;&gt;&gt;&gt;&gt;&#39;)      console.log(vm)      console.groupEnd()      console.group(&#39;&gt;&gt;&gt;&gt;&gt;&gt; Error &gt;&gt;&gt;&gt;&gt;&gt;&#39;)      console.log(err)      console.groupEnd()    }  })}</code></pre><h2 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a>warnHandler</h2><p>​        Function (msg, vm, trace)<br>​        为 Vue 的运行时警告赋予一个自定义处理函数</p><h2 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h2><p>​        Array&lt;string | RegExp&gt;<br>​        须使 Vue 忽略在 Vue 之外的自定义元素</p><h2 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h2><p>​        { [key: string]: number | Array<number> }<br>​        给 v-on 自定义键位别名</p><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><p>​        boolean<br>​        启用对组件初始化、编译、渲染和打补丁的性能追踪</p><h2 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a>productionTip</h2><p>​        阻止 vue 在启动时生成生产提示</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件</title>
      <link href="/2020/04/19/web/vue/component/"/>
      <url>/2020/04/19/web/vue/component/</url>
      
        <content type="html"><![CDATA[<h2 id="内置的组件"><a href="#内置的组件" class="headerlink" title="内置的组件"></a>内置的组件</h2><h3 id="lt-component-gt-lt-component-gt"><a href="#lt-component-gt-lt-component-gt" class="headerlink" title="&lt;component&gt;&lt;/component&gt;"></a><code>&lt;component&gt;&lt;/component&gt;</code></h3><p>渲染一个“元组件”为动态组件。<br>依 is 的值，来决定哪个组件被渲染。</p><a id="more"></a><pre><code class="vue">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is=&quot;$options.components.child&quot;&gt;&lt;/component&gt;</code></pre><h3 id="lt-transition-gt-lt-transition-gt"><a href="#lt-transition-gt-lt-transition-gt" class="headerlink" title="&lt;transition&gt;&lt;/transition&gt;"></a><code>&lt;transition&gt;&lt;/transition&gt;</code></h3><p>作为单个元素/组件的过渡效果。</p><h4 id="Props："><a href="#Props：" class="headerlink" title="Props："></a>Props：</h4><ul><li>name - string，用于自动生成 CSS 过渡类名。例如：name: ‘fade’ 将自动拓展为.fade-enter，.fade-enter-active等。默认类名为 “v”</li><li>appear - boolean，是否在初始渲染时使用过渡。默认为 false。</li><li>css - boolean，是否使用 CSS 过渡类。默认为 true。如果设置为 false，将只通过组件事件触发注册的 JavaScript 钩子。</li><li>type - string，指定过渡事件类型，侦听过渡何时结束。有效值为 “transition” 和 “animation”。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li><li>mode - string，控制离开/进入的过渡时间序列。有效的模式有 “out-in” 和 “in-out”；默认同时生效。</li><li>enter-class - string</li><li>leave-class - string</li><li>appear-class - string</li><li>enter-to-class - string</li><li>leave-to-class - string</li><li>appear-to-class - string</li><li>enter-active-class - string</li><li>leave-active-class - string</li><li>appear-active-class - string</li><li><h4 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h4></li><li>before-enter</li><li>before-leave</li><li>before-appear</li><li>enter</li><li>leave</li><li>appear</li><li>after-enter</li><li>after-leave</li><li>after-appear</li><li>enter-cancelled</li><li>leave-cancelled (v-show only)</li><li>appear-cancelled</li></ul><pre><code class="vue">        &lt;!-- 简单元素 --&gt;        &lt;transition&gt;            &lt;div v-if=&quot;ok&quot;&gt;toggled content&lt;/div&gt;        &lt;/transition&gt;        &lt;!-- 动态组件 --&gt;        &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt;            &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;        &lt;/transition&gt;        &lt;!-- 事件钩子 --&gt;        &lt;div id=&quot;transition-demo&quot;&gt;            &lt;transition @after-enter=&quot;transitionComplete&quot;&gt;                &lt;div v-show=&quot;ok&quot;&gt;toggled content&lt;/div&gt;            &lt;/transition&gt;        &lt;/div&gt;        new Vue({            ...            methods: {                transitionComplete: function (el) {                    // 传入 &#39;el&#39; 这个 DOM 元素作为参数。                }            }            ...        }).$mount(&#39;#transition-demo&#39;)</code></pre><h3 id="lt-transition-group-gt-lt-transition-group-gt"><a href="#lt-transition-group-gt-lt-transition-group-gt" class="headerlink" title="&lt;transition-group&gt;&lt;/transition-group&gt;"></a><code>&lt;transition-group&gt;&lt;/transition-group&gt;</code></h3><p>作为多个元素/组件的过渡效果。<br>是一个抽象组件</p><h4 id="Props：-1"><a href="#Props：-1" class="headerlink" title="Props："></a>Props：</h4><ul><li>tag - string，默认为 span</li><li>move-class - 覆盖移动过渡期间应用的 CSS 类。</li><li>除了 mode，其他特性和 <transition> 相同。</li></ul><h3 id="lt-keep-alive-gt-lt-keep-alive-gt"><a href="#lt-keep-alive-gt-lt-keep-alive-gt" class="headerlink" title="&lt;keep-alive&gt;&lt;/keep-alive&gt;"></a><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code></h3><p>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。<br>主要用于保留组件状态或避免重新渲染。<br>是一个抽象组件<br>在其中有 v-for 则不会工作。 </p><pre><code class="vue">&lt;!-- 基本 --&gt;&lt;keep-alive&gt;    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt;  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;  &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt;  &lt;keep-alive&gt;      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;  &lt;/keep-alive&gt;&lt;/transition&gt;   </code></pre><h4 id="Props：-2"><a href="#Props：-2" class="headerlink" title="Props："></a>Props：</h4><ul><li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li>max - 数字。最多可以缓存多少组件实例。<pre><code class="vue">&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;</code></pre></li></ul><!-- 正则表达式 (使用 `v-bind`) --><keep-alive :include="/a|b/">    <component :is="view"></component></keep-alive><!-- 数组 (使用 `v-bind`) --><keep-alive :include="['a', 'b']">    <component :is="view"></component></keep-alive>  <keep-alive :max="10">    <component :is="view"></component></keep-alive>```<h3 id="lt-slot-gt-lt-slot-gt"><a href="#lt-slot-gt-lt-slot-gt" class="headerlink" title="&lt;slot&gt;&lt;/slot&gt;"></a><code>&lt;slot&gt;&lt;/slot&gt;</code></h3><ul><li><p>作为组件模板之中的内容分发插槽。</p></li><li><p><code>&lt;slot&gt;</code> 元素自身将被替换。</p><pre><code class="vue">  // &lt;base-layout&gt;组件      &lt;div class=&quot;container&quot;&gt;          &lt;header&gt;              &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;          &lt;/header&gt;          &lt;main&gt;              &lt;slot&gt;&lt;/slot&gt;          &lt;/main&gt;          &lt;footer&gt;              &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;          &lt;/footer&gt;      &lt;/div&gt;</code></pre><pre><code class="vue">      //引用base-layout组件进行插入      &lt;base-layout&gt;          &lt;template slot=&quot;header&quot;&gt;              &lt;h1&gt;Here might be a page title&lt;/h1&gt;          &lt;/template&gt;          &lt;p&gt;A paragraph for the main content.&lt;/p&gt;          &lt;p&gt;And another one.&lt;/p&gt;          &lt;template slot=&quot;footer&quot;&gt;              &lt;p&gt;Here&#39;s some contact info&lt;/p&gt;          &lt;/template&gt;      &lt;/base-layout&gt;</code></pre></li><li><p>slot-scope作用域插槽, 调取引用组件内部的数据</p><pre><code class="vue">      //todo-list组件      &lt;ul&gt;          &lt;li              v-for=&quot;todo in todos&quot;              v-bind:key=&quot;todo.id&quot;          &gt;              &lt;!-- 我们为每个 todo 准备了一个插槽，--&gt;              &lt;!-- 将 `todo` 对象作为一个插槽的 prop 传入。--&gt;              &lt;slot v-bind:todo=&quot;todo&quot;&gt;              &lt;!-- 回退的内容 --&gt;              {{ todo.text }}              &lt;/slot&gt;          &lt;/li&gt;      &lt;/ul&gt;</code></pre></li></ul><pre><code class="vue">        //引用todo-list        &lt;todo-list v-bind:todos=&quot;todos&quot;&gt;            &lt;!-- 将 `slotProps` 定义为插槽作用域的名字 --&gt;            &lt;template slot-scope=&quot;slotProps&quot;&gt;                &lt;!-- 也可以用解构方法 &lt;template slot-scope=&quot;{ todo }&quot;&gt; --&gt;                &lt;!-- 为待办项自定义一个模板，--&gt;                &lt;!-- 通过 `slotProps` 定制每个待办项。--&gt;                &lt;span v-if=&quot;slotProps.todo.isComplete&quot;&gt;✓&lt;/span&gt;                {{ slotProps.todo.text }}            &lt;/template&gt;        &lt;/todo-list&gt;</code></pre><pre><code class="vue">        const component = {            template:`                &lt;div&gt;                    &lt;slot value=&#39;123&#39; abc=&#39;456&#39;&gt;&lt;/slot&gt;                &lt;/div&gt;            `,        }        new Vue({            el: &#39;#root&#39;,            components:{                CompOne: component            },            data:{                value: &#39;000&#39;            },            template:  `                &lt;div&gt;                    &lt;comp-one&gt;                        &lt;span slot-scope=&quot;props&quot;&gt;{{props.value}} {{props.abc}} {{value}}&lt;/span&gt;                    &lt;/comp-one&gt;                &lt;/div&gt;            `        })</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Api</title>
      <link href="/2020/04/19/web/vue/api/"/>
      <url>/2020/04/19/web/vue/api/</url>
      
        <content type="html"><![CDATA[<h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><h3 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend( options )"></a>Vue.extend( options )</h3><p>继承，使用基础 Vue 构造器，创建一个“子类”。</p><a id="more"></a><pre><code class="vue">  // 创建构造器  var Profile = Vue.extend({    template: &#39;&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;&#39;,    data: function () {      return {        firstName: &#39;Walter&#39;,        lastName: &#39;White&#39;,        alias: &#39;Heisenberg&#39;      }    }  })  // 创建 Profile 实例，并挂载到一个元素上。  new Profile().$mount(&#39;#mount-point&#39;)</code></pre><ul><li>可以传入vue选项，传props用propsData，选项会合并，</li><li>但生命周期方法都会被调用</li></ul><h3 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick( [callback, context] )"></a>Vue.nextTick( [callback, context] )</h3><ul><li>在下次 DOM 更新循环结束之后执行延迟回调。</li><li>在修改数据之后立即使用这个方法，获取更新后的 DOM。</li></ul><pre><code class="vue">  // 修改数据  vm.msg = &#39;Hello&#39;  // DOM 还没有更新  Vue.nextTick(function () {      // DOM 更新了  })  // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)  Vue.nextTick()  .then(function () {      // DOM 更新了  })</code></pre><h3 id="Vue-set-target-key-value"><a href="#Vue-set-target-key-value" class="headerlink" title="Vue.set( target, key, value )"></a>Vue.set( target, key, value )</h3><blockquote><p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。</p></blockquote><h3 id="Vue-delete-target-key"><a href="#Vue-delete-target-key" class="headerlink" title="Vue.delete( target, key )"></a>Vue.delete( target, key )</h3><blockquote><p>删除对象的属性。</p></blockquote><h3 id="Vue-directive-id-definition"><a href="#Vue-directive-id-definition" class="headerlink" title="Vue.directive( id, [definition] )"></a>Vue.directive( id, [definition] )</h3><blockquote><p>注册或获取全局指令。</p></blockquote><pre><code class="vue">  // 注册  Vue.directive(&#39;my-directive&#39;, {    bind: function () {},    inserted: function () {},    update: function () {},    componentUpdated: function () {},    unbind: function () {}  })  // 注册 (指令函数)  Vue.directive(&#39;my-directive&#39;, function () {      // 这里将会被 `bind` 和 `update` 调用  })  // getter，返回已注册的指令  var myDirective = Vue.directive(&#39;my-directive&#39;)</code></pre><h3 id="Vue-filter-id-definition"><a href="#Vue-filter-id-definition" class="headerlink" title="Vue.filter( id, [definition] )"></a>Vue.filter( id, [definition] )</h3><blockquote><p>注册或获取全局过滤器。</p></blockquote><pre><code class="vue">  // 注册  Vue.filter(&#39;my-filter&#39;, function (value) {      // 返回处理后的值  })  // getter，返回已注册的过滤器  var myFilter = Vue.filter(&#39;my-filter&#39;)</code></pre><h3 id="Vue-component-id-definition"><a href="#Vue-component-id-definition" class="headerlink" title="Vue.component( id, [definition] )"></a>Vue.component( id, [definition] )</h3><blockquote><p>注册或获取全局组件。</p></blockquote><pre><code class="vue">  // 注册组件，传入一个扩展过的构造器  Vue.component(&#39;my-component&#39;, Vue.extend({ /* ... */ }))  // 注册组件，传入一个选项对象 (自动调用 Vue.extend)  Vue.component(&#39;my-component&#39;, { /* ... */ })  // 获取注册的组件 (始终返回构造器)  var MyComponent = Vue.component(&#39;my-component&#39;)</code></pre><h3 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use( plugin )"></a>Vue.use( plugin )</h3><blockquote><p>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。<br>需要在调用 new Vue() 之前被调用。</p></blockquote><h3 id="Vue-mixin-mixin"><a href="#Vue-mixin-mixin" class="headerlink" title="Vue.mixin( mixin )"></a>Vue.mixin( mixin )</h3><blockquote><p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。<br>不推荐在应用代码中使用。</p></blockquote><h3 id="Vue-compile-template"><a href="#Vue-compile-template" class="headerlink" title="Vue.compile( template )"></a>Vue.compile( template )</h3><blockquote><p>在 render 函数中编译模板字符串。只在独立构建时有效</p></blockquote><pre><code class="vue">  var res = Vue.compile(&#39;&lt;div&gt;&lt;span&gt;{{ msg }}&lt;/span&gt;&lt;/div&gt;&#39;)  new Vue({      data: {      msg: &#39;hello&#39;    },    render: res.render,    staticRenderFns: res.staticRenderFns  })</code></pre><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>在组件内部，this指向vm实例</p><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><p>观察的数据对象</p><h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h3><p>接收到的 props 对象</p><h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><p>使用的根 DOM 元素</p><h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><p>初始化选项</p><h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><p>父实例，有的话</p><h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><p>根 Vue 实例，通常是<code>&lt;APP/&gt;</code></p><h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3><p>直接子组件<br>不保证顺序，也不是响应式的</p><h3 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a>vm.$slots</h3><p>用来访问被插槽分发的内容。<br>每个具名插槽 有其相应的属性<br>default 属性包括了所有没有被包含在具名插槽中的节点。</p><h3 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a>vm.$scopedSlots</h3><p>用来访问作用域插槽。</p><h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><p>一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例<br>子组件引用</p><h3 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a>vm.$isServer</h3><p>是否运行于服务器<br>服务端渲染</p><h3 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a>vm.$attrs</h3><p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。<br>可以通过 v-bind=”$attrs” 传入内部组件</p><h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a>vm.$listeners</h3><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。<br>可以通过 v-on=”$listeners” 传入内部组件</p><h2 id="实例方法-数据"><a href="#实例方法-数据" class="headerlink" title="实例方法 / 数据"></a>实例方法 / 数据</h2><h3 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h3><blockquote><p>观察 Vue 实例变化的一个表达式或计算属性函数。</p></blockquote><pre><code>// 键路径var unwatch = vm.$watch(&#39;a.b.c&#39;, function (newVal, oldVal) {    // 做点什么    },{    deep: true,    immediate: true    })// 函数var unwatch = vm.$watch(  function () {      return this.a + this.b  },  function (newVal, oldVal) {      // 做点什么  }}</code></pre><ul><li>unwatch()     返回一个取消观察函数，用来停止触发回调</li><li>deep             为了发现对象内部值的变化</li><li>immediate     将立即以表达式的当前值触发回调</li><li><h3 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h3>  全局 Vue.set 的别名<pre><code class="vue">  vm.$set(vm.obj,&#39;a&#39;,&#39;123&#39;)</code></pre><h3 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a>vm.$delete</h3>  全局 Vue.delete 的别名</li></ul><h2 id="实例方法-事件"><a href="#实例方法-事件" class="headerlink" title="实例方法 / 事件"></a>实例方法 / 事件</h2><h3 id="vm-on"><a href="#vm-on" class="headerlink" title="vm.$on"></a>vm.$on</h3><p>监听当前实例上的自定义事件。<br>可以由vm.$emit触发。</p><pre><code class="vue">vm.$on(&#39;test&#39;, function (msg) {    console.log(msg)})vm.$emit(&#39;test&#39;, &#39;hi&#39;)// =&gt; &quot;hi&quot;</code></pre><h3 id="vm-once"><a href="#vm-once" class="headerlink" title="vm.$once"></a>vm.$once</h3><p>监听一个自定义事件，但是只触发一次<br>触发之后移除</p><h3 id="vm-off"><a href="#vm-off" class="headerlink" title="vm.$off"></a>vm.$off</h3><p>移除自定义事件监听器。<br>如果没有提供参数，则移除所有的事件监听器</p><h3 id="vm-emit"><a href="#vm-emit" class="headerlink" title="vm.$emit"></a>vm.$emit</h3><p>触发当前实例上的事件</p><pre><code class="vue">  &lt;button v-on:click=&quot;$emit(&#39;welcome&#39;)&quot;&gt;  vm.$emit(&#39;welcome&#39;, &#39;hello&#39;)</code></pre><h2 id="实例方法-生命周期"><a href="#实例方法-生命周期" class="headerlink" title="实例方法 / 生命周期"></a>实例方法 / 生命周期</h2><h3 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h3><p>实例未挂载时可以手动地挂载一个未挂载的实例</p><pre><code class="vue">var MyComponent = Vue.extend({    template: &#39;&lt;div&gt;Hello!&lt;/div&gt;&#39;})// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount(&#39;#app&#39;)</code></pre><h3 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate"></a>vm.$forceUpdate</h3><p>强制更新<br>仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p><h3 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h3><p>将回调延迟到下次 DOM 更新循环之后执行。</p><pre><code class="vue">new Vue({  // ...  methods: {    // ...    example: function () {      // 修改数据      this.message = &#39;changed&#39;      // DOM 还没有更新      this.$nextTick(function () {        // DOM 现在更新了        // `this` 绑定到当前实例        this.doSomethingElse()      })    }  }})</code></pre><h3 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy"></a>vm.$destroy</h3><p>完全销毁一个实例。<br>触发 beforeDestroy 和 destroyed 的钩子。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生态圈</title>
      <link href="/2020/04/17/web/vue/%E7%94%9F%E6%80%81%E5%9C%88/"/>
      <url>/2020/04/17/web/vue/%E7%94%9F%E6%80%81%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">vue</a></h2><p>是一套用于构建用户界面的渐进式框架。</p><h2 id="vue-cli3"><a href="#vue-cli3" class="headerlink" title="vue-cli3"></a><a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">vue-cli3</a></h2><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统</p><pre><code class="bash">npm install -g @vue/clivue create hello-worldcd hello-worldnpm installnpm run serve</code></pre><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vue-router</a></h2><ul><li>介绍<pre><code>    路由管理器。    它和 Vue.js 的核心深度集成，    让构建单页面应用变得易如反掌。</code></pre></li><li>功能<pre><code>    嵌套的路由/视图表    模块化的、基于组件的路由配置    路由参数、查询、通配符    基于 Vue.js 过渡系统的视图过渡效果    细粒度的导航控制    带有自动激活的 CSS class 的链接    HTML5 历史模式或 hash 模式，在 IE9 中自动降级    自定义的滚动条行为</code></pre></li></ul><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex</a></h2><p>​    专为 Vue.js 应用程序开发的状态管理模式。<br>​    </p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>​    数据请求工具，类似fetch，返回Promise函数<br>​    <a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">https://www.npmjs.com/package/axios</a><br>​    <a href="https://www.jianshu.com/p/7a9fbcbb1114" target="_blank" rel="noopener">https://www.jianshu.com/p/7a9fbcbb1114</a><br>​    <a href="https://www.cnblogs.com/nogodie/p/9853660.html" target="_blank" rel="noopener">https://www.cnblogs.com/nogodie/p/9853660.html</a></p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a><a href="https://webpack.docschina.org/guides/" target="_blank" rel="noopener">webpack</a></h3><p>​    打包工具<br>​    </p><h3 id="vue-devtools"><a href="#vue-devtools" class="headerlink" title="vue-devtools"></a><a href="https://github.com/vuejs/vue-devtools#vue-devtools" target="_blank" rel="noopener">vue-devtools</a></h3><p>​    开发工具</p><h3 id="awesome"><a href="#awesome" class="headerlink" title="awesome"></a><a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">awesome</a></h3><p>​    工具链集合<br>​    有打印、导航、存储、认证、IDE、等几百项第三方插件库</p><h3 id="apiCloud"><a href="#apiCloud" class="headerlink" title="apiCloud"></a><a href="https://www.apicloud.com" target="_blank" rel="noopener">apiCloud</a></h3><p>​    线上api数据库，定制APP</p><h2 id="跨平台框架"><a href="#跨平台框架" class="headerlink" title="跨平台框架"></a>跨平台框架</h2><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a><a href="http://weex.apache.org/cn/guide/" target="_blank" rel="noopener">weex</a></h3><p>​    跨平台开发框架，ios/android/web</p><h3 id="weex-ui"><a href="#weex-ui" class="headerlink" title="weex-ui"></a><a href="https://alibaba.github.io/weex-ui/#/cn/weex-ui-report" target="_blank" rel="noopener">weex-ui</a></h3><p>​    起源于阿里内部的一个 Weex 上层 Ui 组件库</p><h3 id="wepy"><a href="#wepy" class="headerlink" title="wepy"></a>wepy</h3><p>​    类vue 小程序/h5 不支持vuex</p><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>​    美团开发的基于vue的跨平台框架，小程序/h5, 支持vuex<br>​    mpvue-router-patach<br>​        以便在mpvue小程序中能使用vue-router的写法<br>​    vuex-persistedstate<br>​        vuex数据持久化，解决F5刷新后数据丢失</p><h2 id="移动端UI库"><a href="#移动端UI库" class="headerlink" title="移动端UI库"></a>移动端UI库</h2><h3 id="mintUI"><a href="#mintUI" class="headerlink" title="mintUI"></a>mintUI</h3><p>​    饿了么开发的基于vue app端</p><h3 id="vonic"><a href="#vonic" class="headerlink" title="vonic"></a>vonic</h3><p>​    app端 简约</p><h3 id="vux"><a href="#vux" class="headerlink" title="vux"></a>vux</h3><p>​    微信小程序 app端 个人开发</p><h3 id="iViewWeapp"><a href="#iViewWeapp" class="headerlink" title="iViewWeapp"></a>iViewWeapp</h3><p>​    iView的app版</p><h3 id="cube-UI"><a href="#cube-UI" class="headerlink" title="cube-UI"></a>cube-UI</h3><p>​    滴滴开发的 app端</p><h2 id="PC端UI库"><a href="#PC端UI库" class="headerlink" title="PC端UI库"></a>PC端UI库</h2><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><p>​    饿了么开发的 pc端</p><h3 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h3><p>​    基于vue的中后台</p><h3 id="vuetify"><a href="#vuetify" class="headerlink" title="vuetify"></a>vuetify</h3><p>​    github start 15k</p><h3 id="vue-strap"><a href="#vue-strap" class="headerlink" title="vue-strap"></a>vue-strap</h3><p>​    基于vue的bootstrap</p><h3 id="at-ui"><a href="#at-ui" class="headerlink" title="at-ui"></a>at-ui</h3><p>​    基于antd pc端</p><h3 id="vue-admin"><a href="#vue-admin" class="headerlink" title="vue-admin"></a>vue-admin</h3><p>​    管理后台</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
            <tag> vue-router </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/17/hello-world/"/>
      <url>/2020/04/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
